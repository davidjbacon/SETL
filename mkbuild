#! /bin/sh
#
# $Id: mkbuild,v 1.47 2022/12/11 17:09:26 setlorg Exp $
#
# Free software (c) dB - see file COPYING for license (GPL).
#
#
# Script to set up a separate build directory with its own GNUmakefile.
#
# Use:  [envt var settings] {source dir}/mkbuild
#
# The created GNUmakefile, like the manually maintained GNUmakefile in
# the source dir, forwards requests to main.mk with loc pointing to the
# source dir.
#
# This script will normally ask on stderr for input on stdin, but that
# prompting can be reduced to zero using the following envt vars:
#
#  default_build  -  default dir to offer if build is unset or empty
# *build          -  build dir (can be .)
# *use            -  if yes, use existing build dir without confirmation
# *srcdir         -  path from build dir to source dir
#
# *If non-null (or use=yes), suppresses any prompt for that value.
#
# If you give srcdir (perhaps just to avoid the prompt), you should also
# specify a build dir that is consistent with that srcdir.
#
# Besides the GNUmakefile, this script also emits into the build dir a
# script called run-setl, which lets you run the built 'setl' command
# without having to install it first.


prt () { printf '%s\n' "$*"; }
rpt () { printf '%s\n' "$*" >&2; }

is_dot() {
  wd2=`(cd "$1" && pwd)`
  test X"`pwd`" = X"$wd2"
}

# The presumed location of this script (the source dir from the point
# of view of the current working dir), and the script's basename:
myloc=`dirname "$0"`
myname=`basename "$0"`

is_dot "$myloc" && myloc=.

# An external command we use:
ask_yes=$myloc/ask-yes

# Best guess on where GNU Make is:
for cmd in gmake make; do
  if $cmd --version 2>/dev/null | grep -q '^GNU Make'; then
    make=$cmd
    break
  fi
done
if test -z "$make"; then
  rpt 'Need GNU Make (as gmake or make) in order to configure GNU SETL.'
  exit 1
fi

# Default default [sic] build dir is a sibling of $myloc:
: ${default_build:=$myloc/../setl-build}

# Strip off any leading "./" or ".\":
#default_build=`prt "$default_build" | sed 's,^\.[/\\],,'`
#default_build=`expr "$default_build" : '\.[/\\]\(.*\)'`
default_build=${default_build#.[/\\]}
# If that leaves it empty, make it ".":
: ${default_build:=.}

if test -z "$build"; then
  rpt "Please enter build dir path (default $default_build):"
  # The user may specify . here to build in the source dir:
  IFS= read -r build || exit 1
  : ${build:=$default_build}
fi

if test -d "$build"; then
  if test x"$use" = xyes; then
    rpt "Using \"$build\" as the build directory."
  else
    $ask_yes "Use existing \"$build\" as the build dir?" >&2 || exit 1
  fi
else
  mkdir -p -- "$build" || exit 1
  rpt "Created directory \"$build\"."
fi

# If the build dir turns out be the current working dir but given by
# a different name, "canonicalize" $build to a single dot:
is_dot "$build" && build=.

if test -z "$srcdir"; then
  # Define $srcdir as a path from $build to the source dir:
  default_srcdir=`"$myloc"/path-from "$build" "$myloc"`;
  if test -n "$default_srcdir"; then
    rpt "Please enter path from build dir to source dir"
    rpt "(default \"$default_srcdir\"), or absolute source path:"
    IFS= read -r srcdir || exit 1
    : ${srcdir:=$default_srcdir}
  else
    rpt "Please enter path from build dir to source dir, or"
    rpt "absolute source pathname (e.g., $HOME/setl-x.y.z):"
    IFS= read -r srcdir || exit 1
  fi

fi

# Sanity check on $srcdir:
(test -n "$srcdir" &&
 cd "$build" &&
 cd "$srcdir" &&
 test -f main.mk) 2>/dev/null ||
{
  rpt "$myname: \"$srcdir\" does not appear to be a valid srcdir."
  exit 1
}

# This function spews a build dir GNUmakefile that is distinct from the
# main GNUmakefile in the source dir.
#
# The double colon on the "%" target makes it "terminal", but because
# no prerequisites are listed, that doesn't reduce its applicability.
# In fact, because of the following (from the "Match-Anything Pattern
# Rules" section of the GNU Make info), it applies even to requests
# that might otherwise be redirected to predefined implicit rules,
# which we certainly don't want to happen here though that might be
# just the thing when the request reaches main.mk in the source dir:
#
#  If you do not mark the match-anything rule as terminal, then it
#  is non-terminal.  A non-terminal match-anything rule cannot apply
#  to a file name that indicates a specific type of data.  A file
#  name indicates a specific type of data if some non-match-anything
#  implicit rule target matches it.
#
#  For example, the file name 'foo.c' matches the target for the
#  pattern rule '%.c : %.y' ...
#
emit_makefile() {
  cat <<EOF
# *** Generated by $srcdir/$myname ***
#
# This makefile uses sources that are in the source tree rooted at
# \$(srcdir) to build GNU SETL in the build tree.  It is meant to be
# invoked in the build tree where it resides.
#
# Use:  $make [goals]

SHELL = /bin/sh

# Root of the source tree:
srcdir = $srcdir

# Pass all requests (a.k.a. targets or goals) on to \$(srcdir)/main.mk;
# POSIX_STRICT helps the QNX 6+ rm, cp, and ls commands behave properly:
forward = POSIX_STRICT=1 \$(MAKE) loc=\$(srcdir) -f \$(srcdir)/main.mk \$@

.DEFAULT_GOAL = all

.PHONY:  all doc

# Special cases - "all" and "doc" have to be .PHONY (doc is a subdir).
# Thus they are not subject to implicit match by the "%" goal below:
all doc:
	+\$(forward)

# General case - double colon so that all other requests will be
# forwarded, even those that might otherwise be intercepted by some
# predefined non-match-anything implicit target (see GNU Make doc):
%::
	+\$(forward)
EOF
}

emit_run_setl() {
  cat <<EOF
#! /bin/sh
# *** Generated by $srcdir/$myname ***
#
# Use:  ./run-setl {args}
#
#  to run the built setl command without having to install it first.
#
: \${srcdir:="$srcdir"}
: \${builddir:=src}
top_builddir=\$builddir "\$srcdir/src/run-setl" "\$@"
EOF
}

build_makefile=$build/GNUmakefile
build_run_setl=$build/run-setl

arrange_makefile() {
  arrange "$build_makefile" emit_makefile
}

arrange_run_setl() {
  arrange "$build_run_setl" emit_run_setl
  chmod +x "$build_run_setl"
}

arrange() {
  dst=$1
  emit=$2
  if test ! -f "$dst"; then
    $emit >"$dst"
    rpt "Created $dst."
  elif ! $emit | cmp -s "$dst" -; then
    rpt "File $dst exists but does not match proposed version:"
    # Linux wc formats numbers differently when its stdin is connected to
    # a pipe vs when it is a file redirection (%7d vs %d, it appears), so
    # to recover consistency we use cat rather than the simpler
    # old_wc=`wc <"$dst"`
    old_wc=`cat "$dst" | wc`
    new_wc=`$emit | wc`
    if test X`expr "$old_wc" : ' *\([0-9][0-9]*\)'` = \
            X`expr "$new_wc" : ' *\([0-9][0-9]*\)'`; then
      # Same number of lines.  Cite the diff.
      $emit | diff -u "$dst" - >&2
    else
      # Different numbers of lines.  Give the basic stats.
      rpt "Existing #lines, #words, #bytes: $old_wc"
      rpt "Proposed #lines, #words, #bytes: $new_wc"
    fi
    if $ask_yes "Overwrite?" >&2; then
      rm -f "$dst"
      $emit >"$dst"
    else
      rpt "Leaving $dst intact and not using it:"
      ls -l "$dst" >&2
    fi
  else
    # The file exists and matches what we would spew.
    rpt "Using existing $dst:"
    ls -l "$dst" >&2
  fi
}

if test x"$myloc" = x. &&
   test x"$build" = x.; then
  # We are in the source dir, and user wants to config and build here.
  # Don't offer to clobber GNUmakefile, as it is the distributed one.
  rpt "Building in source dir."
  rpt "You can later use src/run-setl to try a built setl."
else
  # The wise user has chosen a VPATH build.  Create or update a
  # GNUmakefile and convenient run-setl script in the build dir.
  arrange_makefile
  arrange_run_setl
fi

# Caller of this script expects the chosen build dir name on stdout.
prt "$build"
