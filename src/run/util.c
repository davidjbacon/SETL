/*  ===  Miscellaneous utilities  ==================================  */

/*  $Id: util.c,v 1.56 2021/08/24 00:28:40 setlorg Exp $  */

/*  Free software (c) dB - see file COPYING for license (GPL).  */

#include "setlrun.h"

opndtype find_opndtype(instr *x, long iopnd) {
  long nopnd = x->nopnd;
  switch (x->op) {
/* This file is generated by "opndtypes.awk":  */
#include "opndtypes.c"
  default:
    unexpected (x->op);
  }
}

/*
 *  Test for 0 or more digits and spaces followed by a tab or nul.
 */
bool digital(const char *s) {
  char c;
  while (!separator[(uchar)(c=*s++)]) {
    if (!decdigit[(uchar)c] && c!=' ') return false;
  }
  return true;
}

#if !HAVE_STRCASECMP || !HAVE_DECL_STRCASECMP
bool case_insensitively_equal(const char *s, const char *t) {
  size_t i;
  const size_t n = strlen(s);
  if (n != strlen(t)) return false;
  for (i=0; i!=n; ++i) {
    if (toupper((uchar)s[i]) !=
        toupper((uchar)t[i])) return false;
  }
  return true;
}
#endif

#if !HAVE_DECL_STRNLEN
size_t strnlen(const char *s, size_t n);
#endif
#if !HAVE_STRNLEN
size_t strnlen(const char *s, size_t n) {
  size_t m = 0;
  while (m < n && s[m] != '\0') ++m;
  return m;
}
#endif

/*
 *  Copy up to n bytes, and append a nul.
 *
 *  Despite the strncpy in the name, strncpy_plus_nul() does not
 *  nul-fill bytes out to n (so don't leave sensitive garbage in r),
 *  and clobbers up to n + 1 bytes (because it appends a nul).
 */
char *strncpy_plus_nul(char *r, const char *s, size_t n) {
  const size_t m = strnlen(s, n);  /* m := MIN(strlen(s), n) */
  mvmem(r, s, m);  /* copy m chars */
  r[m] = '\0';     /* append nul */
  return r;
}

/*
 *  Helper for the finite_strcpy() macro.
 */
char *do_finite_strcpy(char *r, const char *s, size_t n) {
  const size_t m = strnlen(s, n);  /* m := MIN(strlen(s), n) */
  if (m < n) {             /* the string fits */
    mvmem(r, s, m);          /* copy it */
    r[m] = '\0';             /* append nul */
  } else {                 /* string is uncomfortably long */
    mvmem(r, s, n-4);        /* copy the first n-4 chars */
    strcpy(&r[n-4], "...");  /* append "...\0" */
  }
  make_printable(r);
  return r;
}

/*
 *  Static finite copy of s, with non-printable chars changed to '?'.
 *  The string is "tamed" in the sense of resisting buffer overflow
 *  exploits, and is intended for use in safely citing fragments of
 *  arbitrary untrusted user-created text in error messages.
 */
const char *tame(const char *s) {
  static char r[TAME_SIZE];
  return finite_strcpy(r, s);
}

/*
 *  Like tame(), but for citing all or part of a quoted string
 *  as it would have been presented to READA, UNSTR, or DENOTYPE.
 */
const char *qtame(char q, const char *s) {
  static char r[TAME_SIZE];
  size_t i, j;
  const size_t m = sizeof r - 1;
  const size_t n = strlen(s);
  r[0] = q;
  for (i=1,j=0; i<m && j<n; ++i,++j) {
    r[i] = s[j];
    if (r[i] == q) r[++i] = q;
  }
  if (i >= m) {
    strcpy(&r[m-3], "...");
  } else {
    r[++i] = '\0';
  }
  make_printable(r);
  return r;
}

/*
 *  Turn every unprintable char in p into a '?' (question mark).
 */
void make_printable(char *p) {
  while (*p != '\0') {
    if (!isprint((uchar)*p)) *p = '?';
    ++p;
  }
}

/*
 *  Spew the message in fmt to stderr, ignoring any errors that
 *  bubble up from fprintf (apart from EINTR, upon which
 *  os_vfprintf retries internally).
 */
void print_stderr(const char *fmt, ...) {
  int saved_errno = errno;
  va_list args;
  va_start(args, fmt);
  os_vfprintf(stderr, fmt, args);
  va_end(args);
  errno = saved_errno;
}

/*
 *  Similar to print_stderr but for the single character c.
 */
void putc_stderr(int c) {
  int saved_errno = errno;
  os_fputc(c, stderr);
  errno = saved_errno;
}

#define ONE_MILLION  (1000*1000)

void zero_timeval (struct timeval *r) {
  r->tv_sec = 0;
  r->tv_usec = 0;
}

bool timeval_is_zero (const struct timeval *t) {
  return t->tv_sec == 0 && t->tv_usec == 0;
}

void assign_timeval (struct timeval *dst,
               const struct timeval *src) {
  dst->tv_sec = src->tv_sec;
  dst->tv_usec = src->tv_usec;
}

void add_timevals (struct timeval *result,
             const struct timeval *a,
             const struct timeval *b) {
  result->tv_sec = a->tv_sec + b->tv_sec;
  result->tv_usec = a->tv_usec + b->tv_usec;
  if (result->tv_usec >= ONE_MILLION) {
    result->tv_sec += 1;
    result->tv_usec -= ONE_MILLION;
  }
}

void subtract_timevals (struct timeval *result,
                  const struct timeval *a,
                  const struct timeval *b) {
  /* Don't compute a->tv_usec - b->tv_usec and then compare that to 0,
   * in a misguided effort to make this code look like add_timevals,
   * lest someone redefine the type of tv_usec to be unsigned:  */
  if (a->tv_usec < b->tv_usec) {
    result->tv_sec = (a->tv_sec - b->tv_sec) - 1;
    result->tv_usec = (a->tv_usec - b->tv_usec) + ONE_MILLION;
  } else {
    result->tv_sec = a->tv_sec - b->tv_sec;
    result->tv_usec = a->tv_usec - b->tv_usec;
  }
}

int compare_timevals (const struct timeval *a,
                      const struct timeval *b) {
  if (a->tv_sec < b->tv_sec) return -1;
  if (a->tv_sec > b->tv_sec) return 1;
  if (a->tv_usec < b->tv_usec) return -1;
  if (a->tv_usec > b->tv_usec) return 1;
  return 0;
}

#define ONE_BILLION  (1000*1000*1000)

struct timespec timespec_plus (struct timespec a,
                               struct timespec b) {
  struct timespec result;
  result.tv_sec = a.tv_sec + b.tv_sec;
  result.tv_nsec = a.tv_nsec + b.tv_nsec;
  if (result.tv_nsec >= ONE_BILLION) {
    result.tv_sec += 1;
    result.tv_nsec -= ONE_BILLION;
  }
  return result;
}

struct timespec timespec_minus (struct timespec a,
                                struct timespec b) {
  struct timespec result;
  if (a.tv_nsec < b.tv_nsec) {
    result.tv_sec = (a.tv_sec - b.tv_sec) - 1;
    result.tv_nsec = (a.tv_nsec - b.tv_nsec) + ONE_BILLION;
  } else {
    result.tv_sec = a.tv_sec - b.tv_sec;
    result.tv_nsec = a.tv_nsec - b.tv_nsec;
  }
  return result;
}

int timespec_compare (struct timespec a,
                      struct timespec b) {
  if (a.tv_sec < b.tv_sec) return -1;
  if (a.tv_sec > b.tv_sec) return 1;
  if (a.tv_nsec < b.tv_nsec) return -1;
  if (a.tv_nsec > b.tv_nsec) return 1;
  return 0;
}

bool timespec_is_zero (struct timespec a) {
  return a.tv_sec == 0 &&
         a.tv_nsec == 0;
}

struct timespec timeval_to_timespec(struct timeval t) {
  struct timespec r;
  r.tv_sec = t.tv_sec;
  r.tv_nsec = t.tv_usec * 1000;
  return r;
}

struct timeval timespec_to_timeval(struct timespec t) {
  struct timeval r;
  r.tv_sec = t.tv_sec;
  r.tv_usec = t.tv_nsec / 1000;
  return r;
}


/* Minor FIXME:  some things currently in sys.c were better in util.c. */


int peek_char(io_buffer *b) {
  int c = get_char(b);
  if (c == EOF) return EOF;
  unget_char(c,b);
  return c;
}

void eat_white(io_buffer *b) {  /* no porn intended */
  int c;
  while ((c = get_char(b)) != EOF && valsep[(uchar)c]) ;
  if (c != EOF) unget_char(c,b);  /* the char after the whitespace */
  /* else b->eof_pending has been set */
}

void span_white(const string *a, long *i) {
  while (*i <= a->nchar && valsep[(uchar)strelt(a,*i)]) ++*i;
}


/*
 *  Write the chars of a STRING to a stream and return true, or fail
 *  at some point and return false, setting errno.
 *
 *  On success, some or all of the chars may be merely buffered and
 *  not written at the POSIX level, depending on the io_buffer settings
 *  and the STRING.
 */
bool put_chars (file *f, string *s) {
  io_buffer *p = f->buffer;
  long i;
  bool r;
  assert (p != NULL);
  r = true;  /* success by default */
  for (i=1; i<=s->nchar && r; i++) {
    r = put_char (strelt(s,i), p);  /* false if flushing sets errno */
  }
  return r;  /* true if errno was not set */
}


static mp_limb_t    zero_limb[1] = {0};
static const mpz_t  const_mpz_zero = MPZ_ROINIT_N (zero_limb, 0);

/*
 *  Wrapper for mpz_roinit_n() that, if the size arg is 0, returns a
 *  pointer to a const zero that actually has one limb allocated (the
 *  limbs arg to alias_mpz() is unused in that case).
 */
mpz_srcptr alias_mpz (mpz_t z, const mp_limb_t *limbs, ssize_t size) {
  return size != 0 ? mpz_roinit_n (z, limbs, size) : const_mpz_zero;
}

/*
 *  Random unsigned long in the range 0 to n-1; n must not be 0.
 */
ulong random_ulong(ulong n) {
  assert (n != 0);
  return gmp_urandomm_ui (randstate, n);
}


table *empty_table(void) {  /* new empty associative table */
  table *t;
  patcre(&t);
  return t;
}

key *string_to_key (string *s) {
  assert (is_string(s));
  return tokey(s);
}

string *key_to_string (key *k) {
  string *s = (string *)unkey(k);
  assert (is_string(s));
  return s;
}

key *num_to_key (long i) {
  small *n = new_small(i);
  return tokey(n);
}

long key_to_num (key *k) {
  small *n = (small *)unkey(k);
  assert (is_small(n));
  return n->weeval;
}

key *ith_key (table *t, long i) {
  subnode *b;
  check (ordsee(t,i,&b));
  assert (is_key(b->k));
  return b->k;
}

block *ith_block (table *t, long i) {
  subnode *b;
  check (ordsee(t,i,&b));
  return b->d;
}

long ith_num (table *t, long i) {
  small *n = (small *)ith_block(t, i);
  return n->weeval;
}

bool has_key (table *t, key *k) {
  subnode *b;
  return keysee(t,k,&b);
}

block *lookup_block (table *t, key *k) {
  subnode *b;
  check (keysee(t,k,&b));
  return b->d;
}

long lookup_num (table *t, key *k) {
  small *n = (small *)lookup_block(t, k);
  return n->weeval;
}

table *lookup_subtable (table *t, key *k) {
  return (table *)lookup_block(t, k);
}

tuple *lookup_tuple (table *t, key *k) {
  return (tuple *)lookup_block(t, k);
}

bool see_block (table *t, key *k, block **a) {
  subnode *b;
  bool r = keysee(t,k,&b);
  if (r) *a = b->d;
  return r;
}

bool see_num (table *t, key *k, long *a) {
  HANDLE ht = ref(t);
  HANDLE hk = ref(k);
  small *n = new_small(*a);
  bool r = see_block(t, k, (block **)&n);
  if (r) *a = n->weeval;
  retire(hk);
  retire(ht);
  return r;
}

bool insert_block (table *t, key *k, block *a) {
  HANDLE ha = ref(a);
  subnode *b;
  bool r = keysub(t,k,&b);
  b->d = a;
  retire(ha);
  return r;  /* true if key already existed; entry clobbered */
}

bool insert_num (table *t, key *k, long a) {
  HANDLE ht = ref(t);
  HANDLE hk = ref(k);
  small *n = new_small(a);
  bool r = insert_block(t, k, (block *)n);
  retire(hk);
  retire(ht);
  return r;
}

bool insert_subtable (table *t, key *k, table *a) {
  return insert_block(t, k, (block *)a);
}

bool insert_tuple (table *t, key *k, tuple *a) {
  return insert_block(t, k, (block *)a);
}

void insert_block_new (table *t, key *k, block *a) {
  check (!insert_block(t,k,a));
}

bool cond_insert_block (table *t, key *k, block *a) {
  HANDLE ha = ref(a);
  subnode *b;
  bool r = keysub(t,k,&b);
  if (!r) b->d = a;
  retire(ha);
  return r;  /* true if key already existed; entry not clobbered */
}

bool cond_insert_num (table *t, key *k, long a) {
  HANDLE ht = ref(t);
  HANDLE hk = ref(k);
  small *n = new_small(a);
  bool r = cond_insert_block(t, k, (block *)n);
  retire(hk);
  retire(ht);
  return r;
}

bool insert_or_get_block (table *t, key *k, block **a) {
  block *c = *a;  HANDLE hc = ref(c);
  subnode *b;
  bool r = keysub(t,k,&b);
  if (!r) b->d = c;  /* add new block */
  else *a = b->d;  /* return ptr to existing block */
  retire(hc);
  return r;
}

bool insert_or_get_num (table *t, key *k, long *a) {
  HANDLE ht = ref(t);
  HANDLE hk = ref(k);
  small *n = new_small(*a);
  bool r = insert_or_get_block(t, k, (block **)&n);
  if (r) *a = n->weeval;
  retire(hk);
  retire(ht);
  return r;
}
