This is setl-lib.info, produced by makeinfo version 7.0.3 from
setl-lib.texi.

INFO-DIR-SECTION High-level programming
START-INFO-DIR-ENTRY
* SETL library:         (setl-lib).    GNU SETL Library Reference.
END-INFO-DIR-ENTRY


File: setl-lib.info,  Node: Top,  Next: Overview,  Up: (dir)

GNU SETL Library Reference
**************************

This info file describes the library of functions, operators, and other
“intrinsics” built into SETL.

SETL is of course the world’s most wonderful programming language.  GNU
SETL implements it along with some proposed extensions.

This file is designed to be viewed with ‘info setl-lib’.

GNU SETL normally comes with HTML and PDF versions too, and current
documents should always be at <https://setl.org/setl/doc/>.

* Menu:

* Overview::              About this Library Reference.
* The Library::           Built-in functions, operators etc.
* Operator Precedence::   Grouping of unary and binary operators.
* Restricted Mode::       Some security for untrusted programs.
* Index::                 Subject index.


File: setl-lib.info,  Node: Overview,  Next: The Library,  Prev: Top,  Up: Top

About this Library Reference
****************************

This document is about the library of functions, operators, etc.
(collectively the “intrinsics”) built into SETL.  As part of the GNU
SETL documentation, it also makes occasional reference to that
implementation of SETL.

For the primary document in the present set, *note the GNU SETL Om:
(setl).


File: setl-lib.info,  Node: The Library,  Next: Operator Precedence,  Prev: Overview,  Up: Top

The Library
***********

SETL has no pointers, and is therefore governed by “value semantics”,
even for arbitrarily nested sets and tuples.  Call arguments are passed
by value, result, or value-result assignment, according as the formal
parameter is ‘rd’ (the default), ‘wr’, or ‘rw’.

SETL has no system of datatype declarations currently, but the function
and operator signatures are shown here as if it were possible to declare
the types of their formal parameters and return values.  Where an
argument can be of any type, the keyword ‘var’ is used.

Those signatures also employ fake typenames for some common cases:
‘stream’ means an ‘integer’ or ‘string’ or 2-‘tuple’ that refers to an
I/O stream; ‘pattern’ means a ‘string’ or 2-‘tuple’ used as a pattern
argument to a string matching function such as ‘mark’; and ‘proc_name’
and ‘proc_ref’ are respectively the fake typenames for what ‘routine’
expects and returns.

A further liberty is taken in cases where the return type depends upon
the values of the arguments and not just upon their types.  For example,
the type of the value returned by ‘val’ depends upon what is in the
input string, and this is reflected in a pair of signatures for ‘val’,
one returning ‘integer’ and the other returning ‘real’.  Similarly,
exponentiation (‘**’) on ‘integer’ arguments returns a ‘real’ when the
second argument is negative, but otherwise an ‘integer’, and again this
is reflected in a pair of signatures.  In cases where a wider range of
return types is possible, the designation ‘var’ is used.  This applies
to the “query” operator (‘?’), ‘arb’, ‘call’, ‘random’, and ‘unstr’.

Finally, when the form of a ‘set’ or ‘tuple’ is restricted, it is often
depicted that way.  For example, an ordered pair of integers may be
shown as ‘[integer, integer]’, and a set of 0 or more strings as
‘{string, ...}’.

If no return type is shown for a given intrinsic, it may be assumed to
return ‘om’ if it returns at all.  Also, ‘om’ may be a possible return
value even though the only types shown are other than ‘om’.  Such cases
are identified in the accompanying descriptions.

Where error cases are described with no specific response such as
setting ‘last_error’, but rather with vague and sinister language like
“erroneous” or “It is an error ...”, the most portable assumption to
make is that unspecified disasters may follow.  Nevertheless, a
“checkout” SETL implementation such as GNU SETL will catch many of the
easy cases such as nonsensical or out-of-bounds arguments passed to an
intrinsic, and bring the program down with a diagnostic for them.

The finer details of many intrinsics are governed by the semantics of
POSIX functions.  The general intention in this spec is that support for
IEEE Std 1003.1-2001 or any newer POSIX standard should suffice.  See
for example The Open Group Base Specifications Issue 7 (2018 edition) -
IEEE Std 1003.1-2017 (Revision of IEEE Std 1003.1-2008)
(http://www.opengroup.org/onlinepubs/9699919799/).  Linux and virtually
all variants of Unix satisfy the system needs of the SETL library, as
does Cygwin (mostly).

* Menu:

* sharp::    ‘#’:  Size of set; length of string or tuple.
* star::    ‘*’:  Multiplication; set intersection; string or tuple replication.
* power::    ‘**’:  Exponentiation.
* plus::    ‘+’:  Addition; set union; concatenation.
* minus::    ‘-’:  Negation or subtraction; set difference.
* slash::    ‘/’:  Division.
* equalities::    ‘=’, ‘/=’:  Equality and inequality.
* comparatives::   ‘<’, ‘>’, ‘<=’, ‘>=’:  Numeric and other comparisons.
* query::    ‘?’:  Query (short-circuiting ‘om’ test).
* abs::    Absolute value; integer value of character; Euclidean norm
* accept::    Accept connection on server socket.
* acos::    Arc cosine.
* and::    Logical conjunction.
* any::    Extract leading character using character set.
* arb::    Arbitrary element of set.
* asin::    Arc sine.
* atan::    Arc tangent.
* atan2::    Arc tangent of quotient.
* bitwise logical ops::    ‘bit_and’, ‘bit_not’, ‘bit_or’, ‘bit_xor’.
* break::    Extract leading substring using character set.
* call::    Indirect call.
* callout::    Call C function.
* ceil::    Ceiling (least integer upper bound).
* char::    Character encoding of small integer.
* chdir::    Change directory.
* clear_error::    Clear system error indicator.
* clock::    Elapsed time in milliseconds.
* close::    Close stream.
* close constants::    Constants for use with ‘close’.
* command_line::    Command-line arguments.
* command_name::    Command name.
* cos::    Cosine.
* cosh::    Hyperbolic cosine.
* date::    Date and time of day.
* denotype::    Type of denotation in string.
* div::    Integer division.
* domain::    Domain of map.
* dup; dup2::    Duplicate file descriptor.
* eof::    End-of-file indicators.
* even::    Test for integer divisible by 2.
* exec::    Execute another program in place of current one.
* exp::    Natural exponential (e raised to a power).
* false::    Predefined boolean value.
* fdate::    Format date and time.
* fexists::    Test for existence of file.
* filename::    Name of stream.
* fileno::    File descriptor of stream.
* filepos::    Current file position or number of bytes transferred.
* filter::    Filter string through external command.
* fix::    Truncate ‘real’ number to ‘integer’.
* fixed::    Format number with optional decimal point.
* float::    Convert number to ‘real’.
* floating::    Format number in scientific notation.
* floor::    Floor (greatest integer lower bound).
* flush::    Flush output buffer.
* fork::    Fork into parent and child process.
* from::    Take arbitrary element from set.
* fromb::    Take from beginning of string or tuple.
* frome::    Take from end of string or tuple.
* fsize::    Size of file in bytes.
* ftrunc::    Set size of file in bytes.
* get::    Read lines from ‘stdin’.
* geta::    Read lines from stream.
* getb::    Read values from stream.
* getc::    Read character from stream.
* getchar::    Read character from ‘stdin’.
* getegid::    Get effective group ID.
* getenv::    Get value of environment variable.
* geteuid::    Get effective user ID.
* getfile::    Read stream up to the end.
* getgid::    Get real group ID.
* getline::    Read line from stream.
* getn::    Read fixed number of characters from stream.
* getpgrp::    Get process group ID.
* getpid::    Get process ID.
* getppid::    Get parent process ID.
* gets::    Direct-access read.
* getsid::    Get session ID.
* getuid::    Get real user ID.
* getwd::    Current working directory.
* glob::    Pathname wildcard expansion.
* gmark::    Find all occurrences of pattern in string.
* gsub::    Replace patterns in string.
* hex::    Convert string to hexadecimal.
* hostaddr::    Current host address.
* hostname::    Current host name.
* ichar::    Integer code for character.
* impl::    Implication.
* in::    Membership test; iterator form.
* incs::    Subset test.
* intslash::    Integer quotient type switch.
* ip_addresses::    Internet host addresses.
* ip_names::    Internet host names.
* type-testing::    is_TYPE:  Type testing.
* is_open::    Test for being a stream.
* join::    Concatenate tuple of strings, with delimiter.
* kill::    Send signal to process.
* last_error::    Last error message from system function.
* len::    Extract leading substring by length.
* less::    Set less given element.
* lessf::    Map less given domain element.
* lexists::    Test for existence of file or symlink.
* link::    Create hard link.
* log::    Natural logarithm.
* lpad::    Pad string on left with blanks.
* magic::    Regular expression recognition switch.
* mark::    Find first occurrence of pattern in string.
* match::    Extract leading substring by exact match.
* max::    Maximum.
* min::    Minimum.
* mkstemp::    Create and open temporary file.
* mod::    Integer modulus; symmetric set difference.
* nargs::    Number of arguments given by caller.
* newat::    Create new atom.
* no_error::    Non-error message.
* not::    Logical negation.
* notany::    Extract leading character using character set.
* notin::    Membership test.
* npow::    All subsets of a given size.
* nprint::    Print to ‘stdout’ with no trailing newline.
* nprinta::    Print to stream with no trailing newline.
* odd::    Test for integer not divisible by 2.
* om::    The “undefined” value.
* open::    Open a stream.
* or::    Logical disjunction.
* peekc::    Peek at next character in stream.
* peekchar::    Peek at next character in ‘stdin’.
* peer_address::    Peer host address.
* peer_name::    Peer host name.
* peer_port::    Peer port number.
* peer_sockaddr::    Peer address and port number.
* pexists::    Test for existence of processes.
* pid::    Process ID of connected child.
* pipe::    Create primitive pipe.
* pipe_from_child::    Pipe from child process.
* pipe_to_child::    Pipe to child process.
* port::    Internet port number.
* pow::    Power set.
* pretty::    Printable ASCII rendering of string.
* print::    Print to ‘stdout’.
* printa::    Print to stream.
* pump::    Bidirectional stream to child process.
* put::    Write lines to ‘stdout’.
* puta::    Write lines to stream.
* putb::    Write values to stream.
* putc::    Write characters to stream.
* putchar::    Write characters to ‘stdout’.
* putfile::    Write characters to stream.
* putline::    Write lines to stream.
* puts::    Direct-access write.
* random::    Pseudo-random numbers and selections.
* range::    Range of map.
* rany::    Extract trailing character using character set.
* rbreak::    Extract trailing substring using character set.
* rlen::    Extract trailing substring by length.
* rmatch::    Extract trailing substring by exact match.
* rnotany::    Extract trailing character using character set.
* rspan::    Extract trailing substring using character set.
* read::    Read values from one or more lines of ‘stdin’.
* reada::    Read values from one or more lines of stream.
* readlink::    Symbolic link referent.
* reads::    Read values from a string.
* recv::    Receive datagram on UDP client socket.
* recvfrom::    Receive datagram on server socket.
* recv_fd::    Receive file descriptor.
* rem::    Integer remainder.
* rename::    Rename file.
* reverse::    Reverse string.
* rewind::    Rewind direct-access stream.
* round::    Round to nearest integer.
* routine::    Create procedure reference.
* rpad::    Pad string on right with blanks.
* seek::    Reposition direct-access stream.
* seek constants::    Constants for use with ‘seek’.
* select::    Wait for event or timeout.
* send::    Send datagram on client socket.
* sendto::    Send datagram on server socket.
* send_fd::    Send file descriptor.
* setctty::    Acquire controlling terminal.
* setegid::    Set effective group ID.
* setenv::    Set environment variable.
* seteuid::    Set effective user ID.
* setgid::    Set group ID.
* setpgid::    Set process group ID.
* setrandom::    Set random seed.
* setsid::    Create new session.
* setuid::    Set user ID.
* set_intslash::    Muck with integer division semantics.
* set_magic::    Regular expression recognition.
* shutdown::    Disable I/O in one or both directions.
* shutdown constants::    Constants for use with ‘shutdown’.
* sign::    Sign.
* sin::    Sine.
* sinh::    Hyperbolic sine.
* sockaddr::    Internet address and port number.
* socketpair::    Create bidirectional local channel.
* span::    Extract leading substring using character set.
* split::    Split string into tuple.
* sqrt::    Square root.
* status::    Child process status.
* standard streams::    Standard input, output, and error file descriptors.
* str::    String representation of value.
* strad::    Radix-prefixed string representation of integer.
* sub::    Replace pattern in string.
* subset::    Subset test.
* symlink::    Create symbolic link.
* system::    Run command in subshell.
* sys_read::    Low-level read.
* sys_write::    Low-level write.
* tan::    Trigonometric tangent.
* tanh::    Hyperbolic tangent.
* tcgetpgrp::    Get foreground process group ID.
* tcsetpgrp::    Put process group into foreground.
* tie::    Auto-flush stream upon input from other stream.
* time::    Elapsed CPU time in milliseconds.
* to_lower::    Convert string to lowercase.
* to_upper::    Convert string to uppercase.
* tod::    Calendar time in milliseconds.
* true::    Predefined boolean value.
* tty_pump::    Master end of child stream over pseudo-terminal.
* type::    Type of SETL value.
* umask::    Set file mode creation mask.
* ungetc::    Push characters back into stream.
* ungetchar::    Push characters back into ‘stdin’.
* unhex::    Convert from hexadecimal.
* unlink::    Destroy file reference.
* unpretty::    Convert string from “pretty” form.
* unsetctty::    Relinquish controlling terminal.
* unsetenv::    Remove environment variable definition.
* unstr::    Read value from string.
* untie::    Dissolve stream association made by ‘tie’.
* val::    Read numeric value from string.
* wait::    Wait for any child process status change.
* waitpid::    Wait for child process status change.
* whole::    Format integer.
* with::    Set plus one element.
* write::    Write values to ‘stdout’.
* writea::    Write values to stream.


File: setl-lib.info,  Node: sharp,  Next: star,  Up: The Library

“sharp” (‘#’)  -  size of set; length of string or tuple
========================================================

     op # (set) : integer
     op # (string) : integer
     op # (tuple) : integer

The size (cardinality) of a set is the number of elements.  The length
of a tuple is the index of its last non-‘om’ element.


File: setl-lib.info,  Node: star,  Next: power,  Prev: sharp,  Up: The Library

“star” (‘*’)  -  multiplication; set intersection; string or tuple replication
==============================================================================

     op * (integer, integer) : integer
     op * (real, real) : real
     op * (real, integer) : real
     op * (integer, real) : real
     op * (set, set) : set
     op * (string, integer) : string
     op * (integer, string) : string
     op * (tuple, integer) : tuple
     op * (integer, tuple) : tuple

When one operand is ‘real’ and the other ‘integer’, the ‘integer’ value
is converted as if by ‘float’ before the numbers are multiplied.

In a bounded floating-point implementation such as 64-bit IEEE 754,
multiplication can overflow to a floating-point infinity, or underflow
to a subnormal number or a zero.  Multiplying an infinity by 0 can
produce a NaN (“Not a Number”).  Multiplying a NaN by anything gives
another NaN.

For a pair of ‘set’ operands, this operator gives the set intersection,
i.e., for sets A and B, ‘A*B’ = ‘{X in A | X in B}’.  (The first ‘in’
iterates over A, the vertical bar means “such that”, and the second ‘in’
tests for membership in B.)

For the cases involving a ‘string’ or ‘tuple’, the result is the
concatenation of however many copies of that string or tuple are
indicated by the ‘integer’ operand.


File: setl-lib.info,  Node: power,  Next: plus,  Prev: star,  Up: The Library

“power” (‘**’)  -  exponentiation
=================================

     op ** (integer, integer) : integer
     op ** (integer, integer) : real
     op ** (real, real) : real
     op ** (real, integer) : real
     op ** (integer, real) : real

The first operand is the base, and the second is the power to raise it
to.

When both operands are of type ‘integer’, the return type is ‘integer’
unless the power is negative, in which case the operands are first
converted as if by ‘float’, as is the ‘integer’ operand in the mixed
cases.

When the power is 0, the result is 1 regardless of the base, in the type
appropriate for the operands.

In a bounded floating-point implementation such as 64-bit IEEE 754, this
operator works like POSIX pow() for all cases that return a ‘real’.

It is right-associative, which is an incompatible change from CIMS SETL
but agrees with SETL2 and with the Fortran operator it resembles.  It
has higher precedence than all other binary operators, just below all
non-predicate unary operators.  *Note Operator Precedence::.


File: setl-lib.info,  Node: plus,  Next: minus,  Prev: power,  Up: The Library

“plus” (‘+’)  -  addition; set union; concatenation
===================================================

     op + (integer) : integer
     op + (real) : real
     op + (integer, integer) : integer
     op + (real, real) : real
     op + (real, integer) : real
     op + (integer, real) : real
     op + (set, set) : set
     op + (string, string) : string
     op + (tuple, tuple) : tuple
     op + (string, var) : string
     op + (var, string) : string

The unary forms simply check that the operand is a number and return
that number.

When one operand is ‘real’ and the other ‘integer’, the ‘integer’ value
is converted as if by ‘float’ before the numbers are added.

In a bounded floating-point implementation such as 64-bit IEEE 754,
addition can overflow to a floating-point infinity, or underflow to a
subnormal number.  Addition of opposite infinities can produce a NaN
(“Not a Number”).  Adding a NaN to anything gives another NaN.

For a pair of ‘set’ operands, this operator gives the set union, i.e.,
all elements from both sets.  See also ‘with’.

The cases in which just one operand is a ‘string’ are treated as if
‘str’ is first applied to the non-string operand (shown here as ‘var’),
for string concatenation.

The assigning ‘+:=’ operator, when its left-hand operand is initially
‘om’, substitutes the additive identity (if any) of the type of its
right-hand operand.  So for example

     SUM +:= NUM

does not require SUM to be pre-initialized before NUM is added to it.
Here are the additive identities:

‘integer’          0
‘real’             0.0
‘string’           the empty string, ""
‘set’              the empty set, ‘{}’
‘tuple’            the empty tuple, ‘[]’

It is an error for the left-hand side of ‘+:=’ to be ‘om’ if the type of
the right-hand side has no additive identity.

Note that when X is ‘om’,

     X +:= "some string"

is slightly different from

     X := X + "some string"

as the latter is then equivalent to

     X := str om + "some string"

or in other words

     X := "*some string"

Also,

     N +:= 1

gives N the value 1 if it is initially ‘om’, but

     N := N + 1

is an error (trying to add ‘om’ and a number).

Similarly, trying to accumulate a ‘set’ or ‘tuple’ into an uninitialized
variable using plain ‘+’ rather than the assigning form ‘+:=’ is an
error.


File: setl-lib.info,  Node: minus,  Next: slash,  Prev: plus,  Up: The Library

“minus” (‘-’)  -  negation or subtraction; set difference
=========================================================

     op - (integer) : integer
     op - (real) : real
     op - (integer, integer) : integer
     op - (real, real) : real
     op - (real, integer) : real
     op - (integer, real) : real
     op - (set, set) : set

When one operand is ‘real’ and the other ‘integer’, the ‘integer’ value
is converted as if by ‘float’ before the numbers are subtracted.

In a bounded floating-point implementation such as 64-bit IEEE 754,
subtraction can overflow to a floating-point infinity, or underflow to a
subnormal number.  Subtraction of equal infinities can produce a NaN
(“Not a Number”), and a NaN operand gives a NaN result.

For a pair of ‘set’ operands, this operator gives the set difference,
i.e., for sets A and B, ‘A - B’ = ‘{X in A | X notin B}’.

See also ‘less’, and the symmetric set difference operator ‘mod’.


File: setl-lib.info,  Node: slash,  Next: equalities,  Prev: minus,  Up: The Library

“slash” (‘/’)  -  division
==========================

     op / (integer, integer) : real     -- when intslash is false
     op / (integer, integer) : integer  -- when intslash is true
     op / (real, real) : real
     op / (real, integer) : real
     op / (integer, real) : real

By default, all ‘integer’ operands are converted as if by ‘float’, and
the result is ‘real’.  You would normally use ‘div’ to get integer
quotients.

But you can force this “slash” operator to work like ‘div’ for the
‘integer / integer’ case by setting ‘intslash := ‘true’’, or
equivalently by calling ‘set_intslash (true)’.  This makes the slash
operator mimic SETL2, which entails some peril.  Consider a program that
reads pairs of numbers and computes their quotients.  Unless it takes
care to ensure that at least one operand is ‘real’, say by applying
‘float’, such a program will sometimes truncate quotients and sometimes
not, depending on which input numbers happen to have decimal points (or
exponents) in them.

Division of ‘real’s, if the floating-point implementation is 64-bit IEEE
754, can produce an infinity by means of overflow or a divisor of 0, or
can underflow to a subnormal number or a zero.  Division of infinities
gives a NaN (“Not a Number”), and a NaN operand gives a NaN result.


File: setl-lib.info,  Node: equalities,  Next: comparatives,  Prev: slash,  Up: The Library

“equalities” (‘=’, ‘/=’)  -  equal, not equal
=============================================

     op = (var, var) : boolean
     op /= (var, var) : boolean

In most cases, two values of different types are considered unequal.
But in the special case where an ‘integer’ and ‘real’ are numerically
equal, they are considered equal despite their differing types.

A floating-point NaN (“Not a Number”) never equals anything, not even
another bit-identical NaN.


File: setl-lib.info,  Node: comparatives,  Next: query,  Prev: equalities,  Up: The Library

“comparatives” (‘<’, ‘>’, ‘<=’, ‘>=’)  -  order-based comparisons
=================================================================

     op < (integer, integer) : boolean
     op < (real, real) : boolean
     op < (real, integer) : boolean
     op < (integer, real) : boolean
     op < (string, string) : boolean
     op < (tuple, tuple) : boolean
     op > (integer, integer) : boolean
     op > (real, real) : boolean
     op > (real, integer) : boolean
     op > (integer, real) : boolean
     op > (string, string) : boolean
     op > (tuple, tuple) : boolean
     op <= (integer, integer) : boolean
     op <= (real, real) : boolean
     op <= (real, integer) : boolean
     op <= (integer, real) : boolean
     op <= (string, string) : boolean
     op <= (tuple, tuple) : boolean
     op >= (integer, integer) : boolean
     op >= (real, real) : boolean
     op >= (real, integer) : boolean
     op >= (integer, real) : boolean
     op >= (string, string) : boolean
     op >= (tuple, tuple) : boolean

Strings are compared character by character, as if using the codes
arising from ‘ichar’.  Tuple comparisons are recursive.  If one string
or tuple is a prefix of the other, the shorter one is considered
smaller.

Where one operand is ‘integer’ and the other is ‘real’, the ‘integer’ is
converted as if by ‘float’ before comparison.

Comparison of a floating-point NaN (“Not a Number”) with anything yields
‘false’.

See also ‘max’ and ‘min’.


File: setl-lib.info,  Node: query,  Next: abs,  Prev: comparatives,  Up: The Library

“query” (‘?’)  -  short-circuiting ‘om’ test
============================================

     op ? (var, var) : var

The expression

     X ? Y

is equivalent to the expression

     if (TEMP := X) /= om then TEMP else Y end

(or simply

     if X /= om then X else Y end

if X has no side-effects).

Thus the query operator is “short-circuited” like ‘and’ and ‘or’.


File: setl-lib.info,  Node: abs,  Next: accept,  Prev: query,  Up: The Library

‘abs’  -  absolute value; integer value of character; Euclidean norm
====================================================================

     op abs (integer) : integer
     op abs (real) : real
     op abs (string) : integer
     op abs (tuple) : real

For a number, ‘abs’ returns the magnitude.

For a ‘string’, ‘abs’ is equivalent to ‘ichar’.

For a ‘tuple’ T of numbers,

     abs T = sqrt (0 +/ [X**2 : X in T])

Thus for a complex number represented by ‘[X, Y]’, its magnitude is
‘abs [X, Y]’.  Its phase is ‘Y atan2 X’.


File: setl-lib.info,  Node: accept,  Next: acos,  Prev: abs,  Up: The Library

‘accept’  -  accept connection on server socket
===============================================

     proc accept (stream) : integer

The argument must be a TCP or Unix-domain server socket opened by
‘open’, or denote a host and TCP port to auto-open in "tcp-server" mode
(*note Automatic opening::).

The ‘accept’ function waits for a client to connect, and then returns a
new stream (over a new socket fd) for that peer connection.

The ‘select’ function can be used on a server socket to test whether an
‘accept’ would block on it.

It is possible for ‘accept’ to fail due to conditions arising between
the time of a successful ‘select’ and the issuing of the ‘accept’ call.
In this case ‘accept’ sets ‘last_error’ and returns ‘om’.

See also ‘peer_address’, ‘peer_name’, ‘peer_port’, ‘peer_sockaddr’,
‘sockaddr’, and the "unix-server" mode of ‘open’.


File: setl-lib.info,  Node: acos,  Next: and,  Prev: accept,  Up: The Library

‘acos’  -  arc cosine
=====================

     op acos (real) : real
     op acos (integer) : real

The operand must be in the range -1 to +1, and the result is in radians.
See also ‘cos’.


File: setl-lib.info,  Node: and,  Next: any,  Prev: acos,  Up: The Library

‘and’  -  logical conjunction
=============================

     op and (boolean, boolean) : boolean

The expression

     X and Y

is equivalent to the expression

     if X then Y else false end

which is to say that the ‘and’ operator is “short-circuited”: it only
evaluates Y if X is ‘true’.  This makes it suitable for use as a guard
against erroneous evaluations such as subscripting a tuple with a
nonpositive integer.  For example,

     if I > 0 then
       if T(I) = "/" then
         ...
       end if;
     end if;

can be replaced by

     if I > 0 and T(I) = "/" then
       ...
     end if;

See also ‘or’ and the “query” operator (‘?’), which are likewise
short-circuited, and the bitwise operators such as ‘bit_and’, which
aren’t.

The ‘and’ operator has a rather low precedence, above ‘or’ but below
‘not’.


File: setl-lib.info,  Node: any,  Next: arb,  Prev: and,  Up: The Library

‘any’  -  extract leading character using character set
=======================================================

     proc any (rw string S, string P) : string

If the first character of S appears anywhere in P (treating P as a set
of characters), that first character is removed from S and returned.
Otherwise, nothing happens to S, and the empty string ("") is returned.

See also the other SNOBOL-inspired intrinsics, namely ‘break’, ‘len’,
‘match’, ‘notany’, ‘span’, ‘rany’, ‘rbreak’, ‘rlen’, ‘rmatch’,
‘rnotany’, and ‘rspan’.  The inspiration is pretty much confined to the
reuse of these names, as they are rather clumsy in their present form.
But SETL currently has neither the syntactic nor semantic support for
SNOBOL-like chained pattern matching with backtracking and easy
extraction of intermediate substrings and positions into variables.


File: setl-lib.info,  Node: arb,  Next: asin,  Prev: any,  Up: The Library

‘arb’  -  arbitrary element of set
==================================

     op arb (set) : var

An arbitrary (not _random_, but dealer’s choice) element of the set is
returned.  If the set is empty, ‘om’ is returned.

See also ‘from’ and ‘random’.


File: setl-lib.info,  Node: asin,  Next: atan,  Prev: arb,  Up: The Library

‘asin’  -  arc sine
===================

     op asin (real) : real
     op asin (integer) : real

The operand must be in the range -1 to +1, and the result is in radians.
See also ‘sin’.


File: setl-lib.info,  Node: atan,  Next: atan2,  Prev: asin,  Up: The Library

‘atan’  -  arc tangent
======================

     op atan (real) : real
     op atan (integer) : real

The result is in radians.  See also ‘atan2’ and ‘tan’.


File: setl-lib.info,  Node: atan2,  Next: bitwise logical ops,  Prev: atan,  Up: The Library

‘atan2’  -  arc tangent of quotient
===================================

     op atan2 (real, real) : real
     op atan2 (real, integer) : real
     op atan2 (integer, real) : real
     op atan2 (integer, integer) : real

For non-zero X, the expression

     Y atan2 X

is similar to the expression

     atan (Y/X)

but when X is 0, only the ‘atan2’ form can be used, and returns a
floating-point approximation of pi/2 or -pi/2 depending on the sign of Y
(or 0 if Y is 0).

SETL does not currently have “first class” support for complex numbers,
but for such a number with real part X and imaginary part Y, its phase
is ‘Y atan2 X’ and its magnitude is ‘abs [X, Y]’.


File: setl-lib.info,  Node: bitwise logical ops,  Next: break,  Prev: atan2,  Up: The Library

‘bit_and’, ‘bit_not’, ‘bit_or’, ‘bit_xor’  -  bitwise logical ops
=================================================================

     op bit_and (integer, integer) : integer
     op bit_not (integer) : integer
     op bit_or (integer, integer) : integer
     op bit_xor (integer, integer) : integer

These operators treat integers as if they were expressed in 2’s
complement with an infinite sequence of leading 0 or 1 digits.  For
example, ‘bit_not 1 = -2’.

See also ‘and’, ‘or’, and ‘not’.


File: setl-lib.info,  Node: break,  Next: call,  Prev: bitwise logical ops,  Up: The Library

‘break’  -  extract leading substring using character set
=========================================================

     proc break (rw string S, string P) : string

An initial substring of S up to but not including the first character
that is found in P (treating P as a set of characters) is removed
(“broken off”) from S and returned.  If no character from P appears in
S, the return value is the initial value of S, and S is reduced to the
empty string ("").

See also the other SNOBOL-inspired intrinsics, namely ‘any’, ‘len’,
‘match’, ‘notany’, ‘span’, ‘rany’, ‘rbreak’, ‘rlen’, ‘rmatch’,
‘rnotany’, and ‘rspan’.


File: setl-lib.info,  Node: call,  Next: callout,  Prev: break,  Up: The Library

‘call’  -  indirect call
========================

     proc call (proc_ref, var ARGS(*)) : var

All of the 0 or more ARGS to ‘call’ are read-only, so the procedure
referenced through the ‘proc_ref’ value must not have any ‘rw’ or ‘wr’
arguments.  It may, however, _return_ a result of any type, including
‘tuple’, so multiple values can easily be returned, e.g.:

     F_REF := routine F;
       ...
     [X, Y, Z] := call (F_REF, A, B);
       ...
     proc F (V, W);
       ...
       return [P, Q, R];
     end proc F;


File: setl-lib.info,  Node: callout,  Next: ceil,  Prev: call,  Up: The Library

‘callout’  -  call C function
=============================

     proc callout (integer SERVICE, om, tuple ARGLIST) : string

This is a SETL2 compatibility feature.  It calls a C function having the
signature

     char *setl2_callout (int SERVICE, int ARGC, char *const *ARGV)

by first converting SERVICE to a C ‘int’ and ARGLIST (which must contain
only ‘string’s) to the pair of callout arguments ARGC (the number of
strings) and ARGV (an array of pointers to C character strings).

The result of the call, a C character string, is then converted to a
SETL ‘string’ and returned by ‘callout’.

GNU SETL comes with a “stub” version of ‘setl2_callout’ that simply
reports details of the call on stderr and then returns a ‘NULL’ pointer,
causing ‘callout’ to return ‘om’.


File: setl-lib.info,  Node: ceil,  Next: char,  Prev: callout,  Up: The Library

‘ceil’  -  ceiling (least integer upper bound)
==============================================

     op ceil (real) : integer
     op ceil (integer) : integer

This operator returns the smallest integer that is greater than or equal
to the given operand.

For example, ‘ceil -5.9 = -5’.

Floating-point infinities and NaN (“Not a Number”) values give ‘om’.

See also ‘floor’, ‘round’, ‘fix’, and ‘float’.


File: setl-lib.info,  Node: char,  Next: chdir,  Prev: ceil,  Up: The Library

‘char’  -  character encoding of small integer
==============================================

     op char (integer) : string

This operator makes a one-byte string rather directly from the operand,
which must be an integer in the range 0 to 255.  For example,
‘char 32 = "\x20"’.

In SETL, NUL characters may occur within strings, so ‘char 0’, or
equivalently "\x00", is valid.

See also ‘ichar’.


File: setl-lib.info,  Node: chdir,  Next: clear_error,  Prev: char,  Up: The Library

‘chdir’  -  change directory
============================

     proc chdir
     proc chdir (string S)

The current working directory (“folder”) is changed to S if given and
valid.  Otherwise, if the ‘HOME’ environment variable is defined and
names a valid directory, the working directory becomes that.

It is an error for ‘chdir’ to be called with no arg if ‘HOME’ is not
defined.

If S is given but not valid, or if S is not given and ‘HOME’ is defined
but not valid, then the current working directory is not changed, and
‘last_error’ tells why.  For example, the reason might be a nonexistent
directory, a file that is not a directory, or insufficient permission to
open the directory, as ruled by POSIX chdir().

See also ‘getwd’.


File: setl-lib.info,  Node: clear_error,  Next: clock,  Prev: chdir,  Up: The Library

‘clear_error’  -  clear system error indicator
==============================================

     proc clear_error

Sets ‘last_error’ to ‘no_error’.

For example, a doubtful ‘chdir’ call could be guarded thus:

     clear_error;
     chdir ("somewhere");
     if last_error = no_error then
       -- success ...
     else  -- the string last_error explains
       -- failure ...
     end if;


File: setl-lib.info,  Node: clock,  Next: close,  Prev: clear_error,  Up: The Library

‘clock’  -  elapsed time in milliseconds
========================================

     proc clock : integer

This is the total amount of wall-clock (“real”) time, in milliseconds,
that has elapsed since the current process began.  It is a monotonic
clock, and does not depend on changes to the time within the epoch.

See also ‘time’ and ‘tod’.


File: setl-lib.info,  Node: close,  Next: close constants,  Prev: clock,  Up: The Library

‘close’  -  close stream
========================

     proc close (stream F)
     proc close (stream F, integer HOW)

If F is a stream, i.e., if ‘is_open F’ is ‘true’, then it is flushed as
if by ‘flush’ and destroyed.  Any stream associated with F by ‘tie’ is
also flushed, and the association is dissolved.  Output failures in the
flushing are _not_ reflected in ‘last_error’.

The underlying file descriptor (F itself or the associated fd) is passed
to POSIX close() if it is in the range of valid file descriptors at the
POSIX (system) level.  That range is 0 to some maximum.  Most Unix
shells have a built-in ‘ulimit’ or ‘limit’ command to report or set the
limit.  For example, in Bourne-compatible shells, ‘ulimit -n’ gives the
current maximum fd plus 1.

It is permitted to call ‘close’ on ‘stdin’, ‘stdout’, and ‘stderr’.

You can also call ‘close’ on a fd F that is not open at the SETL level
but is open at the POSIX level, e.g. as inherited by the process, or as
arising from a call to one of the low-level functions ‘dup’, ‘dup2’,
‘socketpair’, ‘pipe’, or ‘recv_fd’.  This just calls POSIX close() on
the fd.

Closing a stream of type "signal", "ignore", "default" (*note Signal
streams::), or "real-ms" (*note Timer streams::) can change the
disposition of a signal.  The fd is a “pseudo-fd” for these stream
cases, outside the range of valid POSIX file descriptors.

As a trivial and dubious convenience, ‘close(om)’ is a no-op.

The HOW argument to ‘close’, if present, must be one of the constants
‘close_await’ (default), ‘close_autoreap’, or ‘close_zombie’.  This
second argument is meaningful for pipe, pump, and tty-pump streams (when
the stream is the original one created by the caller, not one obtained
from a duplicated fd), as follows:

   • If HOW is ‘close_await’, then ‘close’ effectively does a ‘waitpid’
     on the child process ID, passing a WAITFLAG of ‘true’.  This causes
     ‘close’ to block until the child process terminates.  The
     termination status is then available in ‘status’, except in the
     unusual case that the status has already been reaped, e.g. by an
     explicit and probably misdirected ‘waitpid’ before the ‘close’.  In
     that case, ‘close’ sets ‘status’ to ‘om’.

   • If HOW is ‘close_autoreap’, then ‘close’ does not block the program
     in a wait for the child process to terminate, but reaps and
     discards the status in the background if it does so.

   • If HOW is ‘close_zombie’, then ‘close’ does not block the program
     in a wait, nor does it reap the termination status in the
     background.  If the child process terminates before the parent, it
     will become a “zombie” (as defined by POSIX) until a ‘waitpid’ (or
     equivalent) successfully reaps its status.  You can ‘open’ a
     SIGCHLD signal stream to get notified of child terminations.

Failure of the POSIX-level close() causes ‘last_error’ to be set.  In
the case of ‘HOW = close_await’ on a pipe, pump, or tty-pump stream, the
POSIX waitpid() call after that can also set ‘last_error’, in the
circumstances that set ‘status’ to ‘om’ described above.

When a Unix-domain server socket (‘open’ mode "unix-server" or
"unix-datagram-server") is closed, its associated pathname is removed if
it still exists.

Streams that were automatically opened are automatically closed when
appropriate.  *Note Automatic opening::.

All streams are automatically flushed and drained, and then all closed,
before the program exits.  *Note Buffering::.

See ‘shutdown’ about shutting down one or both directions of a
bidirectional communications stream without closing the stream itself.


File: setl-lib.info,  Node: close constants,  Next: command_line,  Prev: close,  Up: The Library

‘close_await’, ‘close_autoreap’, ‘close_zombie’  -  constants for use with ‘close’
==================================================================================

     close_await : integer
     close_autoreap : integer
     close_zombie : integer

See ‘close’.


File: setl-lib.info,  Node: command_line,  Next: command_name,  Prev: close constants,  Up: The Library

‘command_line’  -  command-line arguments
=========================================

     command_line : tuple

This is a tuple of strings giving the command-line arguments that were
passed to the SETL program when it was launched.

See also ‘command_name’.


File: setl-lib.info,  Node: command_name,  Next: cos,  Prev: command_line,  Up: The Library

‘command_name’  -  command name
===============================

     command_name : string

This is an implementation-defined name for the SETL program.

For GNU SETL, if the SETL program comes from an file or command,
‘command_name’ is the name of that file, or the command string,
including the leading vertical bar in the case of a command.  Otherwise
(i.e., when the program is read from a file descriptor, from standard
input, or from the command-line argument itself), ‘command_name’ is the
name of the language processor command, normally ‘setl’.

For example, in POSIX, if this script is stored in the text file
‘/tmp/help’ and made executable, it should print ‘I'm /tmp/help’ and a
newline when invoked:

     #! /usr/bin/env setl
     print ("I'm", command_name);  -- like shell’s $0 or C’s argv[0]

Note the use of the ‘#!’ escape (*note (setl-user)#! invocation::).

See also ‘command_line’.


File: setl-lib.info,  Node: cos,  Next: cosh,  Prev: command_name,  Up: The Library

‘cos’  -  cosine
================

     op cos (real) : real
     op cos (integer) : real

The operand is in radians.  See also ‘acos’.


File: setl-lib.info,  Node: cosh,  Next: date,  Prev: cos,  Up: The Library

‘cosh’  -  hyperbolic cosine
============================

     op cosh (real) : real
     op cosh (integer) : real

Hyperbolic cosine.  Popular with catenarians.


File: setl-lib.info,  Node: date,  Next: denotype,  Prev: cosh,  Up: The Library

‘date’  -  date and time of day
===============================

     proc date : string

Equivalent to ‘fdate (tod, "%c")’.

See also ‘clock’ and ‘time’.


File: setl-lib.info,  Node: denotype,  Next: div,  Prev: date,  Up: The Library

‘denotype’  -  type of denotation in string
===========================================

     op denotype (string S) : string

If S contains a denotation that would be acceptable to ‘unstr’, then
‘denotype S’ = ‘type unstr S’, but if S is some other string, then the
advantage of checking it with ‘denotype’ first is that ‘denotype’
returns ‘om’ instead of taking exception to it as ‘unstr’ would.

See also ‘val’ and ‘str’.


File: setl-lib.info,  Node: div,  Next: domain,  Prev: denotype,  Up: The Library

‘div’  -  integer division
==========================

     op div (integer, integer) : integer

SETL’s ‘div’ operator truncates fractional results towards zero.

It is an error for the second operand (denominator) to be zero.

See also “slash” (‘/’), and for remainders see ‘mod’ and ‘rem’.


File: setl-lib.info,  Node: domain,  Next: dup; dup2,  Prev: div,  Up: The Library

‘domain’  -  domain of map
==========================

     op domain (set) : set

The operand must be a set of ordered pairs, that is, a set of 2-tuples
in which no element is ‘om’.  The result is the set of all first members
of those pairs.

See also ‘range’ and ‘lessf’.


File: setl-lib.info,  Node: dup; dup2,  Next: eof,  Prev: domain,  Up: The Library

‘dup’, ‘dup2’  -  duplicate a file descriptor
=============================================

     op dup (integer FD) : integer
     op dup2 (integer FD1, integer FD2) : integer

These are direct interfaces to POSIX dup() and dup2(), useful when you
want low-level control over system-level file descriptors, e.g. to play
games with ‘socketpair’ (or ‘pipe’) and ‘fork’ and ‘exec’.

The new fd produced by ‘dup’ or ‘dup2’ is not automatically open at the
SETL level, though you can use ‘open’ or one of the auto-opening
intrinsics on it subsequently (*note Automatic opening::).

In ‘dup2’, there is an implicit POSIX close() of FD2 before the
duplication of FD1 occurs.  If FD2 is already open at the SETL level,
any buffer structure it has remains intact (*note Buffering::).  Thus if
FD2 has an output buffer, it is usually best to ‘flush’ it if necessary
before the ‘dup2’ call, so that the redirection to a new sink (FD1) only
applies to new output.  This is similar to the case of a buffered fd
across a ‘fork’.

Example:

     dup2 (stdout, stderr)

redirects ‘stderr’ to wherever ‘stdout’ points, like the shell notation
‘2>&1’.

On failure, ‘dup’ and ‘dup2’ set ‘last_error’ and return ‘om’.


File: setl-lib.info,  Node: eof,  Next: even,  Prev: dup; dup2,  Up: The Library

‘eof’  -  end-of-file indicators
================================

     proc eof : boolean
     proc eof (stream) : boolean

When a stream input operation fails to get any input, two ‘eof’
indicators are set: a global one and a stream-specific one, accessed
respectively by the nullary and unary forms of this intrinsic.

The ‘eof’ indicators are cleared by sequential input intrinsics (and by
‘recv_fd’ and ‘gets’) before they attempt input, and are only set when
no input at all is received.  Thus a ‘getb’ that asks for 3 values but
only gets 2 does _not_ set the ‘eof’ indicators, even though an end of
file on the underlying medium has been reached.  The stream’s ‘eof’
indicator is “pending” in that case, meaning that a subsequent input
attempt on that stream will get nothing and will set the ‘eof’
indicators.  The setting will happen even if the attempt is for no
input, such as for 0 values in the case of ‘getb’, 0 characters in the
case of ‘getn’ or ‘gets’, or 0 lines in the case of ‘geta’.

A vacuous input attempt like that is thus a way to convert a pending
‘eof’ to a ‘true’ result from the ‘eof’ intrinsic, making it no longer
pending.  I haven’t worked out whether that use case is plausible or
more likely symptomatic.  I have not wanted it yet.

A vacuous input attempt on a stream for which ‘eof’ is _not_ pending is
an unconditional way of clearing the ‘eof’ indicators.  Again, this is
not something I have felt moved to do in practice.

Besides ordinary end-of-file conditions such as reaching the end of a
medium, the ‘eof’ indicators may also be set by input errors.  These can
be distinguished from normal end of file using ‘last_error’.  A stream
may have a pending setting of ‘last_error’ when it has a pending ‘eof’;
the actual setting occurs when the ‘eof’ indicators are set.

Setting the ‘eof’ indicators also triggers auto-closing when appropriate
(*note Automatic opening::).  Note that closing a stream invalidates the
unary form of ‘eof’ for that stream, as it has been destroyed by then,
while the nullary form remains valid.

For some input sources, an ‘eof’ indication of ‘true’ does not
necessarily mean that further attempts to read from that source will
fail.  For example, when the stream is connected to a terminal with the
normal “cooked” line discipline settings, a ‘ctrl-D’ instead of an input
line typically makes ‘getline’ yield ‘om’ and ‘eof’ yield ‘true’, but
another ‘getline’ after that will yield another string if another line
is then entered at the terminal.

See ‘get’, ‘geta’, ‘getb’, ‘getc’, ‘getchar’, ‘getfile’, ‘getline’,
‘getn’, ‘gets’, ‘peekc’, ‘peekchar’, ‘read’, ‘reada’, and ‘recv_fd’; but
do not see ‘recv’, ‘recvfrom’, ‘seek’, ‘sys_read’, nor ‘ungetc’, as they
never set ‘eof’.


File: setl-lib.info,  Node: even,  Next: exec,  Prev: eof,  Up: The Library

‘even’  -  test for integer divisible by 2
==========================================

     op even (integer) : boolean

Divisible by 2.  Not ‘odd’.  See also ‘mod’.

Note that the precedence of this operator is quite low, like that of
other unary predicates, and well below that of unary non-predicates
(*note Operator Precedence::).  Its relative precedence was higher in
the original CIMS SETL.


File: setl-lib.info,  Node: exec,  Next: exp,  Prev: even,  Up: The Library

‘exec’  -  execute another program in place of current one
==========================================================

     proc exec (string FILE)
     proc exec (string FILE, tuple ARGV)
     proc exec (string FILE, tuple ARGV, tuple ENVP)

This is a low-level interface to POSIX execvp() or execve() depending on
whether the ENVP argument is supplied.

If ENVP _is_ present, execve() is used, which requires that FILE be a
full pathname identifying a command.

If the ENVP argument is _not_ given, then execvp() is used, so the
‘PATH’ environment variable is searched for a directory containing an
executable named FILE unless FILE contains a slash (/) character.  The
POSIX implementation defines what happens if ‘PATH’ isn’t defined, but a
default search of ‘/bin’ and ‘/usr/bin’ is common.

If the second argument (ARGV) appears, it must be a tuple of strings
giving the arguments that will be supplied to the command, beginning
with the 0th which conventionally is the name by which the command
identifies itself.  A missing ARGV defaults to the one-element tuple
‘[FILE]’.

If ENVP is present, it must be a tuple of strings defining the
environment variables to be seen by the command.  Each string is of the
form "NAME=VALUE".  Otherwise, the existing environment is inherited.

If ‘exec’ is successful, it does not return; the current process is
replaced in that its image in memory is replaced by that of the new
command.  The process ID does not change.

Signals that are being caught because of an open "signal" stream are set
to their POSIX defaults in the new execution context.  If any "real-ms"
timer streams are open (which is _not_ the case in a new child of
‘fork’), SIGALRM is also set to the POSIX default (SIG_DFL). Other
signal dispositions are inherited as POSIX SIG_DFL or SIG_IGN as
appropriate.  *Note Signal streams::.

Compare ‘filter’, ‘system’, and the ‘open’ modes "pipe-from", "pipe-to",
"pump", and "tty-pump", all of which use ‘/bin/sh’ to invoke a shell
command.  One of those may be able to achieve what you want more cleanly
and directly than ‘exec’ does.

If you want your SETL program to set up an environment and then replace
itself with a shell command, this would do the latter:

     exec ("/bin/sh", ["sh", "-c", "command and args"]);

See also ‘pipe_from_child’, ‘pipe_to_child’, ‘pump’, and ‘tty_pump’ for
some ways beyond ‘fork’ to create a child process suitable for calling
‘exec’ in.


File: setl-lib.info,  Node: exp,  Next: false,  Prev: exec,  Up: The Library

‘exp’  -  natural exponential (e raised to a power)
===================================================

     op exp (real) : real
     op exp (integer) : real

See also ‘log’ and the general exponentiation operator (‘**’).


File: setl-lib.info,  Node: false,  Next: fdate,  Prev: exp,  Up: The Library

‘false’  -  predefined boolean value
====================================

     false : boolean

A starting point from which all conclusions are possible.

See also ‘true’.


File: setl-lib.info,  Node: fdate,  Next: fexists,  Prev: false,  Up: The Library

‘fdate’  -  format date and time
================================

     proc fdate (integer MS, string FMT) : string
     proc fdate (integer MS) : string

The MS argument represents some number of milliseconds since 1 January
1970 UTC, to be formatted as a date and time according to FMT, which
defaults to "%a %b %e %H:%M:%S.%s %Z %Y". For example,
‘fdate (936433255888)’ might be ‘Sat Sep  4 04:20:55.888 EDT 1999’ if
invoked in the POSIX locale in the US Eastern time zone, and
‘fdate (tod)’ renders the current calendar time.

The %-sign patterns in FMT are those defined for POSIX strftime() when
applied to the result of applying POSIX localtime() to ‘MS div 1000’,
together with one extension: "%s" expands to the low-order 3 decimal
digits of MS.  (Note: this meaning of "%s" differs from a GNU extension
to strftime(), where it means the number of seconds since the beginning
of 1970, a number that can be obtained in SETL as ‘tod div 1000’.)

See also ‘date’, which is equivalent to ‘fdate (tod, "%c")’.


File: setl-lib.info,  Node: fexists,  Next: filename,  Prev: fdate,  Up: The Library

‘fexists’  -  test for existence of file
========================================

     op fexists (string) : boolean

Returns ‘true’ iff POSIX stat() returns 0 on the given pathname.

Note that stat() _does_ follow symbolic links, so ‘fexists’ will only
return ‘true’ if an existing file is found after following all links
(and provided the caller has sufficient access to all pathname
components in reaching it).

Thus ‘fexists’ is stricter than ‘lexists’, which uses POSIX lstat().
Both provide mere snapshots, not automatically synchronized with actions
by other processes.  See ‘link’ and ‘symlink’ for some ways to use files
as mutual exclusion (mutex) locks.

See also ‘fsize’, ‘readlink’, and ‘unlink’.

Note the low precedence of this operator relative to unary
_non_-predicates (*note Operator Precedence::).  This differs from its
precedence rank in SETL2.


File: setl-lib.info,  Node: filename,  Next: fileno,  Prev: fexists,  Up: The Library

‘filename’  -  name of stream
=============================

     op filename (stream) : integer
     op filename (stream) : string
     op filename (stream) : [integer, integer]
     op filename (stream) : [string, string]

This is some form of the “name” under which the given stream was opened,
as follows.

For an ordinary file, it is the ‘string’ name passed to ‘open’ or used
to auto-open the file (*note Automatic opening::), or the name assigned
by ‘mkstemp’.

For a Unix-domain socket, it is the pathname used at ‘open’ time.  *Note
Unix-domain sockets: Local sockets.

Similarly, for a subprocess started by ‘open’ mode "pipe-from",
"pipe-to", "pump", or "tty-pump", it is the command string that launched
that subprocess.  *Note Connected subprocesses: Pipes and pumps.

For a signal-catching, -ignoring, or -defaulting stream, the name is
returned in the same case and spelling (i.e., with or without the SIG
prefix) as was originally used to ‘open’ the stream.  *Note Signal
streams::.

For a "real-ms" stream, ‘filename’ returns a pair of numbers
‘[INITIAL, INTERVAL]’, each representing milliseconds.  *Note Timer
streams::.

For a TCP or UDP socket stream, it returns a pair ‘[NODE, SERVICE]’,
where NODE is a ‘string’ host name or Internet address (IPv4 dotted or
IPv6 colon-rich), or is ‘om’ to signify an unspecified address (as is
common for servers); and SERVICE is a ‘string’ service name or port
number, converted as if by ‘str’ if the original spec was an ‘integer’.
*Note TCP and UDP sockets: Network sockets.

Finally, for a stream created by ‘accept’, ‘pipe_from_child’,
‘pipe_to_child’, ‘pump’, or ‘tty_pump’, or a stream over a fd that was
already open at the system (POSIX) level, the “name” is simply the
‘integer’ fd.

It is an error to call ‘filename’ on a fd that is not open at the SETL
level, even though it may be open at the system level.

See also ‘is_open’, ‘fileno’, ‘port’, ‘sockaddr’, ‘peer_sockaddr’,
‘peer_name’, ‘ip_names’, and ‘ip_addresses’.


File: setl-lib.info,  Node: fileno,  Next: filepos,  Prev: filename,  Up: The Library

‘fileno’  -  file descriptor of stream
======================================

     op fileno (stream F) : integer

If F exists as a stream according to ‘is_open’, ‘fileno’ returns its
underlying POSIX file descriptor (“fd”) or, for a signal-related stream
(*note Signal streams::) or timer stream (*note Timer streams::), its
pseudo-fd.

It is an error to apply ‘fileno’ to anything else.  The fact that GNU
SETL kindly stops everything and issues a diagnostic leads to the
following non-portable idiom in programs that would rather crash
immediately than continue with a bad result from ‘open’:

     FD := fileno open (F, ...);

See also ‘filename’.


File: setl-lib.info,  Node: filepos,  Next: filter,  Prev: fileno,  Up: The Library

‘filepos’  -  current file position or #bytes transferred
=========================================================

     op filepos (stream F) : integer

Similar to ‘seek (F, 0, seek_cur)’, but does not flush or drain the
stream before giving its result.  Thus while the result of ‘seek’ always
matches the OS-level file position, ‘filepos’ takes into account any
buffered output bytes that have not been written out yet at the system
level and any buffered input that has not yet been consumed by the SETL
program; it gives the offset that would obtain _as if_ the flushing or
draining had occurred.

Also, ‘filepos’ is allowed even on non-seekable streams, where it
returns the number of bytes that have been read and/or written since the
stream was opened.

Finally (again in contrast to ‘seek’), ‘filepos’ does not attempt to
auto-open F, but requires that F already be open (see ‘open’).


File: setl-lib.info,  Node: filter,  Next: fix,  Prev: filepos,  Up: The Library

‘filter’  -  filter string through external command
===================================================

     proc filter (string CMD, string INPUT) : string
     proc filter (string CMD) : string

This feeds the string INPUT into an external command and returns its
output.

The CMD argument specifies a shell command, which is performed as if by
‘exec ("/bin/sh", ["sh", "-c", CMD])’ in a child process spawned as if
by ‘pump’.

The command may read from its standard input and/or write to its
standard output.  The INPUT arg (default "") is fed to the child’s
standard input while the content of its standard output is being
captured.

When all of INPUT has been fed to the child, the end of the pipe that
does the feeding is closed, causing an end of file condition to be
presented to the child’s standard input.

Meanwhile, when an end of file condition is seen by the SETL program on
the capturing end of the pipe, signifying that the child’s standard
output has been closed, POSIX waitpid() is called in an attempt to get
the child’s exit status, and the captured output is returned by
‘filter’.

Just as with ‘system’, the signals SIGINT and SIGQUIT are temporarily
ignored in the parent while it waits for the child to complete.  Thus a
terminal-generated signal (typically ctrl-C for SIGINT and ctrl-\ for
SIGQUIT) that goes to the process group will be seen by the child but
not the parent, which remains to handle the child termination.  Also as
with ‘system’, SIGCHLD is not blocked during the ‘filter’ call.

The termination status of the ‘/bin/sh’ invocation is placed in
‘status’.  By convention, 0 means a successful command execution.  In
the event that the final POSIX waitpid() call to get that status fails,
‘status’ is set to ‘om’ and the reason for the failure appears in
‘last_error’, just as in the similar scenario of ‘close’ with the
‘close_await’ parameter.

See also ‘fork’, ‘pipe_from_child’, ‘pipe_to_child’, ‘tty_pump’,
‘socketpair’, ‘pipe’, ‘dup’, and ‘dup2’; and the ‘open’ modes
"pipe-from", "pipe-to", "pump", and "tty-pump".


File: setl-lib.info,  Node: fix,  Next: fixed,  Prev: filter,  Up: The Library

‘fix’  -  truncate ‘real’ number to ‘integer’
=============================================

     op fix (real) : integer
     op fix (integer) : integer

Truncation of ‘real’ operands is towards zero; ‘integer’ operands are
simply returned.

Example: ‘fix -5.6 = -5’.

Floating-point infinities and NaN (“Not a Number”) values give ‘om’.

See also ‘ceil’, ‘floor’, ‘round’, and ‘float’.


File: setl-lib.info,  Node: fixed,  Next: float,  Prev: fix,  Up: The Library

‘fixed’  -  format number with optional decimal point
=====================================================

     proc fixed (real X, integer WID, integer AFT) : string
     proc fixed (integer X, integer WID, integer AFT) : string

The number ‘float X’ is converted to a string of length ‘abs WID’ or
more, with AFT digits after the decimal point.

If AFT is zero, there is no decimal point, and you might as well use
‘whole’ instead of ‘fixed’.  Negative AFT is an error.

If ‘abs WID’ is larger than necessary, the string is padded with blanks
on the left (for positive WID) or on the right (for negative WID).

If ‘abs WID’ is too small, a longer string is produced as necessary to
accommodate the number.

It is possible for the conversion to result in the string "nan", "inf",
or "infinity", with or without a minus sign in front.

See also ‘floating’, ‘str’, and ‘strad’.


File: setl-lib.info,  Node: float,  Next: floating,  Prev: fixed,  Up: The Library

‘float’  -  convert number to ‘real’
====================================

     op float (integer) : real
     op float (real) : real

If ‘integer’s are unbounded, and ‘real’s are not, it is possible for
this conversion to produce a floating-point infinity.  On a 64-bit IEEE
754 implementation, this will happen for any integer of magnitude
‘2**1024’ or more, a 309-digit integer in decimal.

Also, loss of precision can occur for integers too big to fit in the
mantissa (“significand”) of a bounded floating-point representation.  In
the 64-bit IEEE 754 case, this means that integers of magnitude at most
‘2**53’ will be reproduced with absolute fidelity by ‘float’.  Beyond
that, the gaps in coverage begin, starting with the odd numbers.

Applied to a ‘real’, ‘float’ simply returns it.

See also ‘fix’, ‘ceil’, ‘floor’, and ‘round’.


File: setl-lib.info,  Node: floating,  Next: floor,  Prev: float,  Up: The Library

‘floating’  -  format number in scientific notation
===================================================

     proc floating (real X, integer WID, integer AFT) : string
     proc floating (integer X, integer WID, integer AFT) : string

The number ‘float X’ is converted to a string of length ‘abs WID’ or
more in “scientific” notation, with one digit before the decimal point,
AFT digits after it, and the string "e+DD" or "e-DD" after that, where
the latter stands for “times 10 to the power of DD (or -DD)”, and DD has
at least 2 digits.

If AFT is zero, there is no decimal point; AFT must not be negative.

If ‘abs WID’ is larger than necessary, the string is padded with blanks
on the left (for positive WID) or on the right (for negative WID).

If ‘abs WID’ is too small, a longer string is produced as necessary to
accommodate the number.

It is possible for the conversion to result in the string "nan", "inf",
or "infinity", with or without a minus sign in front.

See also ‘fixed’, ‘whole’, ‘str’, and ‘strad’.


File: setl-lib.info,  Node: floor,  Next: flush,  Prev: floating,  Up: The Library

‘floor’  -  floor (greatest integer lower bound)
================================================

     op floor (real) : integer
     op floor (integer) : integer

This operator returns the largest integer that is less than or equal to
the given operand.

For example, ‘floor -5.1 = -6’.

Floating-point infinities and NaN (“Not a Number”) values give ‘om’.

See also ‘ceil’, ‘round’, ‘fix’, and ‘float’.


File: setl-lib.info,  Node: flush,  Next: fork,  Prev: floor,  Up: The Library

‘flush’  -  flush output buffer
===============================

     proc flush (stream)

All buffered output for the given stream is written out using POSIX
write(), blocking the program if necessary until the entire buffer has
been written.

If POSIX write() fails, ‘last_error’ is set, and the number of bytes
written is then indeterminate.

Applying ‘flush’ to a stream with no pending output (which is always the
case for a read-only or datagram stream) has no effect, not even on
‘last_error’.

For most use cases, flushing is done automatically when it needs to be.
Some auto-flushing can also be arranged using ‘tie’.  *Note Buffering::.

See also ‘open’, ‘close’, and ‘is_open’.


File: setl-lib.info,  Node: fork,  Next: from,  Prev: flush,  Up: The Library

‘fork’  -  fork into parent and child process
=============================================

     proc fork : integer

This is an interface to POSIX fork() with accommodations for SETL.

In the parent process, ‘fork’ returns an integer representing the
process ID of the child.

In the child, ‘fork’ returns 0.

All output buffers are flushed as if by ‘flush’ before the spawning
attempt, possibly causing some blocking.  Output errors in the flushing
are suppressed, and not reflected in ‘last_error’.

In the child, before ‘fork’ returns, all unread input on signal streams
is drained (discarded), all timer streams (‘open’ mode "real-ms") are
closed (*note Signal streams::), and the time base for elapsed time (see
‘clock’) is reset to 0.

If the system cannot spawn a new process, ‘fork’ sets ‘last_error’ and
returns ‘om’, in contrast to all other intrinsics, which consider
spawning failures errors.

In many cases, simply using ‘system’, ‘filter’, ‘pipe_from_child’,
‘pipe_to_child’, ‘pump’, ‘tty_pump’, or one of the ‘open’ modes
"pipe-from", "pipe-to", "pump", or "tty-pump" will be easier than
dancing with ‘fork’, ‘exec’, ‘socketpair’ (or ‘pipe’), ‘dup2’, ‘close’,
and ‘waitpid’.

See also ‘getpid’, ‘pexists’, and ‘kill’.


File: setl-lib.info,  Node: from,  Next: fromb,  Prev: fork,  Up: The Library

‘from’  -  take arbitrary element from set
==========================================

     op from (wr var X, rw set S)

An element of the set S is chosen arbitrarily (but probably not
_randomly_), removed from S, and assigned to X.

If S is empty, ‘X := om’ instead.

Currently, ‘from’ is a statement form, not actually an operator.

See also ‘arb’, ‘fromb’, ‘frome’, ‘less’, ‘lessf’, and the “minus”
operator (‘-’) as applied to sets.


File: setl-lib.info,  Node: fromb,  Next: frome,  Prev: from,  Up: The Library

‘fromb’  -  take from beginning of string or tuple
==================================================

     op fromb (wr string X, rw string S)
     op fromb (wr var X, rw tuple S)

The string or tuple S is stripped of its first element (a one-character
string if S is a string), and that element is assigned to X.

If S is of length 0, ‘X := om’ instead.

Currently, ‘fromb’ is a statement form, not actually an operator.

See also ‘from’ and ‘frome’.


File: setl-lib.info,  Node: frome,  Next: fsize,  Prev: fromb,  Up: The Library

‘frome’  -  take from end of string or tuple
============================================

     op frome (wr string X, rw string S)
     op frome (wr var X, rw tuple S)

The string or tuple S is stripped of its last element (a one-character
string if S is a string), and that element is assigned to X.

If S is of length 0, ‘X := om’ instead.

Currently, ‘frome’ is a statement form, not actually an operator.

See also ‘from’ and ‘fromb’.


File: setl-lib.info,  Node: fsize,  Next: ftrunc,  Prev: frome,  Up: The Library

‘fsize’  -  size of file in bytes
=================================

     op fsize (stream F) : integer
     op fsize (string PATHNAME) : integer

If the operand is a stream, ‘fsize’ returns the size of the thing that
is open (see ‘is_open’).  More precisely, it returns the value of the
‘st_size’ field in the POSIX ‘struct stat’, which is only required to be
meaningful for files, though particular implementations of POSIX fstat()
may extend its meaning to other things.

If the operand is not a stream, POSIX stat() is tried on it to get a
size, again from the ‘st_size’ field.

Errors in fstat() or stat() cause ‘fsize’ to set ‘last_error’ and return
‘om’.

Like ‘fexists’, ‘fsize’ gives just a snapshot, not automatically
synchronized with updates by other processes.

See also ‘open’ and ‘ftrunc’.


File: setl-lib.info,  Node: ftrunc,  Next: get,  Prev: fsize,  Up: The Library

‘ftrunc’  -  set size of file in bytes
======================================

     op ftrunc (stream F, integer LENGTH)
     op ftrunc (string PATHNAME, integer LENGTH)

The file associated with the writable stream F or, if F is not a stream,
the writable file named by PATHNAME, is resized to the given LENGTH,
truncating the file or extending it as necessary.  When extended, it is
padded with NUL characters (‘\0’), possibly in a way that is optimized
by the underlying file system.

For the stream case, F is first flushed as if by ‘flush’ (but ignoring
output errors) and drained.  *Note Buffering::.

The underlying POSIX call is then ftruncate() for F and truncate() for
PATHNAME.  Errors are reflected in ‘last_error’.

See also ‘open’ and ‘fsize’.


File: setl-lib.info,  Node: get,  Next: geta,  Prev: ftrunc,  Up: The Library

‘get’  -  read lines from ‘stdin’
=================================

     proc get (wr string ARGS(*))

Equivalent to ‘geta (stdin, ARGS(*))’.

This signature for ‘get’ follows that of SETL2, while ‘geta’ is
patterned after the old CIMS SETL get.  This makes the signatures of
‘get’ and ‘geta’ consistent with those of ‘read’ and ‘reada’.


File: setl-lib.info,  Node: geta,  Next: getb,  Prev: get,  Up: The Library

‘geta’  -  read lines from stream
=================================

     proc geta (stream F, wr string ARGS(*))

Zero or more lines are read from the stream F and assigned to the
succeeding ARGS in order, as strings.  If an end of input (end of file
or error) is reached before all those arguments have been assigned to,
trailing arguments are set to ‘om’.  If it is reached before _any_ have
been assigned to, the ‘eof’ indicators are set.

If F is not already open, an attempt is made to auto-open it, for
reading or for bidirectional I/O depending on the form of F.  *Note
Automatic opening::.

Lines are terminated by newline (‘\n’), and there is no restriction on
line length.  The newline character is not delivered as part of each
assigned string, and the final line before the end of input need not be
terminated by a newline.

There is no distinction between “text” and “binary” files, nor any
special processing of carriage return (‘\r’).

The rules on auto-flushing F’s output associations, on setting
‘last_error’, and on auto-closing are as for ‘getc’.

The operator-form ‘getline’ in place of ‘geta’ may often be
stylistically preferable.

See also ‘open’, ‘get’, ‘getb’, ‘getn’, ‘gets’, ‘peekc’, ‘reada’,
‘puta’, and ‘printa’.


File: setl-lib.info,  Node: getb,  Next: getc,  Prev: geta,  Up: The Library

‘getb’  -  read values from stream
==================================

     proc getb (stream F, wr var ARGS(*))

Zero or more values are read from the stream F and assigned to the
succeeding ARGS in order.  If an end of input (end of file or error) is
reached before all those arguments have been assigned to, trailing
arguments are set to ‘om’.  If it is reached before _any_ have been
assigned to, the ‘eof’ indicators are set.

If F is not already open, an attempt is made to auto-open it.  *Note
Automatic opening::.

Values written by ‘putb’ or ‘writea’, except for atoms (see ‘newat’) and
procedure references (see ‘routine’), are readable by ‘getb’.  Tokens
denoting values are separated by whitespace (ERE "[ \f\n\r\t\v]+") and
converted as if by ‘unstr’.

There is a difference between ‘getb’ and ‘reada’ in that after reading
the requested number of values, ‘reada’ continues reading characters
until it either absorbs a newline (‘\n’) or encounters an end of input,
whereas ‘getb’ stops right after the end of the last value read.

The rules on auto-flushing F’s output associations, on setting
‘last_error’, and on auto-closing are as for ‘getc’.

See also ‘geta’, ‘getline’, ‘getfile’, ‘getn’, and ‘val’.


File: setl-lib.info,  Node: getc,  Next: getchar,  Prev: getb,  Up: The Library

‘getc’  -  read character from stream
=====================================

     op getc (stream F) : string

One character is read from the stream F and returned as a string of
length 1.  If an end of input (end of file or error) is reached instead,
‘getc’ sets the ‘eof’ indicators and possibly ‘last_error’, and returns
‘om’.

If F is not already open, an attempt is made to auto-open it.  *Note
Automatic opening::.

If ‘eof’ is set by ‘getc’ for an auto-opened sequential stream, the
stream is auto-closed, leaving the nullary ‘eof’ true and the unary
‘eof(F)’ invalid.

The ‘getc’ intrinsic, like all input intrinsics, automatically flushes
any output buffered for F and for any stream associated with F by ‘tie’
before attempting input.  It does not set ‘last_error’ on output
failures in the flushing, but you can ‘flush’ explicitly before the
input operation if details on such failures are of interest.

See also ‘getchar’, ‘getfile’, ‘getline’, ‘getn’, ‘gets’, ‘geta’,
‘getb’, ‘peekc’, ‘reada’, ‘ungetc’, and ‘putc’.


File: setl-lib.info,  Node: getchar,  Next: getegid,  Prev: getc,  Up: The Library

‘getchar’  -  read character from ‘stdin’
=========================================

     proc getchar : string

Equivalent to ‘getc (stdin)’.


File: setl-lib.info,  Node: getegid,  Next: getenv,  Prev: getchar,  Up: The Library

‘getegid’  -  get effective group ID
====================================

     proc getegid : integer

Returns the result of calling the POSIX getegid() function.

See also ‘getgid’, ‘setegid’, ‘setgid’, ‘geteuid’, ‘getuid’, ‘seteuid’,
and ‘setuid’ (details and example).


File: setl-lib.info,  Node: getenv,  Next: geteuid,  Prev: getegid,  Up: The Library

‘getenv’  -  get value of environment variable
==============================================

     op getenv (string) : string

If the environment variable named by the operand exists, its value is
returned; otherwise you get ‘om’.

See also ‘setenv’ and ‘unsetenv’.


File: setl-lib.info,  Node: geteuid,  Next: getfile,  Prev: getenv,  Up: The Library

‘geteuid’  -  get effective user ID
===================================

     proc geteuid : integer

Returns the result of calling the POSIX geteuid() function.

See also ‘getuid’, ‘seteuid’, ‘setuid’ (details and example), ‘getegid’,
‘getgid’, ‘setegid’, and ‘setgid’.


File: setl-lib.info,  Node: getfile,  Next: getgid,  Prev: geteuid,  Up: The Library

‘getfile’  -  read stream up to the end
=======================================

     op getfile (stream F) : string

Zero or more characters are read from the stream F until an end of input
(end of file or error) is reached, and returned as a string.

If F is not already open, an attempt is made to auto-open it.  *Note
Automatic opening::.  As usual, if the file was automatically opened, it
is automatically closed on end of input.

The ‘getfile’ intrinsic is unique in that if it fails on the auto-open
attempt, it returns ‘om’ rather than considering the failure erroneous.
This helps to discourage racy code like

     X := if fexists F then getfile F else "some default" end;

when

     X := getfile F ? "some default";

is race-free and serves a common use case.  The latter is more or less
equivalent to

     FD := open (F, "r");
     if FD /= om then
       X := getfile FD;
       close (FD);
       FD := om;
     else
       X := "some default";
     end if;

The ‘eof’ indicators are always set by ‘getfile’.  This does not matter
to users, but allows auto-closing to be defined as something that only
happens upon the setting of the ‘eof’ indicators, as is the case for all
other input intrinsics.  On the other hand, this makes ‘getfile’ the
only intrinsic that sets ‘eof’ even when it succeeds in getting more
than 0 input items.

The rules on auto-flushing F’s output associations, on setting
‘last_error’, and on auto-closing are as for ‘getc’.

See also ‘getline’, ‘getn’, ‘gets’, ‘getb’, and ‘putfile’.


File: setl-lib.info,  Node: getgid,  Next: getline,  Prev: getfile,  Up: The Library

‘getgid’  -  get real group ID
==============================

     proc getgid : integer

Returns the result of calling the POSIX getgid() function.

Note that group IDs have no relation to _process_ group IDs (see
‘getpgrp’).

See also ‘getegid’, ‘setgid’, ‘setegid’, ‘getuid’, ‘geteuid’, ‘setuid’
(details and example), and ‘seteuid’.


File: setl-lib.info,  Node: getline,  Next: getn,  Prev: getgid,  Up: The Library

‘getline’  -  read line from stream
===================================

     op getline (stream F) : string

This is an operator-form alternative to ‘geta’ for reading a single
line.

Characters through the next newline (‘\n’) if any are read from F and
returned as a string, without the newline.  Thus the trailing newline is
optional on the last line of a file except when needed to signify an
empty line there.

If no characters can be read, ‘getline’ sets the ‘eof’ indicators and
returns ‘om’.

If the stream is not already open, an attempt is made to auto-open it.
*Note Automatic opening::.

The rules on auto-flushing F’s output associations, on setting
‘last_error’, and on auto-closing are as for ‘getc’.

If respectability isn’t your thing, the expression

     [getline F : until eof]

is a convenient way to read all the lines of a file into a tuple.  If F
is the name of a file that was not previously open, this leaves the file
closed after the tuple is accumulated, by the usual rules of
auto-opening and auto-closing.

The above expression only works because the ‘om’ coming from the final
‘getline’ call in the loop is trimmed from the tuple.

See also ‘open’, ‘close’, ‘putline’, ‘getfile’, ‘getb’, ‘getn’, ‘gets’,
‘reada’, and ‘printa’.


File: setl-lib.info,  Node: getn,  Next: getpgrp,  Prev: getline,  Up: The Library

‘getn’  -  read fixed number of characters from stream
======================================================

     proc getn (stream F, integer N) : string

Up to N characters are read from the stream F and returned as a string.
If an end of input (end of file or error) is reached before N characters
have been read, a shorter string is returned.  If it is reached before
_any_ characters have been read, the ‘eof’ indicators are set and the
empty string ("") is returned.

If F is not already open, an attempt is made to auto-open it.  *Note
Automatic opening::.

The rules on auto-flushing F’s output associations, on setting
‘last_error’, and on auto-closing are as for ‘getc’.

See also ‘getfile’, ‘getline’, ‘gets’, and ‘putc’.


File: setl-lib.info,  Node: getpgrp,  Next: getpid,  Prev: getn,  Up: The Library

‘getpgrp’  -  get process group ID
==================================

     proc getpgrp : integer

Gets the process group ID of the calling process, or in other words the
process ID of the process group leader.

See also ‘setpgid’, ‘getpid’, ‘getppid’, ‘getsid’, ‘pexists’, ‘kill’,
and ‘waitpid’.


File: setl-lib.info,  Node: getpid,  Next: getppid,  Prev: getpgrp,  Up: The Library

‘getpid’  -  get process ID
===========================

     proc getpid : integer

Gets the process ID, in the POSIX sense, of the calling process.

See also ‘pid’, ‘getppid’, ‘getpgrp’, ‘getsid’, ‘pexists’, ‘kill’, and
‘waitpid’.


File: setl-lib.info,  Node: getppid,  Next: gets,  Prev: getpid,  Up: The Library

‘getppid’  -  get parent process ID
===================================

     proc getppid : integer

Gets the process ID of the parent of the calling process.

See also ‘getpid’.


File: setl-lib.info,  Node: gets,  Next: getsid,  Prev: getppid,  Up: The Library

‘gets’  -  direct-access read
=============================

     proc gets (stream F, integer START, integer N, wr string X)

The file under the readable, seekable stream F (‘open’ mode "r", "r+",
"w+", "n+", or "a+") is viewed as a string, where START specifies the
index (1 or higher) of the first character to read.

The ‘gets’ intrinsic reads up to N characters and returns them as a
string through the X arg.  If an end of input (end of file or error) is
reached before N characters have been read, a shorter string is
returned.  If it is reached before _any_ characters have been read, the
‘eof’ indicators are set and the empty string ("") is returned.

If F is not already open, an attempt is made to auto-open it in "r+"
mode, which allows seeking, reading, and writing.  *Note Automatic
opening::.

If F was auto-opened in "r" (not "r+") mode, it will be auto-closed when
‘gets’ sets ‘eof’.

As with ‘seek’, F is flushed of output (ignoring errors) and drained of
input before the file is repositioned.  *Note Buffering::.

See also ‘getfile’, ‘getn’, ‘puts’, ‘seek’, and ‘mkstemp’.


File: setl-lib.info,  Node: getsid,  Next: getuid,  Prev: gets,  Up: The Library

‘getsid’  -  get session ID
===========================

     proc getsid : integer
     proc getsid (integer P) : integer

Gets the POSIX session ID for process ID P, which is to say the process
group ID of P’s session leader.  If P is 0 or omitted, the session ID of
the calling process is returned.

On error, ‘getsid’ sets ‘last_error’ and returns ‘om’.

Sessions are used in job control—see ‘setsid’.


File: setl-lib.info,  Node: getuid,  Next: getwd,  Prev: getsid,  Up: The Library

‘getuid’  -  get real user ID
=============================

     proc getuid : integer

Returns the result of calling the POSIX getuid() function.

See also ‘geteuid’, ‘setuid’ (details and example), ‘seteuid’, ‘getgid’,
‘getegid’, ‘setgid’, and ‘setegid’.


File: setl-lib.info,  Node: getwd,  Next: glob,  Prev: getuid,  Up: The Library

‘getwd’  -  current working directory
=====================================

     proc getwd : string

Current working directory of the process.

See also ‘chdir’.


File: setl-lib.info,  Node: glob,  Next: gmark,  Prev: getwd,  Up: The Library

‘glob’  -  pathname wildcard expansion
======================================

     op glob (string) : [string, ...]

Using the POSIX glob() function with no flags and no error callback,
‘glob’ expands the pathname pattern given in the string operand to
produce a tuple of strings.  The empty tuple is produced if there is no
match to an accessible filename.

For example, if the current directory contains 3 ‘.h’ files, then

     glob "*.h"

might equal the tuple

     ["bar.h", "foo.h", "mumble.h"]

See also ‘getwd’ and ‘chdir’.


File: setl-lib.info,  Node: gmark,  Next: gsub,  Prev: glob,  Up: The Library

‘gmark’  -  find all occurrences of pattern in string
=====================================================

     proc gmark (string S, pattern P) : [[integer, integer], ...]

The locations of all non-overlapping occurrences of the pattern P in the
string S are returned in left-to-right order as a tuple of pairs of
integers ‘[i, j]’, where each matched substring can be addressed as
‘S(i..j)’.  If P does not occur in S, the empty tuple is returned.

For example:

   • ‘gmark ("banana", "an")’ is ‘[[2,3], [4,5]]’

   • ‘gmark ("banana", "ana")’ is ‘[[2,4]]’, not ‘[[2,4], [4,6]]’

The pattern P is subject to the setting of ‘magic’, and can be a string
or a 2-tuple, as detailed under ‘mark’.

See also ‘sub’, ‘gsub’, and ‘split’.


File: setl-lib.info,  Node: gsub,  Next: hex,  Prev: gmark,  Up: The Library

‘gsub’  -  replace patterns in string
=====================================

     proc gsub (rw string S, pattern P) : [string, ...]
     proc gsub (rw string S, pattern P, string R) : [string, ...]

All non-overlapping occurrences in S of the pattern P are replaced by R,
which defaults to the empty string ("").  The substrings of S that were
matched by P are returned as a tuple of strings in left-to-right order.

The pattern P is subject to the setting of ‘magic’, and can be a string
or a 2-tuple, as detailed under ‘mark’.

When ‘magic’ is ‘true’, ampersands and backslash-digit sequences in the
replacement pattern R are expanded as in ‘sub’.

Example:

     S := "abcd aabbccdd";
     print (gsub (S, "a([bc]*)d", "&/<\\1>"));  -- prints [abcd abbccd]
     print (S);  -- prints abcd/<bc> aabbccd/<bbcc>d

See also ‘gmark’ and ‘split’.


File: setl-lib.info,  Node: hex,  Next: hostaddr,  Prev: gsub,  Up: The Library

‘hex’  -  convert string to hexadecimal
=======================================

     op hex (string S) : string

Hexadecimal string representation of S.  For example,
‘hex "\011\xCf" = "09CF"’, and ‘hex char 16#dB = "DB"’.

In general, ‘#hex S = 2 * #S’.

See also ‘unhex’.


File: setl-lib.info,  Node: hostaddr,  Next: hostname,  Prev: hex,  Up: The Library

‘hostaddr’  -  current host address
===================================

     proc hostaddr : string

This is some plausible Internet address for the current host system,
defined as the first AF_INET or AF_INET6 address on the list returned by
POSIX getaddrinfo() for the host name obtained by POSIX gethostname(),
in dotted IPv4 or colon-delimited IPv6 notation.

If gethostname() or getaddrinfo() fails, ‘hostaddr’ sets ‘last_error’
and returns ‘om’.

If getaddrinfo() succeeds but yields no addresses in the family AF_INET
or AF_INET6, the value of ‘hostaddr’ is ‘om’ but ‘last_error’ is _not_
set.

Uses for this function seem limited.

See also ‘hostname’, ‘ip_addresses’, and ‘ip_names’.


File: setl-lib.info,  Node: hostname,  Next: ichar,  Prev: hostaddr,  Up: The Library

‘hostname’  -  current host name
================================

     proc hostname : string

This is the “standard” name for the current host system as given by
POSIX gethostname().

In the unlikely case that gethostname() fails, ‘hostname’ sets
‘last_error’ and returns ‘om’.

See also ‘hostaddr’, ‘peer_name’, ‘ip_names’, and ‘ip_addresses’.


File: setl-lib.info,  Node: ichar,  Next: impl,  Prev: hostname,  Up: The Library

‘ichar’  -  integer code for character
======================================

     op ichar (string) : integer

This operator interprets the one byte in the operand as an integer in
the range 0 to 255.  For example, ‘ichar "\x20" = 32’, the code for an
ASCII blank.

See also ‘char’.


File: setl-lib.info,  Node: impl,  Next: in,  Prev: ichar,  Up: The Library

‘impl’  -  implication
======================

     op impl (boolean, boolean) : boolean

Here is the “truth table” defining this operator:

     true  impl true   =  true
     true  impl false  =  false
     false impl true   =  true
     false impl false  =  true

This seldom-used operator could have been “short-circuited” like ‘and’,
‘or’, and the “query” operator (‘?’), but isn’t.  That is to say, both
sides of ‘impl’ are always evaluated.

This is no great loss, however, because it is usually more natural to
write the short-circuiting expression

     Q or not P

or

     (not P) or Q

than the propositional

     P impl Q

especially in the context of ‘if’ or ‘while’ tests.

The ‘impl’ operator has the lowest precedence of any operator (*note
Operator Precedence::).


File: setl-lib.info,  Node: in,  Next: incs,  Prev: impl,  Up: The Library

‘in’  -  membership test; iterator form
=======================================

     op in (var X, set S) : boolean
     op in (var X, tuple S) : boolean
     op in (string X, string S) : boolean

The keyword ‘in’ plays a dual role in SETL.  Depending on context, it is
either the boolean-valued membership test operator whose signature is
given above, or the basis of a common iterator form that occurs in loop
headers, quantifiers, and set and tuple formers.

Here are two examples of its use in iterators, where X acts like a bound
variable in each iteration in that it is assigned successive members of
a set or tuple S, or characters of a string S:

     for X in S loop
       ...
     end loop;

     SQUARES := {X*X : X in S};  -- set former

In its other role, as a binary operator,

     X in S

it is a type-dependent membership test:

   • For a set S, it tells whether X occurs in S; ‘om’ is never
     considered to be a set member.

   • For a tuple S, it likewise seeks an occurrence of X in S, perhaps
     searching linearly; ‘om’ is considered present if the tuple has at
     least one “hole”, i.e., non-trailing ‘om’ member.

   • For a string S, it indicates whether X is a substring of S.

See also ‘arb’, ‘from’, and ‘notin’.


File: setl-lib.info,  Node: incs,  Next: intslash,  Prev: in,  Up: The Library

‘incs’  -  subset test
======================

     op incs (set S, set SS) : boolean

Returns ‘true’ when every member of SS is also in S.  Thus

     S incs SS

has the same truth value as

     SS subset S

Its precedence is quite low, like that of other binary predicates.
*Note Operator Precedence::.


File: setl-lib.info,  Node: intslash,  Next: ip_addresses,  Prev: incs,  Up: The Library

‘intslash’  -  integer quotient type switch
===========================================

     intslash : boolean

By default, the result of dividing two ‘integer’ values in SETL is
‘real’, as in Pascal and the Algol family.  This default corresponds to
‘intslash = false’.  See the discussion of the “slash” operator (‘/’)
for why it is best to leave it this way if possible.

See also ‘set_intslash’.


File: setl-lib.info,  Node: ip_addresses,  Next: ip_names,  Prev: intslash,  Up: The Library

‘ip_addresses’  -  internet host addresses
==========================================

     proc ip_addresses (string HOST) : {string, ...}

Returns a set of Internet addresses as strings in IPv4 dotted or IPv6
colon-separated notation, for the host name or Internet address HOST.

POSIX getaddrinfo() is used to obtain the addresses.

For example,

     ip_addresses ("uccs.edu")

might produce the set

     {"128.198.1.50", "128.198.1.71", "128.198.4.52"}

If getaddrinfo() fails, ‘last_error’ is set and the empty set is
returned.  The empty set can be returned with _no_ setting of
‘last_error’ if getaddrinfo() succeeds but doesn’t find any addresses in
the AF_INET or AF_INET6 family for the given HOST.

See also ‘ip_names’, ‘hostaddr’, ‘hostname’, ‘peer_name’, and
‘peer_address’.


File: setl-lib.info,  Node: ip_names,  Next: type-testing,  Prev: ip_addresses,  Up: The Library

‘ip_names’  -  internet host names
==================================

     proc ip_names (string HOST) : {string, ...}

Returns a set of Internet host names for the host name or IPv4/IPv6
address HOST.

It is like ‘ip_addresses’ but with each address translated to a name
using POSIX getnameinfo() if possible or omitted if not.  For example,

     ip_names ("uccs.edu")

might give the set

     {"federation.uccs.edu", "klingon.uccs.edu", "warp.uccs.edu"}

and

     ip_names ("::1")

might be

     {"ip6-localhost"}

Failure of POSIX getaddrinfo() is treated the same as by ‘ip_addresses’,
including the setting of ‘last_error’.  Failure of getnameinfo() on an
address found by getaddrinfo() is _not_ reflected in ‘last_error’, but
leaves a name out of the return set.

See also ‘hostname’ and ‘peer_name’.


File: setl-lib.info,  Node: type-testing,  Next: is_open,  Prev: ip_names,  Up: The Library

‘is_TYPE’  -  type testers
==========================

     op is_atom (var) : boolean
     op is_boolean (var) : boolean
     op is_integer (var) : boolean
     op is_map (var) : boolean
     op is_mmap (var) : boolean
     op is_numeric (var) : boolean
     op is_om (var) : boolean
     op is_real (var) : boolean
     op is_routine (var) : boolean
     op is_set (var) : boolean
     op is_smap (var) : boolean
     op is_string (var) : boolean
     op is_tuple (var) : boolean

The operator ‘is_map’ (or equivalently ‘is_mmap’, for “multi-valued
map”) returns ‘true’ if its operand is a set consisting entirely of
ordered pairs (tuples of length 2), none of which has ‘om’ as its first
member.

The operator ‘is_smap’ (“single-valued map”) adds the further condition
that for a map ‘f’, ‘#domain f = #f’; that is, that ‘f’ takes each
domain element to one range element.

The operator ‘is_atom’ tests for a value created by ‘newat’, and
‘is_routine’ tests for a value created by ‘routine’.

See also ‘type’ and ‘denotype’.

The type-testing operators have rather low precedence, like other unary
predicates (*note Operator Precedence::).


File: setl-lib.info,  Node: is_open,  Next: join,  Prev: type-testing,  Up: The Library

‘is_open’  -  test for being a stream
=====================================

     op is_open (stream F) : boolean

Tests whether F is one of the pre-opened streams ‘stdin’, ‘stdout’, or
‘stderr’; a stream returned by ‘open’, ‘accept’, ‘pipe_from_child’,
‘pipe_to_child’, ‘pump’, ‘tty_pump’, or ‘mkstemp’; or an automatically
opened stream (*note Automatic opening::).

Being a stream is the same as being open at the SETL level; a stream
ceases to exist when it is closed.

Although SETL provides no intrinsic specifically for testing whether a
given plausible file descriptor FD is open at the underlying _POSIX_
level (an uncommon use case), ‘dup2(FD,FD)’ returns FD if it is, or sets
‘last_error’ and returns ‘om’ otherwise.

See also ‘close’.

Being a predicate, ‘is_open’ has rather low precedence (*note Operator
Precedence::).


File: setl-lib.info,  Node: join,  Next: kill,  Prev: is_open,  Up: The Library

‘join’  -  concatenate tuple of strings, with delimiter
=======================================================

     proc join (tuple T, string GLUE) : string

All elements of the tuple T must be strings, and they are concatenated
together, separated by the delimiter string GLUE.

In general,

     join (T, GLUE) = ("" +/ [GLUE+s : s in T])(#GLUE+1..)

Thus if T is the empty tuple (‘[]’), the result is the empty
string ("").  Note that GLUE is not used when the number of elements
‘#T’ is 0 or 1, but must still be a string.

See also ‘split’.


File: setl-lib.info,  Node: kill,  Next: last_error,  Prev: join,  Up: The Library

‘kill’  -  send signal to process
=================================

     proc kill (integer P)
     proc kill (integer P, integer SIGNAL)
     proc kill (integer P, string SIGNAL)

Calls POSIX kill().  Among processes that the caller of ‘kill’ has
permission to send a signal to, P is interpreted as follows.

If P is greater than 0, the signal is sent to the process with a process
ID equal to P.

If P is 0, the signal is sent to every process whose process group ID is
equal to that of the caller.

If P is negative and not equal to -1, then ‘-P’ is a process group ID,
and the signal is sent to every process in that group.

If P is -1, the signal is sent to every allowed process except for an
unspecified set of system processes.  The signal may or may not be sent
to the calling process.  POSIX doesn’t address this, but Linux excludes
the caller in the -1 case.

If P indicates a nonexistent process or process group, the call has no
effect except upon ‘last_error’.

If SIGNAL is omitted, it defaults to "TERM", or equivalently "SIGTERM".
Signals may be given as integers or more portably as strings.  Case is
not significant.  The signal names HUP, INT, QUIT, ILL, ABRT, FPE, KILL,
SEGV, PIPE, ALRM, TERM, USR1, USR2, CHLD, CONT, STOP, TSTP, TTIN, and
TTOU are defined by POSIX.  A few other common signals such as PWR and
WINCH may also be defined.

As a special case, if SIGNAL is 0, no signal is sent, but the validity
of P is checked and the result is reflected in ‘last_error’.

See also ‘pid’, ‘pexists’, ‘getpgrp’, ‘fork’, ‘pipe_from_child’,
‘pipe_to_child’, ‘pump’, ‘tty_pump’, ‘system’, ‘filter’, and the ‘open’
modes "pipe-from", "pipe-to", "pump" and "tty-pump".


File: setl-lib.info,  Node: last_error,  Next: len,  Prev: kill,  Up: The Library

‘last_error’  -  last error message from system function
========================================================

     last_error : string

After a ‘clear_error’ call, ‘last_error’ has the value ‘no_error’, and
is referred to as “not set”.  Otherwise, it has the most recent setting
by an intrinsic documented as being able to set ‘last_error’.

More precisely, if an intrinsic does set it, it is to

   • the error message returned by POSIX strerror() for the most recent
     setting of POSIX errno, or

   • the error message returned by POSIX gai_strerror() for the most
     recent failed POSIX getaddrinfo() or getnameinfo() call.


File: setl-lib.info,  Node: len,  Next: less,  Prev: last_error,  Up: The Library

‘len’  -  extract leading substring by length
=============================================

     proc len (rw string S, integer N) : string

An initial substring of length ‘N min #S’ is removed from S and
returned.  It is an error for N to be less than 0.

See also the other SNOBOL-inspired intrinsics, namely ‘any’, ‘break’,
‘match’, ‘notany’, ‘span’, ‘rany’, ‘rbreak’, ‘rlen’, ‘rmatch’,
‘rnotany’, and ‘rspan’.


File: setl-lib.info,  Node: less,  Next: lessf,  Prev: len,  Up: The Library

‘less’  -  set less given element
=================================

     op less (set S, var X) : set

Definition: ‘S less X = S - {X}’.

See the set difference (“minus”) operator (‘-’), and also ‘from’,
‘lessf’, and ‘with’.


File: setl-lib.info,  Node: lessf,  Next: lexists,  Prev: less,  Up: The Library

‘lessf’  -  map less given domain element
=========================================

     op lessf (set S, var X) : set

The ‘set’ S must be a map.  The ‘lessf’ operator returns a copy of the
map in which all pairs having X as a first (i.e., domain) element are
removed.

See also ‘less’ and ‘from’.


File: setl-lib.info,  Node: lexists,  Next: link,  Prev: lessf,  Up: The Library

‘lexists’  -  test for existence of file or symlink
===================================================

     op lexists (string) : boolean

Returns ‘true’ iff POSIX lstat() returns 0 on the given pathname.

Note that lstat() does _not_ follow symbolic links, so ‘lexists’ returns
‘true’ for any existing pathname (provided the caller has sufficient
access to all pathname components in reaching it), even a “dangling”
symlink (one that refers to a file that doesn’t exist).

Thus ‘lexists’ is less strict than ‘fexists’, which uses POSIX stat().
Both provide mere snapshots, not automatically synchronized with actions
by other processes.  See ‘link’ and ‘symlink’ for some ways to use files
as mutual exclusion (mutex) locks.

See also ‘readlink’ and ‘unlink’.

Like ‘fexists’, this predicate has rather low precedence (*note Operator
Precedence::).


File: setl-lib.info,  Node: link,  Next: log,  Prev: lexists,  Up: The Library

‘link’  -  create hard link
===========================

     proc link (string F, string NEW)

Creates a link (“hard link”) NEW to the existing file F using POSIX
link(), if NEW does not exist before the call.

If ‘link’ succeeds, NEW and F then refer to the same file.  Otherwise,
such as when NEW already exists, ‘last_error’ is set.

Given stable directory structures above F and NEW, ‘link’ behaves
atomically, and can be used as a test-and-set mechanism for
inter-process synchronization: the mutex (lock file) NEW is acquired if
and when ‘link’ succeeds, and releasing it is done atomically by
‘unlink’.

See also ‘fexists’, ‘symlink’, and ‘rename’, and the ‘open’ modes "n"
and "n+".


File: setl-lib.info,  Node: log,  Next: lpad,  Prev: link,  Up: The Library

‘log’  -  natural logarithm
===========================

     op log (real) : real
     op log (integer) : real

The operand must be greater than 0.

See also ‘exp’.


File: setl-lib.info,  Node: lpad,  Next: magic,  Prev: log,  Up: The Library

‘lpad’  -  pad string on left with blanks
=========================================

     proc lpad (string S, integer N) : string

If ‘N > #S’, the returned string is S padded on the left with blanks to
length N.  Otherwise, S is returned.

It is an error for N to be less than 0.

See also ‘rpad’, which “left-justifies” by padding on the right.


File: setl-lib.info,  Node: magic,  Next: mark,  Prev: lpad,  Up: The Library

‘magic’  -  regular expression recognition switch
=================================================

     magic : boolean

This is a global modal switch.

By default, ‘magic’ is ‘true’, meaning that subscripting and slicing of
subject strings like say S by pattern strings P, P1, and P2 in
expressions like ‘S(P)’ and ‘S(P1..P2)’ interprets the pattern strings
as POSIX “extended regular expressions” (EREs).  This also affects
‘sub’, ‘gsub’, ‘mark’, ‘gmark’, and ‘split’.

You can assign ‘magic := false’, or call ‘set_magic (false)’, to cause
pattern strings to be interpreted literally, i.e., as strings to be
matched exactly somewhere in S.


File: setl-lib.info,  Node: mark,  Next: match,  Prev: magic,  Up: The Library

‘mark’  -  find first occurrence of pattern in string
=====================================================

     proc mark (string S, pattern P) : [integer, integer]

The location of the first (leftmost) occurrence of the pattern P in the
string S is returned as a pair of integers ‘[I, J]’ which index the
first and last characters in the substring matched by P, i.e.,
‘S(I..J)’.

If there is no such occurrence, ‘om’ is returned.

With ‘magic’ left at its default setting of ‘true’, a string-valued P is
interpreted as a POSIX extended regular expression (ERE).

If ‘magic’ is ‘false’, a string-valued P is interpreted literally as the
substring of S to match.

If P is a pair ‘[P1, P2]’ of strings, it represents a pattern that
begins with P1 and ends with the first subsequent occurrence of P2.  The
setting of ‘magic’ applies to each of P1 and P2.  There can be any
characters between P1 and P2, regardless of ‘magic’—sort of like the ERE
".*", but not so greedy.

As with the SETL expression ‘S(P1..P2)’, the substring of S matched by a
pattern pair begins with the first character of the first substring
matching P1 and ends with the last character of the first substring
matching P2 after that.

Also in line with SETL ‘S(P1..P2)’ expressions, either or both of P1 and
P2 may be an integer index rather than a pattern-bearing string, again
irrespective of ‘magic’.  If P1 is an integer, it simply becomes the I
in the returned ‘[I, J]’.  If P2 is an integer, J is the greater of P2
and ‘I-1’.

Like in string subscripting expressions, P can be an ‘integer’, in which
case ‘mark’ returns ‘[P, P]’ if ‘P <= #S’, or ‘[P, P-1]’ otherwise.

See also ‘gmark’, ‘sub’, and ‘gsub’.


File: setl-lib.info,  Node: match,  Next: max,  Prev: mark,  Up: The Library

‘match’  -  extract leading substring by exact match
====================================================

     proc match (rw string S, string P) : string

If P is an initial substring of S, i.e., if ‘S(1..#P) = P’, it is
removed from S and returned.  Otherwise, nothing happens to S and the
empty string ("") is returned.

See also the other SNOBOL-inspired intrinsics, namely ‘any’, ‘break’,
‘len’, ‘notany’, ‘span’, ‘rany’, ‘rbreak’, ‘rlen’, ‘rmatch’, ‘rnotany’,
and ‘rspan’.


File: setl-lib.info,  Node: max,  Next: min,  Prev: match,  Up: The Library

‘max’  -  maximum
=================

     op max (integer, integer) : integer
     op max (real, real) : real
     op max (integer, real) : integer
     op max (integer, real) : real
     op max (real, integer) : integer
     op max (real, integer) : real
     op max (string, string) : string
     op max (tuple, tuple) : tuple

Strings are compared character by character, as if using the codes
arising from ‘ichar’.  Tuple comparisons are element by element, and
recursive.  If one string or tuple is a prefix of the other, the longer
one is considered larger.

For mixed numeric modes, the ‘integer’ is converted to ‘real’ before
comparison, but the result has the type of the larger, or of the first
operand in case of a tie.

If either operand is a floating-point NaN (“Not a Number”), the result
is a NaN.  Contrast POSIX fmax(), which returns the non-NaN arg when
there is just one.

Examples:
     1 max 2 = 2  -- max is a binary operator
     max/ [1, 2, 3] = 3  -- max/ T gives max over set or tuple T
     X max/ [] = X  -- but unary max/ [] is erroneous

See also the order-based “comparatives”, and ‘min’.


File: setl-lib.info,  Node: min,  Next: mkstemp,  Prev: max,  Up: The Library

‘min’  -  minimum
=================

     op min (integer, integer) : integer
     op min (real, real) : real
     op min (integer, real) : integer
     op min (integer, real) : real
     op min (real, integer) : integer
     op min (real, integer) : real
     op min (string, string) : string
     op min (tuple, tuple) : tuple

Strings are compared character by character, as if using the codes
arising from ‘ichar’.  Tuple comparisons are element by element, and
recursive.  If one string or tuple is a prefix of the other, the shorter
one is considered smaller.

For mixed numeric modes, the ‘integer’ is converted to ‘real’ before
comparison, but the result has the type of the smaller, or of the first
operand in case of a tie.

If either operand is a floating-point NaN (“Not a Number”), the result
is a NaN.  Contrast POSIX fmin(), which returns the non-NaN arg when
there is just one.

This operator is commonly used in the combining form, ‘min/’, over a set
or tuple.  See ‘max’ examples.


File: setl-lib.info,  Node: mkstemp,  Next: mod,  Prev: min,  Up: The Library

‘mkstemp’  -  create and open temporary file
============================================

     proc mkstemp (rw string TEMPLATE) : integer

The TEMPLATE must end in the characters "XXXXXX", which will be
overwritten by characters that make the resulting string contain the
name of a file that does not currently exist.

Then a file with that name is created with read/write permissions for
the owner and none for others, using POSIX mkstemp().  A SETL ‘open’ in
"w+" mode is effectively performed over that, and the resulting file
descriptor is returned.

On failure, ‘last_error’ is set and ‘om’ is returned.  The TEMPLATE is
not modified in that case.

The funky signature, with its read/write template arg, resembles that of
the underlying POSIX function.

See also ‘seek’, ‘rewind’, ‘puts’, ‘gets’, and ‘filename’.


File: setl-lib.info,  Node: mod,  Next: nargs,  Prev: mkstemp,  Up: The Library

‘mod’  -  integer modulus; symmetric set difference
===================================================

     op mod (integer, integer) : integer
     op mod (set, set) : set

SETL yields a non-negative remainder as the result of ‘mod’, following
the usual mathematical “clock arithmetic” definition.  The sign of the
denominator is immaterial, so:

      5 mod  3 = 2
     -5 mod  3 = 1
      5 mod -3 = 2
     -5 mod -3 = 1

See also ‘rem’ and ‘div’.

The set-theoretic symmetric difference operator ‘mod’ is analogous to
the logical “exclusive or”, and is likewise associative and commutative
(unlike ‘mod’ over integers, which is neither).  Two sets S and T can be
swapped without an intermediate temporary variable thus:

     S mod:= T;  -- add the info in T to S
     T mod:= S;  -- take out the T, leaving old S
     S mod:= T;  -- take out the old S, leaving old T

See also the regular set difference (“minus”) operator (‘-’).


File: setl-lib.info,  Node: nargs,  Next: newat,  Prev: mod,  Up: The Library

‘nargs’  -  number of arguments given by caller
===============================================

     nargs : integer

For procedures that take a variable number of arguments (i.e., have the
token sequence ‘(*)’ after the final formal parameter, which the
procedure sees as a tuple), ‘nargs’ is the total number of arguments
supplied by the caller to the currently active procedure.


File: setl-lib.info,  Node: newat,  Next: no_error,  Prev: nargs,  Up: The Library

‘newat’  -  create new atom
===========================

     proc newat : atom

This creates a unique ‘atom’, whose salient property is merely that it
is different from all other ‘atom’s created by the current process.
Atoms are like opaque pointers, and cannot be meaningfully exchanged
between programs.  They are sometimes used to highlight the domain
independence of an abstract algorithm, but are otherwise rather useless.
Real applications tend to be expressed over concrete domains with
fitting rules and conventions.

See also ‘is_atom’.


File: setl-lib.info,  Node: no_error,  Next: not,  Prev: newat,  Up: The Library

‘no_error’  -  non-error message
================================

     no_error : string

This is the value of ‘last_error’ immediately after a call to
‘clear_error’.  It is typically some locale-dependent version of "No
error" or "Success".


File: setl-lib.info,  Node: not,  Next: notany,  Prev: no_error,  Up: The Library

‘not’  -  logical negation
==========================

     op not (boolean) : boolean

The unary predicate ‘not’ has a precedence above ‘and’, ‘or’, and
‘impl’, but below that of all the other binary operators and
non-predicates.  *Note Operator Precedence::.  Still, generous use of
parentheses is recommended for readability and for ease of
transliteration to other languages.

See also the bitwise operators such as ‘bit_not’.


File: setl-lib.info,  Node: notany,  Next: notin,  Prev: not,  Up: The Library

‘notany’  -  extract leading character using character set
==========================================================

     proc notany (rw string S, string P) : string

If the first character of S does not occur in P (treating P as a set of
characters), that first character is removed from S and returned.
Otherwise, nothing happens to S, and the empty string ("") is returned.

See also the other SNOBOL-inspired intrinsics, namely ‘any’, ‘break’,
‘len’, ‘match’, ‘span’, ‘rany’, ‘rbreak’, ‘rlen’, ‘rmatch’, ‘rnotany’,
and ‘rspan’.


File: setl-lib.info,  Node: notin,  Next: npow,  Prev: notany,  Up: The Library

‘notin’  -  membership test
===========================

     op notin (var X, set S) : boolean
     op notin (var X, tuple S) : boolean
     op notin (string X, string S) : boolean

Definition: ‘(X notin S) = not (X in S)’.


File: setl-lib.info,  Node: npow,  Next: nprint,  Prev: notin,  Up: The Library

‘npow’  -  all subsets of a given size
======================================

     op npow (integer N, set S) : set
     op npow (set S, integer N) : set

Definition: ‘S npow N = N npow S = {SS in pow S | #SS = N}’.

This is the set of all subsets of S that have N members, or the empty
set if N exceeds ‘#S’.  It is an error for N to be negative.


File: setl-lib.info,  Node: nprint,  Next: nprinta,  Prev: npow,  Up: The Library

‘nprint’  -  print to ‘stdout’ with no trailing newline
=======================================================

     proc nprint (var ARGS(*))

Equivalent to ‘nprinta (stdout, ARGS(*))’.

See also ‘print’ and ‘write’.


File: setl-lib.info,  Node: nprinta,  Next: odd,  Prev: nprint,  Up: The Library

‘nprinta’  -  print to stream with no trailing newline
======================================================

     proc nprinta (stream F, var ARGS(*))

The 0 or more ARGS are written in sequence to the stream F, separated by
single spaces.  String arguments are written directly; all others are
converted as if by ‘str’ first.

If F is not already open, an attempt is made to auto-open it.  *Note
Automatic opening::.

Note that the output of the program

     nprinta (stderr, 1, 2);

is ‘1 2’, which is not the same as the output of the program

     nprinta (stderr, 1);
     nprinta (stderr, 2);

which is ‘12’.

On output error, output may be incomplete and ‘last_error’ may be set.

See also ‘nprint’, ‘printa’, and ‘writea’.


File: setl-lib.info,  Node: odd,  Next: om,  Prev: nprinta,  Up: The Library

‘odd’  -  test for integer not divisible by 2
=============================================

     op odd (integer) : boolean

Not ‘even’, though it shares the rather low precedence of that
predicate.


File: setl-lib.info,  Node: om,  Next: open,  Prev: odd,  Up: The Library

‘om’  -  the “undefined” value
==============================

     om

This is the default value of all uninitialized SETL variables, undefined
set, range, or tuple elements, the implicit return value of all routines
that do not return anything else, and the default result of many
operations when they fail in ways that are not held to be errors.

Ideal if nothing is what you want.  Sounds nice when said slowly.
Depicted as a capital omega in the ancient texts.  Could stand for
“omitted” in some places.

See also ‘is_om’, ‘type’, ‘denotype’, ‘str’, and ‘unstr’.


File: setl-lib.info,  Node: open,  Next: or,  Prev: om,  Up: The Library

‘open’  -  open a stream
========================

     proc open (stream F, string HOW) : integer

Tries to create a stream for F, where F may be

   • a string such as a filename, other pathname, command, or signal
     name,

   • a tuple representing an interval timer or Internet service
     location, or

   • an integer fd that is already open at the POSIX (operating system)
     level but not at the SETL level (see below).

How F is interpreted depends on the mode argument, HOW.  *Note Arguments
to ‘open’: open arguments.

On success, the returned fd (or “pseudo-fd”, for a signal or timer
stream) serves as a stream handle for use in SETL I/O.  The fd is then
“open at the SETL level”.  The stream incorporates relevant state and
buffer structure.  *Note Buffering::.

On failure due to external factors such as a missing file, ‘open’ sets
‘last_error’ and returns ‘om’.

The ‘open’ described here is almost upwardly compatible with the old
CIMS SETL open.  It is completely compatible for programs which ignored
the return value, because all I/O intrinsics in the present SETL accept
as a stream specifier either the argument that was originally passed to
a successful ‘open’ call (if the arg is unique) or the file descriptor
(fd) that was returned by it.  This ‘open’ is also compatible with SETL2
in that the fd serves as a unique handle.

* Menu:

* open arguments::        Arguments to ‘open’.
* Network sockets::       TCP and UDP sockets.
* Local sockets::         Unix-domain sockets.
* Pipes and pumps::       Connected subprocesses.
* Signal streams::        Signal streams.
* Timer streams::         Timer streams.
* Predefined streams::    Predefined streams.
* Automatic opening::     Automatic opening (and closing) of streams.
* Buffering::             Buffering.
* open apocrypha::        Alternative HOW arguments to ‘open’.


File: setl-lib.info,  Node: open arguments,  Next: Network sockets,  Up: open

Arguments to ‘open’
-------------------

Valid values of the case-insensitive I/O mode argument HOW, and their
meanings, are:

mode                   meaning
------------------------------------------------------------------------
"r"                    sequential and direct access input
"w"                    sequential and direct access output
"n"                    like "w", but new file only
"a"                    sequential output, append to file
"r+"                   direct access r/w, existing file
"w+"                   direct access r/w, empty file first
"n+"                   like "w+", but new file only
"a+"                   direct access read, write at end
"rw"                   sequential bidirectional I/O
"pipe-from"            input from shell command
"pipe-to"              output to shell command
"pump"                 I/O to and from shell command
"tty-pump"             I/O to and from pty-wrapped command
"tcp-client"           TCP client socket
"tcp-server"           TCP server socket
"tcp-peer"             connected TCP socket
"udp-client"           UDP client socket
"udp-server"           UDP server socket
"unix-client"          Unix-domain stream client socket
"unix-server"          Unix-domain stream server socket
"unix-peer"            connected Unix-domain stream socket
"unix-datagram-client" Unix-domain datagram client socket
"unix-datagram-server" Unix-domain datagram server socket
"signal"               one input line per catch
"ignore"               signal to be ignored
"default"              signal to be given default effect
"real-ms"              one input line per timer expiry

GNU SETL also has many synonyms for these I/O modes, perhaps best not
used in new code (*note Alternative HOW arguments to ‘open’: open
apocrypha.).

For all of modes "r" through "unix-datagram-server" above, F may be a
file descriptor (fd) that is already open at the POSIX level but not at
the SETL level.  More on that below.

Modes "r" through "rw" cause a POSIX open() call with the following
flags:

mode    POSIX open() flags                   seekable?
------------------------------------------------------------------------
"r"     O_RDONLY                             yes
"w"     O_WRONLY | O_CREAT | O_TRUNC         yes
"n"     O_WRONLY | O_CREAT | O_EXCL          yes
"a"     O_WRONLY | O_CREAT | O_APPEND        no
"r+"    O_RDWR                               yes
"w+"    O_RDWR | O_CREAT | O_TRUNC           yes
"n+"    O_RDWR | O_CREAT | O_EXCL            yes
"a+"    O_RDWR | O_CREAT | O_APPEND          yes
"rw"    O_RDWR                               no

A stream termed “seekable” is not actually known at the time of ‘open’
to be on a file supporting direct access.  Where not, a ‘seek’,
‘rewind’, ‘gets’, or ‘puts’ call will generally fail on the underlying
POSIX lseek() attempt, which is then considered erroneous.

Prior to that seeking attempt, any buffered output is flushed (written
out to the file, ignoring any output errors that may occur), and any
buffered input is drained (discarded).  *Note Buffering::.

The "pipe-from", "pipe-to", "pump", and "tty-pump" modes cause an
external program, given as a shell command string, to be run as a
subprocess whose standard input and/or standard output is connected to
the fd returned by ‘open’.  *Note Connected subprocesses: Pipes and
pumps.

Modes "tcp-client", "tcp-server", "udp-client", and "udp-server" create
network socket streams, with F specifying an Internet host and service,
except of course where F is the fd of a socket that already exists at
the POSIX level.  The mode "tcp-peer" opens a stream over the fd of a
connected TCP socket.  *Note TCP and UDP sockets: Network sockets.

Modes "unix-client" through "unix-datagram-server" create the
corresponding Unix-domain socket streams, with F specifying a pathname
for the socket in the local filesystem space.  For symmetry with
"tcp-peer", the mode "unix-peer" can be used when F is the fd of a
connected non-datagram Unix-domain socket.  *Note Unix-domain sockets:
Local sockets.

The term “stream” for datagram sockets is a bit of a stretch, as they
are distinguished by being _not_ “stream-oriented”.  Likewise,
"tcp-server" and "unix-server" sockets do not stream data, but are only
used to ‘accept’ new clients.

When F is a fd, the assumption is that the mode you provide is
compatible with how the fd is open at the POSIX level.  So, for example,
"rw" is a good mode to use to ‘open’ the fd of an inherited
bidirectional stream (such as a connected socket, coprocess, or
input/output device); and "r" or "r+" might be appropriate for a
direct-access file.  In some cases, you might want to provide a more
specific mode, like the abovementioned "tcp-peer" to indicate that you
intend to do operations requiring a connected TCP socket.

For modes "signal", "ignore", and "default", F must be a signal name.
*Note Signal streams::.

For mode "real-ms", F must be an ordered pair (2-tuple) of integers
‘[INITIAL, INTERVAL]’ where INITIAL is the number of milliseconds before
the first desired timer expiry and INTERVAL the period after that.
*Note Timer streams::.


File: setl-lib.info,  Node: Network sockets,  Next: Local sockets,  Prev: open arguments,  Up: open

TCP and UDP sockets
-------------------

For modes "tcp-client", "tcp-server", "udp-client", and "udp-server",
the first argument to ‘open’ should be (unless a fd) a 2-tuple ‘[H, P]’
where H identifies an Internet host by name or by address in IPv4 dotted
or IPv6 colon-rich notation, and P is a service name or a port number
given as an integer or string of decimal digits.

For the server modes, H may be "0.0.0.0" to request that connections or
datagrams be accepted on any IPv4 interface, or "::" for any IPv6
interface.  It is also possible to let the system choose which kind of
interface to use for the server socket, by letting H be ‘om’ or the
empty string ("").  The wise client would then try both IPv4 and IPv6.
A more accommodating server might listen (or take datagrams) on both
"0.0.0.0" and "::".

If the P in ‘[H, P]’ is zero or ‘om’ (omitted), the system chooses an
available port number which can be retrieved using ‘port’ or ‘sockaddr’.

For example, given

     FD := open ([om, 0], "tcp-server")

the value of ‘sockaddr FD’ might be something like ‘["0.0.0.0", 42113]’
or ‘["::", 53622]’.

For mode "tcp-server", the POSIX-level socket option SO_REUSEADDR is set
on the listening socket.

A call to ‘open’ a TCP client connection can block for an unspecified
length of time, as can a call to an intrinsic that attempts to auto-open
one (*note Automatic opening::).

If the first arg to ‘open’ is the fd of an already connected TCP socket,
such as might have arisen from ‘accept’, the mode "tcp-peer" can be used
to open a SETL stream over it, to indicate intent to call things like
‘peer_sockaddr’ that require a connected TCP socket.  Such a socket is
indistinguishable at the programming level from a client socket, so mode
"tcp-client" would work just as well but be misleading in the case of an
accepted client.  The designation "tcp-peer" is also a good fit to the
case where you don’t care which role (client or server) the socket
plays.  (If you don’t even care that it’s a socket, the more generic
mode "rw" might serve better still.)

The only I/O (data-transferring) operations allowed on UDP client
sockets are ‘send’ and ‘recv’, and the only ones allowed on UDP server
sockets are ‘sendto’ and ‘recvfrom’.  Conversely, ‘recv’ can only be
used on UDP client sockets (not on Unix-domain datagram client sockets,
which have no names and thus cannot be sent to).  But ‘send’ can be used
on either kind of datagram client socket, and ‘recvfrom’ and ‘sendto’
can be used on either kind of datagram server socket.

For legacy support, the canonical ‘[H, P]’ tuple for identifying a host
and port may be given as a string of the form "H:P".

Failure of ‘open’ for a network socket mode gives ‘om’ instead of a fd,
and sets ‘last_error’ in accordance with the failing POSIX socket(),
connect(), bind() or listen() call.  A fd passed to ‘open’ that is not
open at the POSIX level sets ‘last_error’ to a locale-dependent version
of “Bad file descriptor”.

See also ‘peer_address’, ‘peer_name’, and ‘peer_port’.


File: setl-lib.info,  Node: Local sockets,  Next: Pipes and pumps,  Prev: Network sockets,  Up: open

Unix-domain sockets
-------------------

For modes "unix-client", "unix-server", "unix-datagram-client", and
"unix-datagram-server", the first arg to ‘open’ must be (unless a fd) a
pathname F for the socket.  A Unix-domain (local) socket is created by
POSIX socket(), and its file descriptor is returned by ‘open’ if one of
these cases also succeeds:

   bullet For a client mode, POSIX connect() connects the socket to the
     server at F.  No actual connection is made in the case of
     "unix-datagram-client", but a later ‘send’ will use the remembered
     pathname.

   bullet For a server mode, any existing pathname F is removed by POSIX
     unlink(), and then created and bound to the socket by POSIX bind().
     The unlink() is meant to improve the chances of success of the
     bind(), but the sequence of calls is not performed as an atomic
     unit.  The pathname has all permissions enabled, minus those turned
     off by the current file mode creation mask (see ‘umask’).  For mode
     "unix-server", POSIX listen() is then called.

Errors in any of the above POSIX calls cause ‘open’ to return ‘om’ and
set ‘last_error’.  The expected ENOENT from unlink() does not count as
an error.

If the first arg to ‘open’ is the fd of an already connected Unix-domain
stream socket, such as might have arisen from ‘accept’, the mode
"unix-peer" can be used to open a SETL stream over it, for symmetry with
"tcp-peer" mode.

Upon ‘close’ of a server socket, the pathname is again removed.  Errors
from unlink() are ignored in this case, as the pathname may legitimately
have been removed already.

File descriptors may be passed on non-datagram Unix-domain sockets using
‘send_fd’ and ‘recv_fd’.

Unix-domain sockets do not support network-oriented queries such as
‘sockaddr’ and ‘peer_name’.  Unix-domain datagram client sockets do not
support ‘recv’, as they are anonymous and thus cannot be sent to.

In other respects, Unix-domain sockets act much like their network
counterparts (*note TCP and UDP sockets: Network sockets.):

Unix-domain                   network
------------------------------------------------------------------------
"unix-client"                 "tcp-client"
"unix-server"                 "tcp-server"
"unix-peer"                   "tcp-peer"
"unix-datagram-client"        "udp-client"
"unix-datagram-server"        "udp-server"

They do have some particular advantages over network sockets though,
such as the absence of lingering connection state when the server closes
first, and the immediate “broken pipe” error seen by the sender on a
write when the receiver has done a ‘shut_rd’.


File: setl-lib.info,  Node: Pipes and pumps,  Next: Signal streams,  Prev: Local sockets,  Up: open

Connected subprocesses
----------------------

For a "pipe-from" stream, the standard output of the child process is
connected to the (readable) fd returned by ‘open’ in the parent process.

For a "pipe-to" stream, the child’s standard input is connected to the
parent’s (writable) fd.

For a "pump" stream, the standard input and output of the child process
are both connected to the parent’s (bidirectional) fd.

The connection between parent and child in all three of these cases is a
Unix-domain socketpair, and therefore supports ‘send_fd’ and ‘recv_fd’.

A "tty-pump" stream resembles a "pump" stream, but the child’s standard
input and output are instead connected to the slave side of a
pseudo-terminal (pty) in “raw” mode, while the ‘open’ caller gets the fd
of the master.  The child’s terminal-like environment lets the parent
direct a program intended for interactive use.  Also, since POSIX
programs usually line buffer their standard output instead of block
buffering it when stdout appears to be connected to a terminal, the
"tty-pump" mode lets you use an off-the-shelf program such as sed or awk
as a coprocess in line-by-line message exchange fashion, without
response lines getting stuck in the child’s output buffer and never
being seen by the parent.

A string first argument F to ‘open’ gives a command to be run by the
standard shell, as if by ‘exec ("/bin/sh", ["sh", "-c", F])’.  The
command is run in a subprocess created as if by ‘pipe_from_child’,
‘pipe_to_child’, ‘pump’, or ‘tty_pump’.

For all these subprocess streams, the second argument to the ‘close’
that balances the ‘open’ is significant.  The default of ‘close_await’
is usually appropriate, and sets ‘status’ to the child’s exit status.
Unclosed pipe/pump streams are closed automatically upon program
termination, but _not_ using ‘close_await’.

The signal dispositions in the child are as for a ‘fork’, followed in
the above ‘open’ modes by an ‘exec’.

See also ‘pid’, ‘kill’, ‘filter’, ‘system’, ‘flush’, ‘shutdown’, and
‘socketpair’.


File: setl-lib.info,  Node: Signal streams,  Next: Timer streams,  Prev: Pipes and pumps,  Up: open

Signal streams
--------------

When the HOW argument to ‘open’ is "signal", "ignore", or "default", the
F argument may be one of the following case-insensitive signal names,
with or without the "SIG" prefix:

signal name   default action          usual meaning
------------------------------------------------------------------------
"SIGHUP"      terminate process       modem hangup, or reread config
                                      file
"SIGINT"      terminate process       interrupt from keyboard (e.g.,
                                      ‘ctrl-C’)
"SIGQUIT"     terminate; dump core    quit from keyboard (e.g.,
                                      ‘ctrl-\’)
"SIGUSR1"     terminate process       user-defined signal 1
"SIGUSR2"     terminate process       user-defined signal 2
"SIGPIPE"     terminate process       write to pipe or socket with
                                      no readers
"SIGALRM"     terminate process       timer expiry
"SIGTERM"     terminate process       software termination request
"SIGCHLD"     ignore                  child status change
"SIGCONT"     ignore                  continue after stoppage
"SIGTSTP"     stop process            terminal stop signal
"SIGTTIN"     stop process            background process attempting
                                      read
"SIGTTOU"     stop process            background process attempting
                                      write
"SIGXCPU"     terminate; dump core    soft CPU limit exceeded
"SIGXFSZ"     terminate; dump core    soft filesize limit exceeded
"SIGPWR"      ignore                  low battery, or power failure
                                      imminent
"SIGWINCH"    ignore                  terminal window size change

The default actions shown here are the POSIX defaults, corresponding to
a disposition of SIG_DFL at the POSIX sigaction() level.  The actual
disposition for most may be inherited by the SETL program as if by
SIG_IGN (ignore the signal).

SIGPWR and SIGWINCH are not specified by POSIX, but are widely
available.

There are many signals that can be sent by ‘kill’ but cannot be caught
or ignored, such as SIGKILL.

The “file descriptor” returned by ‘open’ for any of these stream types
is a “pseudo-fd”, meaning a small integer like a POSIX fd but phony in
that it lies outside the normal fd range (which is limited by the host
operating system; see your shell’s ‘ulimit’ or ‘limit’ command for the
maximum number of open files, which is one more than the highest
possible system-level fd.

The pecking order for signal handling is as follows:

   • Whenever a signal is caught because there is at least one "signal"
     stream open on that signal name, an empty line is delivered to
     every such stream.

     Applications are encouraged to anticipate information content in
     extensions of the "signal" stream type by reading an arbitrary
     line, e.g. by using ‘getline’ or ‘geta’, or ‘reada’ with only the
     stream arg.

   • Otherwise (no "signal" streams open for the given signal name),
     when a signal is received and there is at least one stream of mode
     "ignore" open on that signal name, the signal is ignored as if by
     SIG_IGN at the POSIX sigaction() level.

   • Otherwise (neither of the above), when a signal is received and
     there is at least one stream of mode "default" open on that signal
     name, the signal is defaulted as if by POSIX SIG_DFL to the default
     action in the above table.

   • Otherwise, with no streams open on a given signal name, the signal
     disposition is given by the program environment, which is typically
     (but not necessarily) the default listed in the above table.

Note that "ignore" and "default" streams are created only for their
effects on signal dispositions.  The only thing you can do with one is
‘close’ it, which may cause its disposition to revert according to the
above pecking order (catch, ignore, default, inherit).

To allow the SETL implementation to use SIGCHLD in support of
‘close_autoreap’, opening SIGCHLD in "ignore" or "default" mode does not
respectively prevent or enable zombies as a POSIX-level SIG_IGN or
SIG_DFL disposition would.

A "signal" stream opened on SIGCHLD gets a line each time a child
process terminates, stops (suspends), or continues (resumes).  This type
of signal does not necessarily queue, and applications may do well to
loop over some non-blocking ‘waitpid’ and ‘status’ checks each time a
line is received from a SIGCHLD stream.

To allow the SETL implementation to use SIGALRM in support of the
"real-ms" mode (*note Timer streams::), SIGALRM cannot be opened as a
"signal" stream, despite its appearance in the above table.  It can,
however, be opened in "ignore" or "default" mode, in order to control
the initial disposition of SIGALRM in child processes, as all timer
streams are closed initially in the child, letting the POSIX-level
SIG_IGN or SIG_DFL take effect according to the rules given above.  If
no SIGALRM stream is open, its disposition in the child is what the
parent began with.

Signal streams can be used with ‘select’.


File: setl-lib.info,  Node: Timer streams,  Next: Predefined streams,  Prev: Signal streams,  Up: open

Timer streams
-------------

For mode "real-ms", the first arg to ‘open’ should be a pair of integers
‘[INITIAL, INTERVAL]’ giving the number of milliseconds before the first
timer expiry and between subsequent expiries.

The degenerate form ‘[INTERVAL]’, meaning ‘[INTERVAL, INTERVAL]’, may
also be used, and for back-compatibility, the interval may be given as a
decimal string rather than in a tuple.

As with a signal stream, the fd returned by ‘open’ is a pseudo-fd.

All timer streams are initially closed in a child process, which allows
its initial SIGALRM disposition to be controlled by the parent (*note
Signal streams::).

Timer streams can be used with ‘select’.


File: setl-lib.info,  Node: Predefined streams,  Next: Automatic opening,  Prev: Timer streams,  Up: open

Predefined streams
------------------

There are three predefined streams with the following case-insensitive
aliases:

name        fd      aliases                          meaning
------------------------------------------------------------------------
‘stdin’     ‘0’     "", "-", "stdin", "input"        standard input
‘stdout’    ‘1’     "", "-", "stdout", "output"      standard output
‘stderr’    ‘2’     "stderr", "error"                standard error

Files whose actual names are ‘input’, ‘ERROR’, etc. may still be
referred to by explicitly opening them before starting I/O on them.
This will cause such names not to act as standard aliases again until
they are closed as streams.

The empty string ("") acts as ‘stdin’ or ‘stdout’ depending on the
direction of the stream operation.  Likewise for the hyphen ("-").

You can ‘close’ ‘stdin’, ‘stdout’, or ‘stderr’ at any time, and by the
rules of POSIX, the next ‘open’ will choose the lowest fd, providing a
mechanism by which you can implement redirection à la shell.  See also
‘dup2’.


File: setl-lib.info,  Node: Automatic opening,  Next: Buffering,  Prev: Predefined streams,  Up: open

Automatic opening (and closing) of streams
------------------------------------------

The intrinsics ‘geta’, ‘getb’, ‘getc’, ‘getfile’, ‘getline’, ‘getn’,
‘peekc’, and ‘reada’ attempt to open a stream F automatically if it is
not already open at the SETL level.  This also applies when F is a
member of the “readable” set passed to ‘select’.

If F is a tuple of up to 2 elements, these intrinsics try to open a
bidirectional TCP client connection or a (read-only) interval timer,
depending on the type of ‘F(1)’: an integer indicates a timer (*note
Timer streams::).

If F is a string or integer, they try to ‘open’ it in sequential reading
("r") mode.

Similarly, ‘nprinta’, ‘printa’, ‘puta’, ‘putb’, ‘putc’, ‘putfile’,
‘putline’, and ‘writea’ (and ‘select’ when F appears in the “writable”
set) attempt to auto-open F as a bidirectional TCP client socket if it
is a 2-tuple, or as a sequential output stream otherwise ("w" mode).

The ‘accept’ intrinsic attempts to auto-open a TCP server socket for any
argument that would satisfy ‘open’ in "tcp-server" mode.

The intrinsics ‘gets’, ‘puts’, ‘rewind’, and ‘seek’ attempt to auto-open
a stream in "r+" mode (read/write direct access to an existing file) for
any string or plausible fd first argument.

The intrinsics ‘send’ and ‘recv’ attempt to auto-open a UDP client
socket if F is not already a stream, and ‘sendto’ and ‘recvfrom’ try to
auto-open a UDP server socket.  This applies when F is a tuple, string,
or integer.

Failure of auto-open is considered erroneous except in the case of
‘getfile’, which sets ‘last_error’ and returns ‘om’.

When the ‘eof’ indicators are being set, a stream that has been
auto-opened will be auto-closed as if by ‘close’ (which may cause
‘last_error’ to be set), except that a stream auto-opened in "r+" mode
is never auto-closed.

The only _output_ intrinsic that auto-closes a stream is ‘putfile’, and
only on an auto-opening call.

No intrinsic ever attempts to open a stream in mode "n", "a", "w+",
"n+", "a+", "rw", "pipe-from", "pipe-to", "pump", "tty-pump",
"unix-client", "unix-server", "unix-datagram-client",
"unix-datagram-server", "signal", "ignore", or "default".


File: setl-lib.info,  Node: Buffering,  Next: open apocrypha,  Prev: Automatic opening,  Up: open

Buffering
---------

An important difference between file descriptors that are open at the
SETL level and the POSIX file descriptors that underlie them at the
system level is that at the SETL level, a fd returned by ‘open’
implicitly has an attached buffer structure for SETL-level I/O state.

This is also true for a fd returned by ‘accept’, ‘mkstemp’,
‘pipe_from_child’, ‘pipe_to_child’, ‘pump’, or ‘tty_pump’, but _not_ for
any fd returned by the low-level intrinsics ‘dup’, ‘dup2’, ‘socketpair’,
‘pipe’, or ‘recv_fd’.

Thus the POSIX fd, a small non-negative integer, serves as a handle for
the SETL stream.  Contrast this with C, where buffered I/O is usually
done by the “stdio” layer using a separate ‘FILE’ object that contains
the fd and the buffer structure.

Data written by intrinsics such as ‘putc’ accumulates in the stream’s
output buffer until the stream is “flushed” by writing the data out
using POSIX write() or equivalent.  Flushing is done automatically
according to the buffering policy associated with the stream, and
whenever ‘flush’ is called:

   • In the “block” buffering policy, the output buffer is flushed
     whenever it becomes full.  The implementation-defined capacity of
     the output buffer is typically on the order of a few thousand
     bytes.

   • The “line” buffering policy is the same as block except that if a
     newline character (‘\n’) is written by the SETL program, the buffer
     is flushed even if it is not yet full.

   • In the “byte” buffering policy, characters are written out at the
     system level as soon as they are written by the SETL program.

The buffering policy is set when the stream is created.  Most streams
are block buffered, but if a sequential data stream is opened on what
appears to be a tty-like device according to POSIX isatty(), it is line
buffered, except in the case of ‘stderr’ (fd 2), which is byte buffered
by default (though *note (setl-user)SETL_LINEBUF_STDERR::).

One implication of output buffering is that most programs that exchange
messages with other programs should always flush output before
attempting input, so that messages are fully sent before replies are
awaited.

The SETL I/O system takes care of most such flushing automatically.  In
particular, a bidirectional stream (such as for a connected socket or
pump or direct-access file) is implicitly flushed whenever input is
initiated on that stream.

More generally, automatic flushing of the output buffer occurs on a data
stream F, and on the stream if any that is linked to F by ‘tie’, when
any of these occur:

   • SETL input (except via ‘gets’) is attempted on F;

   • a ‘select’ call includes F in the “readable” set;

   • ‘recv_fd’ is called on F.

Thus the call ‘tie (stdin, stdout)’ can be used to ensure that ‘stdout’
is auto-flushed before any attempt is made by the program to read from
‘stdin’ or await its readability in a ‘select’-based event loop.

Auto-flushing of F (but not of any tie) is done on calls to:

   • ‘seek’, ‘rewind’, ‘gets’, or ‘puts’;

   • ‘close’, or ‘shutdown’ with a second arg of ‘shut_wr’ or
     ‘shut_rdwr’;

   • ‘send_fd’;

   • ‘ftrunc’ when F is a stream arg (rather than a pathname that is not
     open).

Also, whenever ‘fork’ is called (at least effectively, as for example in
an intrinsic like ‘pump’ which is described as creating a child process
“as if by ‘fork’”), all streams are flushed automatically before the
spawning attempt.

Furthermore, when the program is finalizing in preparation for exit, all
streams are flushed and then all closed.

Although an explicit ‘flush’ call sets ‘last_error’ in the event of a
POSIX write() error, auto-flushing never does, with the sole exception
of ‘putfile’ in the auto-open/auto-close case (*note Automatic
opening::), which acts as if ‘flush’ were called explicitly.

_Input_ buffering is largely invisible at the SETL level.  The SETL
implementation is expected to request up to some number of bytes from
the system (again, typically on the order of a few thousand bytes)
whenever input is requested by the SETL program in the presence of an
empty input buffer.  That system call, typically POSIX read() or
equivalent, after waiting as long as necessary for at least one byte or
an end of file, receives some bytes into the buffer or indicates an
end-of-file or error condition.

Although input buffering is mostly just silently efficient, there are
places where it can be noticed.  One such case is ‘ungetc’, as the SETL
implementation is only required to support _at least_ one character of
pushback after a ‘getc’.  It _may_ allow more.

More significantly, input is “drained” (discarded) upon initiation of
any of these operations on F:

   • SETL output;

   • a seeking operation (‘seek’, ‘rewind’, ‘gets’, ‘puts’);

   • ‘ftrunc’ when F is a stream (rather than a pathname that is not
     open).

The draining of input on every output attempt on F, along with the
automatic flushing of output on every input attempt, is ideal for the
common case of a bidirectional stream used in a message-and-reply or
immediate-handshake regime.  But for truly full-duplex cases where
messages in each direction are to be overlapped, the use of
subprocesses, each with its own copy of the fd, is generally the best
approach in SETL.  The full-duplex operation is then effectively
relegated to the so-called “file description” level (the buffer
structure of the POSIX kernel or equivalent; a file description is
shared by a fd and all its duplicates, whether arising from the likes of
POSIX dup() or from process duplication à la fork()).

Buffering can also be bypassed entirely by using the “non-SETL I/O”
‘sys_read’ and ‘sys_write’ intrinsics.

Datagrams, sent by ‘send’ and ‘sendto’, are not buffered.  Nor are file
descriptors, sent by ‘send_fd’.


File: setl-lib.info,  Node: open apocrypha,  Prev: Buffering,  Up: open

Alternative HOW arguments to ‘open’
-----------------------------------

The following synonyms for the HOW argument also exist in GNU SETL, the
apparent result of over-building on some back-compatibility union of
historical opening mode names.

If the mode names in the left column may be taken as standard, the
aliases on the right should perhaps be deprecated.

Despite the presentation, they are all case-insensitive:

"a"                       "AB"
"a"                       "APPEND"
"a"                       "BINARY-APPEND"
"a"                       "CODED-APPEND"
"a"                       "OUTPUT-APPEND"
"a"                       "PRINT-APPEND"
"a"                       "TEXT-APPEND"
"a+"                      "A+B"
"a+"                      "AB+"
"default"                 "DEFAULT-SIGNAL"
"default"                 "SIGNAL-DEFAULT"
"ignore"                  "IGNORE-SIGNAL"
"ignore"                  "SIGNAL-IGNORE"
"n"                       "BINARY-NEW"
"n"                       "CODED-NEW"
"n"                       "NB"
"n"                       "NEW"
"n"                       "NEW-BINARY"
"n"                       "NEW-CODED"
"n"                       "NEW-TEXT"
"n"                       "NEW-W"
"n"                       "TEXT-NEW"
"n+"                      "BINARY-DIRECT-NEW"
"n+"                      "BINARY-RANDOM-NEW"
"n+"                      "DIRECT-BINARY-NEW"
"n+"                      "DIRECT-NEW"
"n+"                      "N+B"
"n+"                      "NB+"
"n+"                      "NEW+"
"n+"                      "NEW-BINARY-DIRECT"
"n+"                      "NEW-BINARY-RANDOM"
"n+"                      "NEW-DIRECT"
"n+"                      "NEW-DIRECT-BINARY"
"n+"                      "NEW-R+"
"n+"                      "NEW-RANDOM"
"n+"                      "NEW-RANDOM-BINARY"
"n+"                      "NEW-W+"
"n+"                      "RANDOM-BINARY-NEW"
"n+"                      "RANDOM-NEW"
"pipe-from"               "PIPE-IN"
"pipe-to"                 "PIPE-OUT"
"r"                       "BINARY"
"r"                       "BINARY-IN"
"r"                       "CODED"
"r"                       "CODED-IN"
"r"                       "INPUT"
"r"                       "RB"
"r"                       "TEXT"
"r"                       "TEXT-IN"
"r+"                      "BINARY-DIRECT"
"r+"                      "BINARY-RANDOM"
"r+"                      "DIRECT"
"r+"                      "DIRECT-BINARY"
"r+"                      "R+B"
"r+"                      "RANDOM"
"r+"                      "RANDOM-BINARY"
"r+"                      "RB+"
"rw"                      "BIDIRECTIONAL"
"rw"                      "INPUT-OUTPUT"
"rw"                      "READ-WRITE"
"rw"                      "TWO-WAY"
"rw"                      "TWOWAY"
"signal"                  "SIGNAL-IN"
"tcp-client"              "TCP-CLIENT-SOCKET"
"tcp-client"              "CLIENT-SOCKET"
"tcp-client"              "SOCKET"
"tcp-server"              "TCP-SERVER-SOCKET"
"tcp-server"              "SERVER-SOCKET"
"tty-pump"                "LINE-PUMP"
"udp-client"              "UDP-CLIENT-SOCKET"
"udp-server"              "UDP-SERVER-SOCKET"
"unix-client"             "UNIX-STREAM-CLIENT"
"unix-client"             "UNIX-CLIENT-SOCKET"
"unix-server"             "UNIX-STREAM-SERVER"
"unix-server"             "UNIX-SERVER-SOCKET"
"w"                       "BINARY-OUT"
"w"                       "CODED-OUT"
"w"                       "OUTPUT"
"w"                       "PRINT"
"w"                       "TEXT-OUT"
"w"                       "WB"
"w+"                      "W+B"
"w+"                      "WB+"


File: setl-lib.info,  Node: or,  Next: peekc,  Prev: open,  Up: The Library

‘or’  -  logical disjunction
============================

     op or (boolean, boolean) : boolean

The expression

     x or y

is equivalent to the expression

     if x then true else y end

which is to say that the ‘or’ operator is “short-circuited” like ‘and’
and the “query” operator (‘?’), making it similarly suitable for use as
a guard.

Contrast the bitwise operators such as ‘bit_or’.

The ‘or’ operator has a very low precedence, above ‘impl’ but below
‘and’.  *Note Operator Precedence::.


File: setl-lib.info,  Node: peekc,  Next: peekchar,  Prev: or,  Up: The Library

‘peekc’  -  peek at next character in stream
============================================

     op peekc (stream F) : string

The next available character, if any, in the stream F is returned as a
string of length 1, as if by ‘getc’.  However, the character also
remains in the input as if it were “pushed back” by ‘ungetc’.  In all
other respects, including auto-opening, the flushing of any output
associations F may have, the setting of ‘eof’ and ‘last_error’, and
auto-closing, ‘peekc’ behaves like ‘getc’.

See also ‘peekchar’, ‘ungetc’, and ‘ungetchar’.


File: setl-lib.info,  Node: peekchar,  Next: peer_address,  Prev: peekc,  Up: The Library

‘peekchar’  -  peek at next character in ‘stdin’
================================================

     proc peekchar : string

Equivalent to ‘peekc (stdin)’.


File: setl-lib.info,  Node: peer_address,  Next: peer_name,  Prev: peekchar,  Up: The Library

‘peer_address’  -  peer host address
====================================

     proc peer_address (stream F) : string

If the stream F is a connected TCP or UDP socket, ‘peer_address’ returns
the Internet address of the peer in either IPv4 dotted or IPv6
colon-delimited notation.  It is permissible for F to be a file
descriptor that is open only at the POSIX level.

Note that for a UDP client socket, there is no actual connection, just a
record made of the peer address when it was opened.

On failure of the underlying POSIX getpeername() to find a peer for F in
address family AF_INET or AF_INET6, ‘peer_address’ sets ‘last_error’ and
returns ‘om’.

See also ‘open’, ‘filename’, ‘peer_name’, ‘peer_port’, ‘peer_sockaddr’,
‘ip_addresses’, ‘ip_names’, and ‘hostaddr’.


File: setl-lib.info,  Node: peer_name,  Next: peer_port,  Prev: peer_address,  Up: The Library

‘peer_name’  -  peer host name
==============================

     proc peer_name (stream F) : string

If the stream F is a connected TCP or UDP socket, ‘peer_name’ returns an
Internet host name for the peer.  It is permissible for F to be a file
descriptor that is open only at the POSIX level.

If the underlying POSIX getpeername() fails to find a peer address for F
in address family AF_INET or AF_INET6, or if a corresponding name cannot
be found by POSIX getnameinfo(), ‘peer_name’ sets ‘last_error’ and
returns ‘om’.

See also ‘open’, ‘filename’, ‘peer_address’, ‘peer_port’,
‘peer_sockaddr’, ‘ip_names’, and ‘hostname’.


File: setl-lib.info,  Node: peer_port,  Next: peer_sockaddr,  Prev: peer_name,  Up: The Library

‘peer_port’  -  peer port number
================================

     proc peer_port (stream F) : integer

If the stream F is a connected TCP or UDP socket, ‘peer_port’ returns
the port number of the peer.  It is permissible for F to be a file
descriptor that is open only at the POSIX level.

On failure of the underlying POSIX getpeername() to find a peer for F in
address family AF_INET or AF_INET6, ‘peer_port’ sets ‘last_error’ and
returns ‘om’.

See also ‘open’, ‘filename’, ‘port’, ‘peer_address’, ‘peer_name’, and
‘peer_sockaddr’.


File: setl-lib.info,  Node: peer_sockaddr,  Next: pexists,  Prev: peer_port,  Up: The Library

‘peer_sockaddr’  -  peer address and port number
================================================

     proc peer_sockaddr (stream F) : [string, integer]

If the stream F is a connected TCP or UDP socket, ‘peer_sockaddr’
returns a 2-tuple ‘[peer_address F’, ‘peer_port F’].  It is permissible
for F to be a file descriptor that is open only at the POSIX level.

On failure of the underlying POSIX getpeername() to find a peer for F in
address family AF_INET or AF_INET6, ‘peer_sockaddr’ sets ‘last_error’
and returns ‘om’.

See also ‘accept’, ‘open’, ‘filename’, ‘sockaddr’, ‘peer_name’,
‘ip_addresses’, and ‘ip_names’.


File: setl-lib.info,  Node: pexists,  Next: pid,  Prev: peer_sockaddr,  Up: The Library

‘pexists’  -  test for existence of processes
=============================================

     op pexists (integer P) : boolean

Tests whether the process or set of processes identified by pid P
exists, according to the same rules as for the P argument to ‘kill’.
Unlike ‘kill’, however, ‘pexists’ does not set ‘last_error’.

If P exists, ‘pexists P’ may return ‘true’ even if the caller has no
permission to send a signal to P.  Permission can be checked by calling
‘kill’ with a signal number of 0 and then examining ‘last_error’.

Both of those operations give but a transient snapshot of system state.

See also ‘pid’ and ‘getpid’.

The precedence of ‘pexists’ is quite low, like that of other unary
predicates (*note Operator Precedence::).


File: setl-lib.info,  Node: pid,  Next: pipe,  Prev: pexists,  Up: The Library

‘pid’  -  process ID of connected child
=======================================

     proc pid (stream) : integer

If the argument is a pipe, pump, or tty-pump stream connected to a child
process, ‘pid’ returns the child’s POSIX process ID.  No other stream
types are allowed.

If the stream is of an acceptable type but came from an ‘open’ call over
a fd rather than from a child-creating call, -1 is returned.

See also ‘getpid’, ‘getppid’, ‘getpgrp’, ‘pipe_from_child’,
‘pipe_to_child’, ‘pump’, ‘tty_pump’, ‘pexists’, ‘kill’, and the ‘open’
modes "pipe-from", "pipe-to", "pump", and "tty-pump".


File: setl-lib.info,  Node: pipe,  Next: pipe_from_child,  Prev: pid,  Up: The Library

‘pipe’  -  create primitive pipe
================================

     proc pipe : [integer, integer]

This is a synonym for ‘socketpair’, except that the first fd of the
returned pair may only be open for reading, and the second only for
writing, as in POSIX pipe().


File: setl-lib.info,  Node: pipe_from_child,  Next: pipe_to_child,  Prev: pipe,  Up: The Library

‘pipe_from_child’  -  pipe from child process
=============================================

     proc pipe_from_child : integer

The ‘pipe_from_child’ intrinsic is a unidirectional form of ‘pump’.

It creates a child process, and returns to the calling process a
readable stream connected to the standard output of that child.  In the
child process, ‘pipe_from_child’ returns -1.

See also ‘close’, ‘filter’, ‘system’, ‘pid’, ‘pipe_to_child’, and the
‘open’ mode "pipe-from".


File: setl-lib.info,  Node: pipe_to_child,  Next: port,  Prev: pipe_from_child,  Up: The Library

‘pipe_to_child’  -  pipe to child process
=========================================

     proc pipe_to_child : integer

The ‘pipe_to_child’ intrinsic is a unidirectional form of ‘pump’.

It creates a child process, and returns to the calling process a
writable stream connected to the standard input of that child.  In the
child process, ‘pipe_to_child’ returns -1.

See also ‘close’, ‘filter’, ‘system’, ‘pid’, ‘pipe_from_child’ and the
‘open’ mode "pipe-to".


File: setl-lib.info,  Node: port,  Next: pow,  Prev: pipe_to_child,  Up: The Library

‘port’  -  Internet port number
===============================

     op port (stream F) : integer

Local (“this side”) port number of the TCP or UDP stream F.  It is
permissible for F to be a file descriptor that is open only at the POSIX
level.

On failure of the underlying POSIX getsockname() to find an address for
F in family AF_INET or AF_INET6, ‘port’ sets ‘last_error’ and returns
‘om’.

See also ‘open’, ‘filename’, ‘sockaddr’, ‘peer_port’, and
‘peer_sockaddr’.


File: setl-lib.info,  Node: pow,  Next: pretty,  Prev: port,  Up: The Library

‘pow’  -  power set
===================

     op pow (set S) : set

Returns the set of all ‘2 ** #S’ subsets of S, including the empty set
‘{}’ and S itself.

See also ‘npow’.


File: setl-lib.info,  Node: pretty,  Next: print,  Prev: pow,  Up: The Library

‘pretty’  -  printable ASCII rendering of string
================================================

     op pretty (var) : string

If the operand is not already a ‘string’, the ‘pretty’ operator first
converts it to one as if by ‘str’.  It then returns a copy of that
string in which the 95 characters that ASCII considers “printable” are
left unchanged, except for the apostrophe (single quote, ‘'’), which
becomes two apostrophes in a row, and the backslash (‘\’), which becomes
two backslashes in a row.  An apostrophe is also added at each end.
Among the non-printable characters, the audible alarm, backspace,
formfeed, newline, return, horizontal tab, and vertical tab are
converted to ‘\a’, ‘\b’, ‘\f’, ‘\n’, ‘\r’, ‘\t’, and ‘\v’ respectively
(these are the same as the C conventions), and all remaining characters
are converted to ‘\OOO’ form (backslash followd by 3 octal digits).  For
example,

     print (pretty +/[char i : i in [0..255]]);

exhibits this printable encoding for all the characters in ASCII.  It
really is not all that pretty, but at least it won’t do horrid things to
your terminal.

See also ‘unpretty’ and ‘unstr’.


File: setl-lib.info,  Node: print,  Next: printa,  Prev: pretty,  Up: The Library

‘print’  -  print to ‘stdout’
=============================

     proc print (var ARGS(*))

Equivalent to ‘printa (stdout, ARGS(*))’.

See also ‘nprint’ and ‘write’.


File: setl-lib.info,  Node: printa,  Next: pump,  Prev: print,  Up: The Library

‘printa’  -  print to stream
============================

     proc printa (stream F, var ARGS(*))

The 0 or more ARGS are written in sequence to the stream F, separated by
single spaces.  String arguments are written directly; all others are
converted as if by ‘str’ first.  A newline character (‘\n’) then
follows.

If F is not already open, an attempt is made to auto-open it.  *Note
Automatic opening::.

On output error, output may be incomplete and ‘last_error’ may be set.

See also ‘print’ and ‘nprinta’ (which omits the trailing newline), and
‘writea’.


File: setl-lib.info,  Node: pump,  Next: put,  Prev: printa,  Up: The Library

‘pump’  -  bidirectional stream to child process
================================================

     proc pump : integer

The ‘pump’ intrinsic creates a child process as if by ‘fork’, and
returns in the parent a bidirectional stream that is connected to the
child’s standard input and output.

In the child process, ‘pump’ returns -1, an unfortunate convention
motivated by wanting an integer outside the range of all possible file
descriptors.

Failure to create the child or the bidirectional stream, generally
indicating resource exhaustion, is considered erroneous.  (You need to
call ‘fork’ directly in order to detect and recover from spawning
failure.)

The child in this kind of arrangement is sometimes called a “coprocess”.
*Note Connected subprocesses: Pipes and pumps.

The call ‘tie (stdin, stdout)’ can be useful in the child in the case of
a straightforward message-and-response application-level protocol over
the stream.  *Note Buffering::.

The bidirectional channel between parent and child is opened over
Unix-domain sockets created as if by ‘socketpair’, and therefore
supports the passing of file descriptors using ‘send_fd’ and ‘recv_fd’.

See also ‘open’ (particularly the "pump", "tty-pump", "pipe-from", and
"pipe-to" modes), ‘tty_pump’, ‘pipe_from_child’, ‘pipe_to_child’, ‘pid’,
‘filter’, ‘system’, ‘flush’, ‘close’, and ‘shutdown’.


File: setl-lib.info,  Node: put,  Next: puta,  Prev: pump,  Up: The Library

‘put’  -  write lines to ‘stdout’
=================================

     proc put (string ARGS(*))

Equivalent to ‘puta (stdout, ARGS(*))’.

This signature for ‘put’ follows that of SETL2, while ‘puta’ is
patterned after the old CIMS SETL put.  This makes the signatures of
‘put’ and ‘puta’ consistent with those of ‘print’ and ‘printa’.


File: setl-lib.info,  Node: puta,  Next: putb,  Prev: put,  Up: The Library

‘puta’  -  write lines to stream
================================

     proc puta (stream F, string ARGS(*))

The 0 or more ARGS are written in sequence to the stream F, with a
newline character (‘\n’) after each string.

If F is not already open, an attempt is made to auto-open it.  *Note
Automatic opening::.

On output error, output may be incomplete and ‘last_error’ may be set.

A synonym for ‘puta’ is ‘putline’.

See also ‘printa’.


File: setl-lib.info,  Node: putb,  Next: putc,  Prev: puta,  Up: The Library

‘putb’  -  write values to stream
=================================

     proc putb (stream F, var ARGS(*))

The 0 or more ARGS are written in sequence to the stream F, separated by
single spaces and followed by a newline character (‘\n’).  All of them
are converted as if by ‘str’ first, with no exception for strings
(contrast ‘printa’).

Values written by ‘putb’, except for atoms (see ‘newat’) and procedure
references (see ‘routine’), can be read by ‘getb’.

If F is not already open, an attempt is made to auto-open it.  *Note
Automatic opening::.

On output error, output may be incomplete and ‘last_error’ may be set.

A synonym for ‘putb’ is ‘writea’.

See also ‘puta’.


File: setl-lib.info,  Node: putc,  Next: putchar,  Prev: putb,  Up: The Library

‘putc’  -  write characters to stream
=====================================

     proc putc (stream F, string S)

The 0 or more characters in S are written to the stream F.

If F is not already open, an attempt is made to auto-open it.  *Note
Automatic opening::.

On output error, output may be incomplete and ‘last_error’ may be set.

See also ‘putfile’.


File: setl-lib.info,  Node: putchar,  Next: putfile,  Prev: putc,  Up: The Library

‘putchar’  -  write characters to ‘stdout’
==========================================

     proc putchar (string S)

The call ‘putchar (S)’ is the same as ‘putc (stdout, S)’.


File: setl-lib.info,  Node: putfile,  Next: putline,  Prev: putchar,  Up: The Library

‘putfile’  -  write characters to stream
========================================

     proc putfile (stream F, string S)

The 0 or more characters in S are written to the stream F.

If F is not already open, an attempt is made to auto-open it.  *Note
Automatic opening::.

The ‘putfile’ intrinsic is almost equivalent to ‘putc’, except that if
‘putfile’ auto-opens F, it also makes sure all output has been written
as if by ‘flush’ and then auto-closes F.

It is the only output intrinsic that auto-closes, making it a convenient
one-stop way of writing a string to a file or network destination, e.g.:

     putfile ('timestamp', date);  -- put date into timestamp file

On error, output may be incomplete and ‘last_error’ may be set by POSIX
write() and/or POSIX close().

See also ‘getfile’.


File: setl-lib.info,  Node: putline,  Next: puts,  Prev: putfile,  Up: The Library

‘putline’  -  write lines to stream
===================================

     proc putline (stream F, string ARGS(*))

The 0 or more ARGS are written in sequence to the stream F, with a
newline character (‘\n’) after each string.

If F is not already open, an attempt is made to auto-open it.  *Note
Automatic opening::.

On output error, output may be incomplete and ‘last_error’ may be set.

A synonym for ‘putline’ is ‘puta’.

See also ‘printa’.


File: setl-lib.info,  Node: puts,  Next: random,  Prev: putline,  Up: The Library

‘puts’  -  direct-access write
==============================

     proc puts (stream F, integer START, string X)

The file under the direct-access (seekable) stream F (‘open’ mode "w",
"n", "r+", "w+", "n+", or "a+") is treated as a string, where START
specifies the index (1 or higher) of the first character to write.  In
"a+" mode, START is ignored, and the writing will be at the end of the
file.

The ‘puts’ intrinsic writes N characters, increasing the size of the
file as necessary.  Writing to a position beyond the current end of the
file is allowed, and the gap is filled with NUL characters (‘\0’),
possibly in a way that is optimized by the underlying file system.
Again, this does not apply to "a+" mode, where START is ignored.

If F is not already open, an attempt is made to auto-open it in "r+"
mode, which allows seeking, reading, and writing.  *Note Automatic
opening::.

As with ‘seek’, F is flushed of output (ignoring errors), and drained of
input, before the repositioning of the file.  *Note Buffering::.

On output error, output may be incomplete and ‘last_error’ may be set.

See also ‘gets’, ‘putc’, ‘putfile’, and ‘mkstemp’.


File: setl-lib.info,  Node: random,  Next: range,  Prev: puts,  Up: The Library

‘random’  -  pseudo-random numbers and selections
=================================================

     op random (integer I) : integer
     op random (real R) : real
     op random (string S) : string
     op random (set T) : var
     op random (tuple T) : var

For an integer ‘I >= 0’, ‘random I’ returns a uniformly distributed
pseudo-random integer in the range ‘0’ through I.  For ‘I <= 0’, the
return value is in the range I through ‘0’.

The closed interval range in the integer case is a regrettable SETL
idiosyncrasy: ‘random I’ can return any one of ‘I+1’ values, including I
itself.  It is perhaps best buried in a wrapper with a more conventional
convention:

     -- Uniformly chosen random number in [0..i-1]
     op my_random (i);
       return random (i-1);
     end op;

For a positive real (floating-point) R, ‘random R’ returns a real in the
half-open interval [0,R), and for negative R, in (R,0].  Paradoxically,
‘random 0.0’ is ‘0.0’.

For a string S, ‘random S’ returns a pseudo-randomly chosen character
from S, or ‘om’ if S is the empty string ("").

For a set or tuple T, ‘random T’ returns a pseudo-randomly chosen
element from T, or ‘om’ if ‘#T = 0’.

There is a theoretical possibility that ‘random’ applied to real R sets
‘last_error’ to something like "Numerical result out of range", but most
extremely small values of R will map to ‘0.0’ or ‘-0.0’ depending on R’s
sign, and most extremely large values to positive or negative
floating-point infinity, without setting ‘last_error’.  In a 64-bit IEEE
754 implementation, a magnitude of R between ‘1e-288’ and ‘1e+288’ will
keep clear of these extremes.

See also ‘setrandom’, which sets the “random seed”.


File: setl-lib.info,  Node: range,  Next: rany,  Prev: random,  Up: The Library

‘range’  -  range of map
========================

     op range (set) : set

The operand must be a set of ordered pairs, that is, a set of 2-tuples
in which no element is ‘om’.  The result is the set of all second
members of those pairs.

See also ‘domain’.


File: setl-lib.info,  Node: rany,  Next: rbreak,  Prev: range,  Up: The Library

‘rany’  -  extract trailing character using character set
=========================================================

     proc rany (rw string S, string P) : string

If the last character of S occurs anywhere in P (treating P as a set of
characters), that last character is removed from S and returned.
Otherwise, nothing happens to S, and the empty string ("") is returned.

See also the other SNOBOL-inspired intrinsics, namely ‘any’, ‘break’,
‘len’, ‘match’, ‘notany’, ‘span’, ‘rbreak’, ‘rlen’, ‘rmatch’, ‘rnotany’,
and ‘rspan’.


File: setl-lib.info,  Node: rbreak,  Next: rlen,  Prev: rany,  Up: The Library

‘rbreak’  -  extract trailing substring using character set
===========================================================

     proc rbreak (rw string S, string P) : string

Starting from the right, if S contains a character that appears in P
(treating P as a set of characters), the substring of S after that
character is removed from the tail of S and returned.  If no character
from P appears in S, the return value is the initial value of S, and S
is reduced to the empty string ("").

See also the other SNOBOL-inspired intrinsics, namely ‘any’, ‘break’,
‘len’, ‘match’, ‘notany’, ‘span’, ‘rany’, ‘rlen’, ‘rmatch’, ‘rnotany’,
and ‘rspan’.


File: setl-lib.info,  Node: rlen,  Next: rmatch,  Prev: rbreak,  Up: The Library

‘rlen’  -  extract trailing substring by length
===============================================

     proc rlen (rw string S, integer N) : string

A substring of length ‘N min #S’ is removed from the tail of S and
returned.  It is an error for N to be less than 0.

See also the other SNOBOL-inspired intrinsics, namely ‘any’, ‘break’,
‘len’, ‘match’, ‘notany’, ‘span’, ‘rany’, ‘rbreak’, ‘rmatch’, ‘rnotany’,
and ‘rspan’.


File: setl-lib.info,  Node: rmatch,  Next: rnotany,  Prev: rlen,  Up: The Library

‘rmatch’  -  extract trailing substring by exact match
======================================================

     proc rmatch (rw string S, string P) : string

If P is equal to the rightmost substring of S, it is removed from S and
returned.  Otherwise, nothing happens to S and the empty string ("") is
returned.

See also the other SNOBOL-inspired intrinsics, namely ‘any’, ‘break’,
‘len’, ‘match’, ‘notany’, ‘span’, ‘rany’, ‘rbreak’, ‘rlen’, ‘rnotany’,
and ‘rspan’.


File: setl-lib.info,  Node: rnotany,  Next: rspan,  Prev: rmatch,  Up: The Library

‘rnotany’  -  extract trailing character using character set
============================================================

     proc rnotany (rw string S, string P) : string

If the last character of S does not occur in P (treating P as a set of
characters), that last character is removed from S and returned.
Otherwise, nothing happens to S, and the empty string ("") is returned.

See also the other SNOBOL-inspired intrinsics, namely ‘any’, ‘break’,
‘len’, ‘match’, ‘notany’, ‘span’, ‘rany’, ‘rbreak’, ‘rlen’, ‘rmatch’,
and ‘rspan’.


File: setl-lib.info,  Node: rspan,  Next: read,  Prev: rnotany,  Up: The Library

‘rspan’  -  extract trailing substring using character set
==========================================================

     proc rspan (rw string S, string P) : string

The longest trailing substring of S consisting of characters that are in
P (treating P as a set of characters) is removed from S and returned.
If there is no such substring, nothing happens to S, and the empty
string ("") is returned.

See also the other SNOBOL-inspired intrinsics, namely ‘any’, ‘break’,
‘len’, ‘match’, ‘notany’, ‘span’, ‘rany’, ‘rbreak’, ‘rlen’, ‘rmatch’,
and ‘rnotany’.


File: setl-lib.info,  Node: read,  Next: reada,  Prev: rspan,  Up: The Library

‘read’  -  read values from one or more lines of ‘stdin’
========================================================

     proc read (wr var ARGS(*))

Equivalent to ‘reada (stdin, ARGS(*))’.


File: setl-lib.info,  Node: reada,  Next: readlink,  Prev: read,  Up: The Library

‘reada’  -  read values from one or more lines of stream
========================================================

     proc reada (stream F, wr var ARGS(*))

Zero or more values are read from the stream F and assigned to the
succeeding ARGS in order.  If an end of input (end of file or error) is
reached before all those arguments have been assigned to, trailing
arguments are set to ‘om’.  Otherwise, characters through the next
newline (‘\n’)) if any are read and discarded.  If the end of input is
reached before any arguments have been assigned to, the ‘eof’ indicators
are set.

If F is not already open, an attempt is made to auto-open it.  *Note
Automatic opening::.

Values written by ‘writea’, except for atoms (see ‘newat’) and procedure
references (see ‘routine’), are readable by ‘reada’.  Tokens denoting
values are separated by whitespace (ERE "[ \f\n\r\t\v]+") and converted
as if by ‘unstr’.  Since newline is a whitespace character, input values
may be distributed over more than one line.

There is a difference between ‘reada’ and ‘getb’ in that after reading
the requested number of values, ‘reada’ continues reading characters
until it either absorbs a newline (‘\n’) or encounters an end of input,
whereas ‘getb’ stops right after the end of the last value read.  Thus
‘reada (F)’ is a way of reading a line from F but ignoring its content.

The rules on auto-flushing F’s output associations, on setting
‘last_error’, and on auto-closing are as for ‘getc’.

See also ‘read’, ‘reads’, ‘geta’, ‘getline’, ‘getfile’, ‘getn’,
‘printa’, ‘val’, and ‘unpretty’.


File: setl-lib.info,  Node: readlink,  Next: reads,  Prev: reada,  Up: The Library

‘readlink’  -  symbolic link referent
=====================================

     op readlink (string F) : string

When F names a file that is a symbolic link (“symlink”), ‘readlink’
returns the string associated with F, i.e., the symlink.  The string may
or may not name another existing file.

Contrast this with a regular input operation on F, which will fail if F
is a symlink to a file that doesn’t exist.

If F is not a symlink, ‘readlink’ returns ‘om’ and sets ‘last_error’
according to the rules for POSIX readlink().

See also ‘lexists’, ‘fexists’, ‘symlink’, ‘link’, and ‘unlink’.


File: setl-lib.info,  Node: reads,  Next: recv,  Prev: readlink,  Up: The Library

‘reads’  -  read values from a string
=====================================

     proc reads (stream S, wr var ARGS(*))

Zero or more values are “read” from the string S and assigned to the
succeeding ARGS in order.  If the end of the string is reached before
all those arguments have been assigned to, trailing arguments get ‘om’.
The rules for value recognition and conversion are the same as for
‘reada’ and ‘unstr’.

See also ‘val’.


File: setl-lib.info,  Node: recv,  Next: recvfrom,  Prev: reads,  Up: The Library

‘recv’  -  receive datagram on UDP client socket
================================================

     op recv (stream F) : string

A datagram is read from the socket F and returned as a string.  The
stream F must be of ‘open’ mode "udp-client"—‘recv’ is not supported for
"unix-datagram-client" streams, which can only ‘send’.

The ‘select’ function can be used to wait or check for input of this
kind.

If the underlying POSIX recv() fails, ‘recv’ sets ‘last_error’ and
returns ‘om’.

The ‘eof’ indicators are not set by ‘recv’, not even when an empty
datagram ("") is received.

If F is not already open at the SETL level, an attempt is made to
auto-open it in "udp-client" mode.  *Note Automatic opening::.

See also ‘recvfrom’, ‘sendto’, and ‘sockaddr’.


File: setl-lib.info,  Node: recvfrom,  Next: recv_fd,  Prev: recv,  Up: The Library

‘recvfrom’  -  receive datagram on server socket
================================================

     op recvfrom (stream F) : [[string, integer], string]
     op recvfrom (stream F) : [string, string]

A datagram is read from the socket F, and information about its source
is returned along with it.

If F is of ‘open’ mode "udp-server", the sender’s Internet address and
port number are sensed, and bundled together with the datagram as the
return value ‘[[ADDRESS, PORTNUM], DATAGRAM]’, where ADDRESS is a string
in IPv4 or IPv6 notation, PORTNUM is an integer, and DATAGRAM is a
string.

If F is of mode "unix-datagram-server", the return value is ‘[PATHNAME,
DATAGRAM]’, where PATHNAME is the socket name of the sender if it has
one, otherwise the empty string ("").  (Unix-domain clients, mode
"unix-datagram-client", do not bind names, so the PATHNAME is only
useful when receiving from other Unix-domain servers.)

The ‘select’ function can be used to check or wait for input of this
kind.

If the underlying POSIX recvfrom() fails, ‘recvfrom’ sets ‘last_error’
and returns ‘om’.

The ‘eof’ indicators are not set by ‘recvfrom’, not even when an empty
datagram ("") is received.

If F is not already open at the SETL level, an attempt is made to
auto-open it in "udp-server" mode.  *Note Automatic opening::.

See also ‘sendto’, ‘recv’, ‘send’, and ‘sockaddr’.


File: setl-lib.info,  Node: recv_fd,  Next: rem,  Prev: recvfrom,  Up: The Library

‘recv_fd’  -  receive file descriptor
=====================================

     op recv_fd (stream F) : integer

A file descriptor (fd) sent by a process executing a ‘send_fd’ is
returned and left open at the system level.  It is not immediately
opened at the SETL level, but can be opened as a stream by ‘open’ like
any other fd, or auto-opened (*note Automatic opening::).

The stream F should be a Unix-domain socket, such as is created by
‘pipe_from_child’, ‘pipe_to_child’, or ‘pump’; or by ‘open’ mode
"pipe-from", "pipe-to", "pump", "unix-client", or "unix-server".  Or by
‘socketpair’, as F is itself allowed to be a fd not open at the SETL
level.

The ‘select’ function can be used to test or wait for the presence of a
fd ready to be received on F.

The integer value of the returned fd is chosen by ‘recv_fd’ as the next
available integer, in the manner of ‘dup’, and refers to the same
POSIX-level “open file description” object as the fd that the other
process passed to ‘send_fd’ does, even though it is numerically
independent.

If ‘recv_fd’ fails to receive a fd, it sets the ‘eof’ indicators and
returns ‘om’.  An error in the underlying POSIX recvmsg() call is
reflected in ‘last_error’.

No attempt to auto-open F is made by ‘recv_fd’, but it does follow the
‘getc’ rules on initial flushing of output associations and on
auto-close upon ‘eof’.


File: setl-lib.info,  Node: rem,  Next: rename,  Prev: recv_fd,  Up: The Library

‘rem’  -  integer remainder
===========================

     op rem (integer N, integer D) : integer

For non-zero D,

     N rem D = N - ((N div D) * D)

so, for example:

      5 rem  3 =  2
     -5 rem  3 = -2
      5 rem -3 =  2
     -5 rem -3 = -2

In contrast with ‘mod’, the sign of the result follows that of the
numerator, and its magnitude depends only on the magnitudes of the
operands (not on their signs).  Rearrangement of terms in the above
definition of ‘rem’ allows N to be rather directly reconstructed from
its ‘div’ and ‘rem’ given the divisor D.


File: setl-lib.info,  Node: rename,  Next: reverse,  Prev: rem,  Up: The Library

‘rename’  -  rename file
========================

     proc rename (string OLD, string NEW)

Changes the name of a file if possible.  On failure of the underlying
POSIX rename() call, ‘last_error’ is set.

See also ‘link’, ‘symlink’, ‘unlink’, and ‘system’.


File: setl-lib.info,  Node: reverse,  Next: rewind,  Prev: rename,  Up: The Library

‘reverse’  -  reverse string
============================

     op reverse (string) : string

Characters in reverse order.


File: setl-lib.info,  Node: rewind,  Next: round,  Prev: reverse,  Up: The Library

‘rewind’  -  rewind direct-access stream
========================================

     proc rewind (stream F)

Equivalent to ‘seek (F, 0)’.


File: setl-lib.info,  Node: round,  Next: routine,  Prev: rewind,  Up: The Library

‘round’  -  round to nearest integer
====================================

     op round (real) : integer
     op round (integer) : integer

Numbers ending in .5 are rounded away from zero.  All others are rounded
to the nearest integer.

For example, ‘round -5.5 = -6’, and ‘round -5.4 = -5’.

Floating-point infinities and NaN (“Not a Number”) values give ‘om’.

See also ‘floor’, ‘ceil’, ‘fix’, and ‘float’.


File: setl-lib.info,  Node: routine,  Next: rpad,  Prev: round,  Up: The Library

‘routine’  -  create procedure reference
========================================

     op routine (proc_name) : proc_ref

This pseudo-operator produces a value that can subsequently be passed to
‘call’ in order to perform an indirect procedure call.  The typenames in
the signature shown here do not really exist as SETL keywords, but
suggest how this operator is used: you pass it the name of a procedure
in your program, and it returns a handle which you can later pass to
‘call’.

For example, it is sometimes convenient to use a mapping to associate
strings with procedure references, as illustrated by the “callback”
style of programming in the example at ‘select’.


File: setl-lib.info,  Node: rpad,  Next: seek,  Prev: routine,  Up: The Library

‘rpad’  -  pad string on right with blanks
==========================================

     proc rpad (string S, integer N) : string

If ‘N > #S’, the returned string is S padded on the right with blanks to
length N.  Otherwise, S is returned.

It is an error for N to be less than 0.

See also ‘lpad’, which “right-justifies” by padding on the left.


File: setl-lib.info,  Node: seek,  Next: seek constants,  Prev: rpad,  Up: The Library

‘seek’  -  reposition direct-access stream
==========================================

     proc seek (stream F, integer OFFSET) : integer
     proc seek (stream F, integer OFFSET, integer WHENCE) : integer

The file under the direct-access (seekable) stream F (‘open’ mode "r",
"w", "n", "r+", "w+", "n+", or "a+") is repositioned so that the next
sequential read or write operation will start at OFFSET bytes relative
to the point indicated by WHENCE (except that for "a+", writes are
always at the end of the file).  The possibilities for WHENCE are

   • ‘seek_set’ (the default), meaning an absolute offset from the
     beginning of the file;

   • ‘seek_cur’, meaning relative to the current read/write position;

   • ‘seek_end’, meaning from the end of the file.

The OFFSET convention has the beginning of the file at position 0,
consistent with the conventions of POSIX lseek().  (By contrast, the
START argument of ‘gets’ and ‘puts’ follows the convention of SETL
strings, where the first character has index 1.)

If F is not already open, an attempt is made to auto-open it in "r+"
mode, which allows seeking, reading, and writing.  *Note Automatic
opening::.

The return value is the new read/write position (offset from beginning
of file).

Note that ‘seek’ does _not_ affect ‘eof’.  Seeking beyond the end of the
file and writing is allowed, as it is for ‘puts’, and the gap is filled
with NUL characters (‘\0’), possibly in a way that is optimized by the
underlying file system.

The stream F is flushed of output (ignoring output errors) and drained
of input, before any seeking attempt, even one that does not change the
current position.  *Note Buffering::.  Consider using ‘filepos’ if you
just want the current position without the flushing and draining.

See also ‘rewind’ and ‘mkstemp’.


File: setl-lib.info,  Node: seek constants,  Next: select,  Prev: seek,  Up: The Library

‘seek_set’, ‘seek_cur’, ‘seek_end’  -  constants for use with ‘seek’
====================================================================

     seek_set : integer
     seek_cur : integer
     seek_end : integer

See ‘seek’.


File: setl-lib.info,  Node: select,  Next: send,  Prev: seek constants,  Up: The Library

‘select’  -  wait for event or timeout
======================================

     proc select (tuple STREAM_SETS) : tuple
     proc select (tuple STREAM_SETS, integer MS) : tuple

Waits for I/O events on sets of streams, with optional timeout (0 to
poll).

Because interprocess communication, signals, interval timers, and
sockets are all wrapped as I/O streams in SETL, and SETL is resolutely
single-threaded, ‘select’ is the fundamental intrinsic for event-driven
programming in SETL.

The STREAM_SETS argument gives up to 3 sets of streams:

   • ‘STREAM_SETS(1)’ - streams that may produce input.  The meaning of
     this is actually extended to include TCP and Unix-domain server
     sockets that are ready to ‘accept’ without blocking, UDP client
     sockets that have datagrams ready for receipt by ‘recv’, UDP or
     Unix-domain server sockets ready for a ‘recvfrom’, and Unix-domain
     sockets on which ‘recv_fd’ can be called without blocking.

   • ‘STREAM_SETS(2)’ - streams that take output, including UDP and
     Unix-domain datagram sockets ready for ‘send’ or ‘sendto’
     operations, and Unix-domain sockets ready for ‘send_fd’.

   • ‘STREAM_SETS(3)’ - streams that can indicate exceptional
     conditions.  No such conditions are currently defined in SETL.

An empty STREAM_SETS tuple can be given as ‘[]’ or ‘om’.

The MS argument, if present, specifies how many milliseconds ‘select’
should wait until a stream in STREAM_SETS becomes ready.  If MS is 0,
the streams are tested without waiting.  If MS is absent, ‘select’ waits
indefinitely.

The return value from ‘select’ is a 3-tuple of stream sets having input,
output, and exceptional readiness respectively.  In the case of a
timeout, all 3 sets will be empty.

Historically, there could be any number of streams in each of these
return sets, and some of the consequences of that rather direct
interface to the underlying POSIX select() or pselect() are discussed in
Section 5.3.8.3, “The Event Loop”, of SETL for Internet Data Processing
(https://cs.nyu.edu/media/publications/bacon_david.pdf), p. 163 ff.  In
brief, an unprocessed stream in a ready set can be closed during the
processing of an event associated with another stream, and then reopened
in another way before being processed on that burst of events as if it
were the original stream.  POSIX promotes fd reuse by picking the lowest
unused number, making such aliasing quite possible unless the
application takes special care to prevent it.

To remove that subtle and unnecessary hazard, ‘select’ now returns at
most one stream.  So at least 2 of the 3 ready sets will be empty, and
the other at most a singleton.  Implementations are encouraged to cache
results from an underlying POSIX pselect() call, doling a stream out
from the cache in preference to calling pselect(), and removing a stream
from the cache when it is closed.  But an implementation could instead
skip that optimization and simply pick one stream from what pselect()
gives, ignoring the rest in the faith that they will still be there on
the next pselect() call if they should be.

Streams in the input and output sets in the STREAM_SETS argument to
‘select’ are subject to auto-opening (*note Automatic opening::).

Also, appearance in the input set causes auto-flushing of a stream’s
output associations in the manner of ‘getc’.

Since a STREAM_SETS argument of ‘om’ means no streams, the statement

     select (om, MS);

is pretty much a standard way to delay program execution for
MS milliseconds, and

     select (om);

suspends the program until it is killed by external forces.

Mostly, ‘select’ is used to check and wait for the availability of
input, not for the possibility of output.  Even when ‘select’ tells you
a stream is ready to take output, you do not in general know how much.
Moreover, it’s the pipe that is ready, not necessarily the receiver.
Such notifications could conceivably be of use in some high-performance
multiplexing application, but if output blockage is a concern in any
given instance, it is usually best to interpose a child process that can
afford to block on its own output, and notifies the parent when it is
ready for more.  The parent-child communication goes at local speed.

For a SETL stream, which is buffered, “ready for output” means that a
POSIX write() of some number of bytes will not block.  It does not
merely mean that there is room in the SETL buffer, which is always true,
but rather that the stream is “flushable” without blocking (unless the
buffer is too full for what the pipe can currently accommodate).  It
also means that ‘sys_write’ can be called on the stream without
blocking, provided the request is not too big.  It is seldom necessary
to test for output readiness.  For datagram sockets, it is never even
useful.

Using ‘routine’, a “callback” scheme for input events can be realized
with ‘select’:

   • Global map from stream handle to unary callback routine:
          var CALLBACKS := {};

   • Register callback procedure CB to be called when stream F has input
     available:
          CALLBACKS(F) := routine CB;

   • Unregister stream F:
          CALLBACKS(F) := om;

   • Input event dispatcher loop:
          loop  -- indefinitely
            [READY] := select ([domain CALLBACKS]);
            for F in READY loop  -- at most 1 iteration nowadays
              call (CALLBACKS(F), F);  -- F is map key and callback arg
            end loop;
          end loop;

   • A callback CB for input available on stream F:
          proc CB (F);
            reada (F, CMD);  -- read a request from F
            -- act on it ...
          end CB;


File: setl-lib.info,  Node: send,  Next: sendto,  Prev: select,  Up: The Library

‘send’  -  send datagram on client socket
=========================================

     proc send (stream F, string DATAGRAM)

The string DATAGRAM is sent via the client socket F (‘open’ mode
"udp-client" or "unix-datagram-client").  Datagram output is not
buffered (*note Buffering::).

Failure of the underlying POSIX send() is reflected in ‘last_error’.

If F is not already open at the SETL level, an attempt is made to
auto-open it in "udp-client" mode.  *Note Automatic opening::.

See also ‘sendto’, ‘recv’, ‘recvfrom’, and ‘sockaddr’.


File: setl-lib.info,  Node: sendto,  Next: send_fd,  Prev: send,  Up: The Library

‘sendto’  -  send datagram on server socket
===========================================

     proc sendto (stream F, tuple DEST, string DATAGRAM)
     proc sendto (stream F, string PATHNAME, string DATAGRAM)

The DATAGRAM is sent via the server socket F to the destination DEST or
PATHNAME.

If F is of ‘open’ mode "udp-server", DEST must be a 2-tuple
‘[HOST, PORT]’, where HOST is a string containing an Internet host name
or an address in IPv4 or IPv6 notation, and PORT is an ‘integer’ client
port number or ‘string’ port name.

If HOST is ‘om’ or the empty string (""), it is taken to mean a loopback
interface such as "127.0.0.1" or "::1".

If POSIX getaddrinfo() fails on the given DEST, or all POSIX sendto()
attempts on the Internet address(es) found for it fail, ‘last_error’ is
set according to the last of those failures.

If F is of ‘open’ mode "unix-datagram-server", PATHNAME is the
Unix-domain socket of another server.  Errors in POSIX sendto() are
reflected in ‘last_error’.

If F is not already open at the SETL level, an attempt is made to
auto-open it in "udp-server" mode.  *Note Automatic opening::.

See the ‘open’ mode "udp-server", and see also ‘recvfrom’, ‘send’,
‘recv’, and ‘select’.


File: setl-lib.info,  Node: send_fd,  Next: setctty,  Prev: sendto,  Up: The Library

‘send_fd’  -  send file descriptor
==================================

     proc send_fd (stream F, integer FD)

The stream F is first flushed as if by ‘flush’ (but without setting
‘last_error’), and then the file descriptor FD (which may or may not be
open at the SETL level) is sent via F to a process that is expected to
call ‘recv_fd’.

The stream F should be a non-datagram Unix-domain socket, such as is
created by ‘pipe_from_child’, ‘pipe_to_child’, or ‘pump’; or by ‘open’
mode "pipe-from", "pipe-to", "pump", "unix-client", or "unix-server".
Or by ‘socketpair’, as F is itself allowed to be a fd not open at the
SETL level.

The ‘select’ function can be used to check or wait for F to be ready to
take a file descriptor without blocking.  This will never be necessary
in practice, though the POSIX sendmsg() specification makes it
theoretically possible that ‘send_fd’ could block on that call.

The more significant possibility is that ‘send_fd’ blocks while waiting
for the receiver to acknowledge receipt of the fd.  There are POSIX
platforms such as QNX where the sender cannot afford to close the fd
before the receiver is known to have received it, or the “open file
description” may have been destroyed in the meantime.  Although this
responsibility could have been left to applications to deal with, the
design decision was made to insist that the SETL implementation take
care of it.  This imposes a different and perfectly normal
responsibility on applications, namely to ensure that the blocking by
‘send_fd’ during this rendezvous, while it awaits confirmation by the
peer ‘recv_fd’, is kept brief or benign as appropriate.

If the POSIX sendmsg() underlying ‘send_fd’ fails, ‘last_error’ is set.


File: setl-lib.info,  Node: setctty,  Next: setegid,  Prev: send_fd,  Up: The Library

‘setctty’  -  acquire controlling terminal
==========================================

     proc setctty (stream F)

The terminal or pseudo-terminal connected to stream F is made (in POSIX
terms) the “controlling terminal” of the calling process if it is a
session leader (see ‘setsid’) and does not already have a controlling
terminal.  This is used in job control.

POSIX does not define a standard way of acquiring a controlling
terminal, but the BSD ioctl() TIOCSCTTY is widely supported.  For older
SystemV-based Unix systems that do not have this capability but do
support the notion of a controlling terminal, the SETL implementation is
expected to fall back to acquiring it when a session leader without one
opens a terminal device (real or virtual).  Conversely, if a mechanism
like TIOCSCTTY is supported by the host system, the SETL implementation
is expected to use that as the only way of setting the controlling
terminal (specifically, by including the O_NOCTTY flag on all POSIX tty
open() and posix_openpt() calls so that the controlling terminal isn’t
automatically assigned).

When the controlling terminal is acquired, the foreground process group
(see ‘tcgetpgrp’ and ‘tcsetpgrp’) is set to be that of the session
leader, which becomes the “controlling process” for that terminal.

Failure of ‘setctty’, such as when the calling process is not a session
leader, is reflected in ‘last_error’.  If the host system does not have
a mechanism like TIOCSCTTY (or like the tcsetsid() that appears in
FreeBSD and QNX), ‘last_error’ corresponds to a POSIX errno value of
ENOSYS.

See also ‘unsetctty’, ‘getpgrp’, ‘setpgid’, and ‘tty_pump’.


File: setl-lib.info,  Node: setegid,  Next: setenv,  Prev: setctty,  Up: The Library

‘setegid’  -  set effective group ID
====================================

     proc setegid (integer GID)

Calls POSIX setegid() on the group ID GID.

Sets ‘last_error’ on failure.

See also ‘setgid’, ‘getegid’, ‘getgid’, ‘seteuid’, ‘setuid’ (details and
example), ‘geteuid’, and ‘getuid’.


File: setl-lib.info,  Node: setenv,  Next: seteuid,  Prev: setegid,  Up: The Library

‘setenv’  -  set environment variable
=====================================

     proc setenv (string NAME, string VALUE)
     proc setenv (string NAME)

The call ‘setenv NAME, VALUE’ gives the environment variable NAME the
value VALUE.  Omitting VALUE is equivalent to passing the empty
string ("").

Note that ‘setenv’ is an interface to the POSIX setenv(), and uses some
system memory, so should be used sparingly.

See also ‘getenv’ and ‘unsetenv’.


File: setl-lib.info,  Node: seteuid,  Next: setgid,  Prev: setenv,  Up: The Library

‘seteuid’  -  set effective user ID
===================================

     proc seteuid (integer UID)

Calls POSIX seteuid() on the user ID UID.

Sets ‘last_error’ on failure.

See also ‘setuid’ (details and example), ‘geteuid’, ‘getuid’, ‘setegid’,
‘setgid’, ‘getegid’, and ‘getgid’.


File: setl-lib.info,  Node: setgid,  Next: setpgid,  Prev: seteuid,  Up: The Library

‘setgid’  -  set group ID
=========================

     proc setgid (integer GID)

Calls POSIX setgid() on the group ID GID.

Sets ‘last_error’ on failure.

See also ‘setegid’, ‘getgid’, ‘getegid’, ‘setuid’ (details and example),
‘seteuid’, ‘getuid’, and ‘geteuid’.


File: setl-lib.info,  Node: setpgid,  Next: setrandom,  Prev: setgid,  Up: The Library

‘setpgid’  -  set process group ID
==================================

     proc setpgid (integer P, integer PG)

Sets the process group ID of the process with process ID P to PG, using
POSIX setpgid().  If P and PG match, a new process group is created
within the session.  Otherwise, PG must identify an existing process
group within the session.  The pid P must be that of the caller or of a
direct child that has not yet called ‘exec’.

The process group ID of a session leader (see ‘setsid’) cannot be
changed.

If P is 0, ‘getpid’ is substituted.  If PG is 0, it is taken to be P
(after substitution).

On failure, ‘last_error’ is set.

The main intended role of this intrinsic is in job control.  When a new
process is spawned, it needs to be put into the right process group.  In
order to ensure that this happens before either the parent starts
sending signals intended for the process group or the child does an
‘exec’, both the parent and the child should call ‘setpgid’ on the
child’s pid, putting it in the desired (new or existing) process group
right after the spawning, so that it does not matter which attempt
succeeds first.

See also ‘getpgrp’, ‘setctty’, ‘unsetctty’, ‘tcgetpgrp’, and
‘tcsetpgrp’.


File: setl-lib.info,  Node: setrandom,  Next: setsid,  Prev: setpgid,  Up: The Library

‘setrandom’  -  set random seed
===============================

     proc setrandom (integer SEED)

Establishes a starting point for pseudo-random number generation.  If
SEED is ‘0’, the starting point is as unpredictable as the SETL
implementation can make it with reasonable effort, given available
sources of entropy such as /dev/urandom.

See also ‘random’.


File: setl-lib.info,  Node: setsid,  Next: setuid,  Prev: setrandom,  Up: The Library

‘setsid’  -  create new session
===============================

     proc setsid

Sessions are fundamental to job control in POSIX, as each job is a
process group, and a session is a set of process groups.

If the caller is not a process group leader, that is, its process ID is
not the process group ID of any process, ‘setsid’ establishes a new
session: the session ID and process group ID are set to the process ID
of the caller, thus making the caller the new process group leader and
the new session leader.  After a successful call to ‘setsid’, there is
no controlling terminal (but see ‘setctty’).

On failure (such as when the caller is already a process group leader),
‘last_error’ is set.

See also ‘getsid’, ‘getpgrp’, ‘setpgid’, ‘tcgetpgrp’, ‘tcsetpgrp’, and
‘unsetctty’.


File: setl-lib.info,  Node: setuid,  Next: set_intslash,  Prev: setsid,  Up: The Library

‘setuid’  -  set user ID
========================

     proc setuid (integer UID)

Calls POSIX setuid() on the user ID UID.

A “setuid executable” file in POSIX is one that has the set-user-ID mode
bit set (the POSIX command ‘chmod u+s FILE’ sets this bit,
‘chmod u-s FILE’ clears it, and ‘ls -l FILE’ displays whether it is
set).

If a user (called the “real” user) other than the owner of such a file
runs it, the “effective” user ID and “saved” user ID are initially
defined to be those of the file’s owner, rather than the real user ID.
The program runs with the privileges of the effective user, which in
particular implies that upon starting, the program can manipulate the
owner’s files.

But the program has another important privilege too, namely the ability
to switch the effective user ID back and forth between the real and the
saved ID, using ‘seteuid’.  (For a regular user, ‘setuid’ is equivalent
to ‘seteuid’, but for a “superuser”, ‘setuid’ sets all 3 IDs and is in
that respect like a one-way door.)

For example, suppose you are a DYI professor, and you want your students
to be able to submit homework programs and other files safely.
Naturally, your IT department does not trust you, so you don’t have
special privileges.  Armed with ‘setuid’, however, it is easy to set up
what you want: simply have your ‘submit’ program, when run by a student,
use the student’s privileges to fetch the student’s files, and your
privileges to store them in a private area of yours.

The situation for group IDs and “setgid executables” is exactly
analogous to that for user IDs.

If ‘setuid’ fails, ‘last_error’ is set.

See also ‘getuid’, ‘geteuid’, ‘setgid’, ‘setegid’, ‘getgid’, and
‘getegid’.


File: setl-lib.info,  Node: set_intslash,  Next: set_magic,  Prev: setuid,  Up: The Library

‘set_intslash’  -  muck with integer division semantics
=======================================================

     proc set_intslash (boolean) : boolean

A call to ‘set_intslash’ returns the current value of ‘intslash’ and
sets ‘intslash’ to the value given by the ‘boolean’ argument.


File: setl-lib.info,  Node: set_magic,  Next: shutdown,  Prev: set_intslash,  Up: The Library

‘set_magic’  -  regular expression recognition
==============================================

     proc set_magic (boolean) : boolean

A call to ‘set_magic’ returns the current value of ‘magic’ and sets it
to the value given by the ‘boolean’ argument.


File: setl-lib.info,  Node: shutdown,  Next: shutdown constants,  Prev: set_magic,  Up: The Library

‘shutdown’  -  disable I/O in one or both directions
====================================================

     proc shutdown (stream F, integer HOW)

If F is a TCP or Unix-domain socket stream, ‘shutdown’ disables the
direction(s) indicated in the HOW argument (which may be any one of the
predefined constants ‘shut_rd’, ‘shut_wr’, or ‘shut_rdwr’), using POSIX
shutdown().

If HOW is ‘shut_wr’ or ‘shut_rdwr’, the stream is first flushed as if by
‘flush’, but without reflecting output errors in ‘last_error’.

With a ‘shut_wr’ or ‘shut_rd’ argument, ‘shutdown’ performs a
“half-close”.  For example, ‘shut_wr’ can be used to tell a peer that
you have finished sending data (thus making the peer see an end-of-file
condition) but that you would still like to receive a reply on the same
(still “half-open”) connection.

Unlike ‘close’, which does nothing to the communications channel unless
the stream’s fd is the last reference to the underlying file
description, ‘shutdown’ actually closes the direction(s) of
communication that it is asked to.

It is permissible to call ‘shutdown’ on a file descriptor that is not
open at the SETL level but open at the underlying system level.

Failure of the underlying POSIX shutdown() is reflected in ‘last_error’.

See also ‘open’ and ‘pump’.


File: setl-lib.info,  Node: shutdown constants,  Next: sign,  Prev: shutdown,  Up: The Library

‘shut_rd’, ‘shut_wr’, ‘shut_rdwr’  -  constants for use with ‘shutdown’
=======================================================================

     shut_rd : integer
     shut_wr : integer
     shut_rdwr : integer

See ‘shutdown’.


File: setl-lib.info,  Node: sign,  Next: sin,  Prev: shutdown constants,  Up: The Library

‘sign’  -  sign
===============

     op sign (integer X) : integer
     op sign (real X) : integer

Returns ‘-1’, ‘0’, or ‘1’ according as ‘X < 0’, ‘X = 0’, or ‘X > 0’
respectively.


File: setl-lib.info,  Node: sin,  Next: sinh,  Prev: sign,  Up: The Library

‘sin’  -  sine
==============

     op sin (real) : real
     op sin (integer) : real

The operand is in radians.  See also ‘asin’.


File: setl-lib.info,  Node: sinh,  Next: sockaddr,  Prev: sin,  Up: The Library

‘sinh’  -  hyperbolic sine
==========================

     op sinh (real) : real
     op sinh (integer) : real

Engorged nasal passage.


File: setl-lib.info,  Node: sockaddr,  Next: socketpair,  Prev: sinh,  Up: The Library

‘sockaddr’  -  Internet address and port number
===============================================

     proc sockaddr (stream F): [string, integer]

If stream F is a TCP or UDP socket, ‘sockaddr’ returns a 2-tuple whose
first member is its local Internet address, in either IPv4 dotted or
IPv6 colon hexadecimal notation, and whose second member is the TCP or
UDP port number.  It is permissible for F to be a file descriptor that
is open only at the POSIX level.  In the case of a listening TCP server
socket or a UDP server socket, the address may indicate “any available”
interface, e.g., "0.0.0.0" or "::".

On failure of the underlying POSIX getsockname() to find an address for
F in family AF_INET or AF_INET6, ‘sockaddr’ sets ‘last_error’ and
returns ‘om’.

See also ‘open’, ‘filename’, ‘port’, ‘hostaddr’, ‘ip_addresses’,
‘ip_names’, ‘peer_name’, and ‘peer_sockaddr’.


File: setl-lib.info,  Node: socketpair,  Next: span,  Prev: sockaddr,  Up: The Library

‘socketpair’  -  create bidirectional local channel
===================================================

     proc socketpair : [integer, integer]

This is a low-level interface to POSIX socketpair().

It returns the file descriptors of a pair of connected, unnamed
Unix-domain sockets such that output to each socket is presented as
input to the other.

This is chiefly of use when you are (perhaps as a classroom or
prototyping exercise) managing processes at the level of ‘fork’, ‘dup2’,
‘close’, ‘exec’, and ‘waitpid’.  Otherwise, one of the higher-level
intrinsics {‘filter’, ‘system’, ‘pipe_from_child’, ‘pipe_to_child’,
‘pump’, ‘tty_pump’} or ‘open’ modes {"pipe-from", "pipe-to", "pump",
"tty-pump"} might cover your needs more conveniently.

That said, there may be times when you want an extra channel between the
program and a child process, or between offspring; and ‘socketpair’
creates such a channel before the spawning.  Each process would then
keep one fd and close the other, possibly opening a SETL stream over the
kept fd in mode "r", "w", or "rw", either explicitly with ‘open’ or (for
"r" or "w") implicitly (*note Automatic opening::).

Being a Unix-domain socket, each fd in the pair returned by ‘socketpair’
supports the passing of other file descriptors with ‘send_fd’ and
‘recv_fd’.

On failure, ‘socketpair’ sets ‘last_error’ and returns ‘om’.

See also ‘pipe’, which can (but need not be) used for unidirectional use
cases.


File: setl-lib.info,  Node: span,  Next: split,  Prev: socketpair,  Up: The Library

‘span’  -  extract leading substring using character set
========================================================

     proc span (rw string S, string P) : string

The longest initial substring of S consisting of characters that are in
P (treating P as a set of characters) is removed from S and returned.
If there is no such substring, nothing happens to S, and the empty
string ("") is returned.

See also the other SNOBOL-inspired intrinsics, namely ‘any’, ‘break’,
‘len’, ‘match’, ‘notany’, ‘rany’, ‘rbreak’, ‘rlen’, ‘rmatch’, ‘rnotany’,
and ‘rspan’.


File: setl-lib.info,  Node: split,  Next: sqrt,  Prev: span,  Up: The Library

‘split’  -  split string into tuple
===================================

     proc split (string S, pattern P) : [string, ...]
     proc split (string S) : [string, ...]

Substrings of S are returned as a tuple, where the extended regular
expression (ERE) P is a delimiter pattern defaulting to whitespace, "[
\f\n\r\t\v]+".

The subject string S is considered to be surrounded by strings
satisfying the delimiter pattern P, and ‘split’ returns the strings
between the delimiters.  So for example ‘split (":ab::c", ":")’ is
‘["", "ab", "", "c"]’ while ‘split (":ab::c", ":+")’ is ‘["ab", "c"]’.

The pattern P is subject to the setting of ‘magic’, and can be a string
or a 2-tuple, as detailed under ‘mark’.  When P is omitted, the
whitespace ERE is used regardless of the setting of ‘magic’.

Splitting the empty string yields the empty tuple; i.e.,
‘split ("", P) = []’ for any pattern P;

See also ‘join’ and ‘gsub’.


File: setl-lib.info,  Node: sqrt,  Next: status,  Prev: split,  Up: The Library

‘sqrt’  -  square root
======================

     op sqrt (real) : real
     op sqrt (integer) : real

Where squares come from.


File: setl-lib.info,  Node: status,  Next: standard streams,  Prev: sqrt,  Up: The Library

‘status’  -  child process status
=================================

     status : integer

Status of the child process that was last successfully waited for by
‘filter’, ‘system’, or ‘waitpid’; or by ‘close’ as applied to a pipe,
pump, or tty-pump stream in ‘close_await’ mode (the default).

The initial value of ‘status’, when no child status has yet been reaped,
is ‘om’.  It is also set to ‘om’ when any of the above calls is
unsuccessful, or when ‘waitpid’ returns 0.

If a successfully waited-for child made a normal exit, e.g. via POSIX
exit() or _exit(), return from C main() program, or SETL ‘stop’
statement, ‘status’ is the exit status given by the exit() or _exit()
argument, main() return value, or ‘stop’ operand, modulo 256.  In POSIX
conventions, an exit status of 0 indicates “success”.

If the child was terminated by signal SIG (see ‘kill’), ‘status’ is
‘-128 + SIG’.  This allows the SETL program to distinguish normal exits
from termination by signal, but also dovetails with shell practice
(which uses 128 plus the signal number).  For example, given a SIGINT
value of 2, the ‘status’ of a waited-for subprocess killed by SIGINT is
-126 (-128 + 2), which if used in turn as the operand of a ‘stop’
statement gives an exit status of 130 when taken modulo 256, just as for
a program the shell terminates with SIGINT, e.g. on a ctrl-C from the
keyboard.

Additionally, if the child is waited for by ‘waitpid’ (rather than by
‘close’, ‘filter’, or ‘system’), “stopped” and “continued” events are
reflected in a ‘status’ of ‘-32’ for a continued (resumed) child, and
‘-32 + STOPSIG’ for a stopped (suspended) child, where STOPSIG is the
number of the SIGSTOP, SIGTSTP, SIGTTIN, or SIGTTOU signal that caused
the stoppage.  These 4 signal numbers lie within the range 17 to 28 on
all known POSIX implementations, putting the corresponding ‘status’
values in an otherwise unused range of small negative integers.

See also ‘pipe_from_child’, ‘pipe_to_child’, ‘pump’, ‘tty_pump’, and the
‘open’ modes "pipe-from", "pipe-to", "pump", and "tty-pump".


File: setl-lib.info,  Node: standard streams,  Next: str,  Prev: status,  Up: The Library

‘stdin’, ‘stdout’, ‘stderr’  -  predefined streams
==================================================

     stdin : integer
     stdout : integer
     stderr : integer

The constant fd ‘stdin’ is ‘0’, ‘stdout’ is ‘1’, and ‘stderr’ is ‘2’.
*Note Predefined streams::.


File: setl-lib.info,  Node: str,  Next: strad,  Prev: standard streams,  Up: The Library

‘str’  -  string representation of value
========================================

     op str (var X) : string

The operand X is converted to a ‘string’ such that (for most types) the
result can be converted back to the same value using ‘unstr’.

Some loss of precision is possible in the case of ‘real X’, and the
decimal point may be omitted if the fraction in X is 0.  These hazards
can be offset by the use of ‘fixed’ or ‘floating’ in place of ‘str’.
Bizarre forms such as "nan" and "-inf" are also possible in extreme
cases.

Procedure references (see ‘routine’) are converted to "<ROUTINE>", and
‘atom’s are converted to strings of the form "#DIGITS".  Those two forms
cannot be converted back to values with ‘unstr’.

The value ‘om’ renders as an asterisk (‘*’).

For a ‘string X’ that does not have the form of a SETL identifier
(alphabetic character followed by 0 or more alphanumeric or underscore
characters), ‘str X’ is a copy of X except that each apostrophe (‘'’) is
twinned (producing two apostrophes in a row), and an apostrophe is added
at each end.  If X _does_ have the form of a SETL identifier,
‘str X = unstr X = X’.

For a ‘set X’, ‘str X’ begins with a left brace (‘{’) and ends with a
right one (‘}’).  Likewise brackets (‘[’,‘]’) surround a ‘tuple’.  Sets
and tuples nest to arbitrary degree, and the converted values within
them are separated by single spaces.

See also also ‘pretty’, ‘unpretty’, ‘whole’, ‘strad’, ‘val’, ‘printa’,
‘putb’, ‘puts’, and ‘writea’.


File: setl-lib.info,  Node: strad,  Next: sub,  Prev: str,  Up: The Library

‘strad’  -  radix-prefixed string representation of integer
===========================================================

     proc strad (integer X, integer RADIX) : string

The integer argument X is converted to a string representing its value
with an explicit radix.  The RADIX argument, which must be an integer in
the range 2 to 36, gives the base prefix in the result denotation
"RADIX#DIGITS", where the radix is represented in decimal and the digits
after the sharp sign are drawn from the characters ‘0’ through ‘9’ and
lowercase ‘a’ through ‘z’.  The string is prefixed with a hyphen if X is
negative.  Examples:

     strad (10, 10) = "10#10"
     strad (10, 16) = "16#a"
     strad (10, 2) = "2#1010"
     strad (-899, 36) = "-36#oz"

Strings produced by ‘strad’ can be converted back to integers by ‘val’,
‘unstr’, and ‘reads’.

See also ‘whole’, ‘str’, ‘fixed’, and ‘floating’.


File: setl-lib.info,  Node: sub,  Next: subset,  Prev: strad,  Up: The Library

‘sub’  -  replace pattern in string
===================================

     proc sub (rw string S, pattern P) : string
     proc sub (rw string S, pattern P, string R) : string

The leftmost occurrence in S of the pattern P is replaced by R, which
defaults to the empty string ("").  The matched substring of S replaced
by this operation is returned.  If P is not found, S is left unmodified
and ‘om’ is returned.

The pattern P is subject to the setting of ‘magic’, and can be a string
or a 2-tuple, as detailed under ‘mark’.

In the replacement pattern R, when ‘magic’ is ‘true’, the ampersand
character (‘&’) is special, as is a backslash (‘\’) followed by a
decimal digit.  The ampersand refers to the entire matched substring,
and that is also the meaning of a backslash followed by zero (‘0’).
Backslash followed by another digit _k_ refers to the substring matching
the _k_th parenthesized subexpression in the pattern P.  When P is a
tuple ‘[P1, P2]’, parenthesized subexpressions are counted starting in
P1 and continuing in P2.

If ‘magic’ is set to ‘false’, R is taken literally as the string to
replace the matched substring, with no ampersand or backslash
interpretation.

Notice that for string P, the expression

     sub (S, P, R)

is similar to

     S(P) := R

except that the value of the latter is not simply the substring that was
replaced as it is in the ‘sub’ case, but rather the new value of
‘S(P)’—a rematch!

If P is the tuple ‘[P1, P2]’, the corresponding assignment is:

     S(P1..P2) := R

See also ‘gsub’ and ‘gmark’.


File: setl-lib.info,  Node: subset,  Next: symlink,  Prev: sub,  Up: The Library

‘subset’  -  subset test
========================

     op subset (set SS, set S) : boolean

Returns ‘true’ if every member of SS is also in S.

Being a predicate, it has quite a low precedence.  *Note Operator
Precedence::.

See also ‘incs’.


File: setl-lib.info,  Node: symlink,  Next: system,  Prev: subset,  Up: The Library

‘symlink’  -  create symbolic link
==================================

     proc symlink (string S, string NEW)

Creates a symbolic link (“soft link”) to S under the filename NEW using
POSIX symlink(), if NEW does not exist before the call.

For symbolic links, unlike “hard” links (see ‘link’), it does not matter
whether S refers to an existing file in order for the ‘symlink’ call to
succeed.  However, if S does exist as a file and the ‘symlink’ call does
succeed, subsequent attempts to access the contents of the file NEW will
be redirected to the file S.

If ‘symlink’ fails, ‘last_error’ is set.

Given a stable directory structure above NEW, ‘symlink’ behaves
atomically, and can be used as a test-and-set mechanism for
inter-process synchronization: the lock (mutex) NEW is acquired if and
when ‘symlink’ succeeds, and releasing it is done atomically by
‘unlink’.

See also ‘readlink’, ‘lexists’, ‘fexists’, and ‘rename’.


File: setl-lib.info,  Node: system,  Next: sys_read,  Prev: symlink,  Up: The Library

‘system’  -  run command in subshell
====================================

     proc system (string CMD) : integer

The CMD argument specifies a shell command, which is performed as if by
‘exec ("/bin/sh", ["sh", "-c", CMD])’ in a child process spawned as if
by ‘fork’.

Just as with ‘filter’, the signals SIGINT and SIGQUIT are temporarily
ignored in the parent while it waits for the child to complete.  Thus a
terminal-generated signal (typically ctrl-C for SIGINT and ctrl-\ for
SIGQUIT) that goes to the process group will be seen by the child but
not the parent, which thus remains to handle the child termination.

SIGCHLD is not blocked during the ‘system’ call, as it would be during a
POSIX system() call.  The SETL implementation is expected to do all
handling of SIGCHLD, and has to be free to reap child processes detached
via ‘close_autoreap’ even while it is waiting for the CMD child to
complete.  Effectively, this means that it has to be in no danger of
competing with a user-supplied handler that intercepts SIGCHLD. Since
that signal, like others, is reflected up to the SETL program when a
"signal" stream over it is open, there is no need in a SETL
implementation, and really no room in the semantics of SETL, for
unrestricted asynchronous signal handlers.

The parent uses POSIX waitpid() to get the exit status of the command,
which is placed in ‘status’ and returned by ‘system’.  If waitpid()
fails, ‘status’ is set to ‘om’ and the reason for the failure appears in
‘last_error’, just as in the similar scenario of ‘close’ with the
‘close_await’ parameter.

See also ‘pipe_from_child’, ‘pipe_to_child’, ‘pump’, ‘tty_pump’,
‘socketpair’, ‘pipe’, ‘dup’, ‘dup2’, and ‘waitpid’; and the ‘open’ modes
"pipe-from", "pipe-to", "pump", and "tty-pump".


File: setl-lib.info,  Node: sys_read,  Next: sys_write,  Prev: system,  Up: The Library

‘sys_read’  -  low-level read
=============================

     proc sys_read (integer FD, integer N) : string

This function bypasses SETL buffering and calls POSIX read() directly.
The FD may or may not be open at the SETL level (*note Buffering::).

Up to N bytes are read from the FD and returned as a string.

End of file is _not_ indicated by a change in ‘eof’, only by an empty
string result ("").

If an error occurs at the POSIX read() level, ‘sys_read’ sets
‘last_error’ and returns ‘om’.

See also ‘sys_write’.


File: setl-lib.info,  Node: sys_write,  Next: tan,  Prev: sys_read,  Up: The Library

‘sys_write’  -  low-level write
===============================

     proc sys_write (integer FD, string S) : integer

This function bypasses SETL buffering and calls POSIX write() directly.
The FD may or may not be open at the SETL level (*note Buffering::).

An attempt is made to write all ‘#S’ bytes of S.  The actual number of
bytes written is returned, unless there is an error at the POSIX write()
level, in which case -1 is returned and ‘last_error’ gives details.

See also ‘sys_read’.


File: setl-lib.info,  Node: tan,  Next: tanh,  Prev: sys_write,  Up: The Library

‘tan’  -  trigonometric tangent
===============================

     op tan (real) : real
     op tan (integer) : real

The operand is in radians.  See also ‘atan’ and ‘atan2’.


File: setl-lib.info,  Node: tanh,  Next: tcgetpgrp,  Prev: tan,  Up: The Library

‘tanh’  -  hyperbolic tangent
=============================

     op tanh (real) : real
     op tanh (integer) : real

An extreme diversion.


File: setl-lib.info,  Node: tcgetpgrp,  Next: tcsetpgrp,  Prev: tanh,  Up: The Library

‘tcgetpgrp’  -  get foreground process group ID
===============================================

     proc tcgetpgrp (stream F) : integer

Uses POSIX tcgetpgrp to get the process group ID of the foreground
process group for which the terminal given by stream F is the caller’s
controlling terminal.  If there is no foreground process group, the
return value will be greater than 1 and not match the ID of any existing
process group.

On failure, ‘last_error’ is set and ‘om’ is returned.

See also ‘tcsetpgrp’.


File: setl-lib.info,  Node: tcsetpgrp,  Next: tie,  Prev: tcgetpgrp,  Up: The Library

‘tcsetpgrp’  -  put process group into foreground
=================================================

     proc tcsetpgrp (stream F, integer P)

For use in job control, ‘tcsetpgrp’ uses POSIX tcsetpgrp to set the
foreground process group ID associated with the controlling terminal
(see ‘setctty’) given by stream F to P, which must match the process
group ID of a process in the same session as the calling process.  The
terminal driver sends keyboard-generated signals (SIGINT and SIGQUIT) to
the foreground process group (job).

If ‘tcsetpgrp’ is called by a member of a background process group in
its session, and the caller is not blocking or ignoring SIGTTOU, a
SIGTTOU signal is sent to the background process group (as it is for
attempted output to the controlling terminal by a background process
when POSIX ‘stty tostop’ is in effect).  If SIGTTOU is being blocked or
ignored, the ‘tcsetpgrp’ operation is allowed.  Interactive session
leaders use it to assign foreground status to one job or another.

On failure, ‘tcsetpgrp’ sets ‘last_error’.

See also ‘tcgetpgrp’, ‘getpgrp’, ‘setpgid’, and ‘tty_pump’.


File: setl-lib.info,  Node: tie,  Next: time,  Prev: tcsetpgrp,  Up: The Library

‘tie’  -  auto-flush stream upon input from other stream
========================================================

     proc tie (stream, stream)

After a call to ‘tie’, whenever an input operation such as ‘reada’ or
‘geta’ is requested on one of the two given streams, all output buffered
for the other is written out as if by ‘flush’ first but without setting
‘last_error’.  Flushing a read-only stream, or a stream with no pending
output, is a no-op.

There are a few other operations besides attempted sequential stream
input that trigger the auto-flushing of a tied stream.  *Note
Buffering::.

A stream can only be tied to one other stream at a time.  Previous
associations are dissolved by ‘tie’ when it forms a new one, and by
‘untie’.


File: setl-lib.info,  Node: time,  Next: to_lower,  Prev: tie,  Up: The Library

‘time’  -  elapsed CPU time in milliseconds
===========================================

     proc time : integer

This gives the total amount of CPU time used by the current process and
all its child processes that have terminated and been waited for, in
milliseconds.  This includes both “user” time and time spent by the
operating system on behalf of the user.

See also ‘clock’, ‘tod’, ‘close’ (on streams connected to child
processes), ‘filter’, ‘system’, and ‘waitpid’.


File: setl-lib.info,  Node: to_lower,  Next: to_upper,  Prev: time,  Up: The Library

‘to_lower’  -  convert string to lowercase
==========================================

     op to_lower (string) : string

A string of length equal to that of the operand is returned.  Characters
other than ‘A-Z’ are unaffected.

See also ‘to_upper’.


File: setl-lib.info,  Node: to_upper,  Next: tod,  Prev: to_lower,  Up: The Library

‘to_upper’  -  convert string to uppercase
==========================================

     op to_upper (string) : string

A string of length equal to that of the operand is returned.  Characters
other than ‘a-z’ are unaffected.

See also ‘to_lower’.


File: setl-lib.info,  Node: tod,  Next: true,  Prev: to_upper,  Up: The Library

‘tod’  -  calendar time in milliseconds
=======================================

     proc tod : integer

This is the total number of milliseconds that have elapsed in the epoch
beginning 1 January 1970 UTC.

See also ‘clock’, ‘time’, ‘date’, and ‘fdate’.


File: setl-lib.info,  Node: true,  Next: tty_pump,  Prev: tod,  Up: The Library

‘true’  -  predefined boolean value
===================================

     true : boolean

Information is not knowledge.
Knowledge is not wisdom.
Wisdom is not truth.
Truth is not beauty.
Beauty is not love.
Love is not music.
Music is the best.

 _– Frank Zappa, 1979_

See also ‘false’.


File: setl-lib.info,  Node: tty_pump,  Next: type,  Prev: true,  Up: The Library

‘tty_pump’  -  master end of child stream over pseudo-terminal
==============================================================

This is the same as ‘pump’, but instead of a socketpair, the child’s
standard input and output are connected to the slave side of a
pseudo-terminal (pty) in “raw” mode; ‘tty_pump’ returns the fd of the
master side.

The ‘open’ mode "tty-pump" is like ‘tty_pump’ but spawns an external
program rather than a local coprocess.

*Note Connected subprocesses: Pipes and pumps.


File: setl-lib.info,  Node: type,  Next: umask,  Prev: tty_pump,  Up: The Library

‘type’  -  type of SETL value
=============================

     op type (var) : string

Returns "ATOM", "BOOLEAN", "INTEGER", "REAL", "SET", "STRING", "TUPLE",
"PROC_REF", or "OM".

See also the ‘is_TYPE’ “type-testing” operators, and ‘denotype’.


File: setl-lib.info,  Node: umask,  Next: ungetc,  Prev: type,  Up: The Library

‘umask’  -  set file mode creation mask
=======================================

     proc umask : integer
     proc umask (integer) : integer

This is an interface to POSIX umask().  Both forms of the call return
the current value of the file mode creation mask, and the second form
changes it to a new value.  For example,

     umask (8#022);

arranges that files created by the program and its child processes will
not be writable by other users or groups unless subsequently made so by
the POSIX ‘chmod’ command.

In restricted mode (*note Restricted Mode::), ‘bit_or’ is applied
between the mask argument and the mask with which the SETL program
began.  This allows the environment to prevent a restricted program from
creating files with excessive permissions.  For example, starting the
restricted program with a umask of octal 137 would make sure files were
created with no execute access by the owner, at most read access by the
group, and no access by the rest of the world.


File: setl-lib.info,  Node: ungetc,  Next: ungetchar,  Prev: umask,  Up: The Library

‘ungetc’  -  push characters back into stream
=============================================

     proc ungetc (stream F, string S)

The 0 or more characters of S are “pushed back” into the stream F, so
that they will appear as the next input.  The SETL implementation may
insist that S match the ‘#S’ characters that were most recently read
from the stream.

At least one character of pushback is allowed if at least one character
has been read since the input buffer was last empty, such as after it
was last drained (*note Buffering::).

A successful ‘ungetc’ does _not_ clear ‘eof’, but the next input attempt
on F will begin by doing so.  Pending ‘eof’ and error indicators remain
pending, and any characters pushed back can be read again before ‘eof’
and possibly ‘last_error’ are actually set.

See also ‘ungetchar’, ‘peekc’, and ‘peekchar’.


File: setl-lib.info,  Node: ungetchar,  Next: unhex,  Prev: ungetc,  Up: The Library

‘ungetchar’  -  push characters back into ‘stdin’
=================================================

     proc ungetchar (string S)

Equivalent to ‘ungetc (stdin, S)’.


File: setl-lib.info,  Node: unhex,  Next: unlink,  Prev: ungetchar,  Up: The Library

‘unhex’  -  convert from hexadecimal
====================================

     op unhex (string) : string

This is the inverse of ‘hex’.  It returns ‘om’ if its string operand
does not contain an even number of (case-insensitively recognized)
hexadecimal characters.


File: setl-lib.info,  Node: unlink,  Next: unpretty,  Prev: unhex,  Up: The Library

‘unlink’  -  destroy file reference
===================================

     proc unlink (string F)

Remove the pathname F from the filesystem, using POSIX unlink().  If F
is a symbolic link, the pathname is removed.  Otherwise, if F is the
last link to the object in the filesystem, and the last of any file
descriptors open on it have closed, the space if any occupied by the
object is freed.

If ‘unlink’ fails, ‘last_error’ is set.

See also ‘link’, ‘symlink’, ‘readlink’, ‘fexists’, and ‘lexists’.


File: setl-lib.info,  Node: unpretty,  Next: unsetctty,  Prev: unlink,  Up: The Library

‘unpretty’  -  convert string from “pretty” form
================================================

     op unpretty (string S) : string

The string S should be in “pretty” form, though the ‘unpretty’ operator
is somewhat liberal in what it accepts relative to what ‘pretty’
produces.

However, S must still begin and end with an apostrophe (single quote,
‘'’) or begin and end with a double quote (‘"’).

Inside S, every character must be one of the 95 characters ASCII
considers “printable”, which includes blank.  The ‘unpretty’ operator
makes the following interpretations in transforming S into an
unrestricted string, where backslash (‘\’) is the “escape” character
that introduces a special sequence:

   • Escape followed by any of the 33 non-alphanumeric printable
     characters, including backslash, means just that character.

   • Escape followed by up to 3 octal digits starting with the digit 0,
     1, 2, or 3 means a character having the bit pattern indicated by
     the digits, as in C.

   • Escape followed by ‘x’ and then 1 or 2 hexadecimal digits is an
     alternative to the octal escape sequence.  Thus "\xdB" means the
     same as "\333" to ‘unpretty’.

   • Escape followed by these letters means what it does in C:

     letter      equivalent     ASCII meaning
     -------------------------------------------------------------------
     ‘a’         ‘x07’          alert
     ‘b’         ‘x08’          backspace
     ‘f’         ‘x0c’          formfeed
     ‘n’         ‘x0a’          newline
     ‘r’         ‘x0d’          carriage return
     ‘t’         ‘x09’          horizontal tab
     ‘v’         ‘x0b’          vertical tab

   • Escape followed by anything else is invalid.

Other characters represent themselves, except that if the string begins
with an apostrophe, an internal apostrophe may be indicated by a pair of
successive apostrophes instead of ‘\'’.  Likewise, if the string begins
with a double quote, an internal double quote may be indicated by a pair
of successive double quotes rather than ‘\"’.

Those are also the rules and interpretations for literal strings in SETL
source code.

For any string S, ‘unpretty pretty s = s’.

See also ‘unstr’ and ‘str’.


File: setl-lib.info,  Node: unsetctty,  Next: unsetenv,  Prev: unpretty,  Up: The Library

‘unsetctty’  -  relinquish controlling terminal
===============================================

     proc unsetctty (stream F)

If the terminal or pseudo-terminal connected to stream F is the
controlling terminal for the calling process (see ‘setctty’), it is
given up, provided that a mechanism at the host system level such as the
BSD-rooted ioctl() TIOCNOTTY is available.  On some systems, such as
Linux, this will also cause signals SIGHUP and SIGCONT to be sent to the
foreground process group if the caller is session leader.

Failure of ‘unsetctty’ is reflected in ‘last_error’.


File: setl-lib.info,  Node: unsetenv,  Next: unstr,  Prev: unsetctty,  Up: The Library

‘unsetenv’  -  remove environment variable definition
=====================================================

     op unsetenv (string NAME)

If the environment variable NAME was defined, undefine it.  Note that
this is not the same as setting it to the empty string ("").

See also ‘setenv’ and ‘getenv’.


File: setl-lib.info,  Node: unstr,  Next: untie,  Prev: unsetenv,  Up: The Library

‘unstr’  -  read value from string
==================================

     op unstr (string S) : var

The ‘unstr’ operator converts any string produced by ‘str’ (a
“denotation”) back to its original type, except that it does not accept
the string representations of procedure references or atoms, interprets
"nan" and "inf" as strings, treats "-nan" and "-inf" as erroneous, and
classifies numbers as ‘real’ or ‘integer’ according to their appearance
(so the type of ‘unstr str 2.0’ is ‘integer’).  Also, since ‘str’ may do
some rounding when rendering a ‘real’, you don’t necessarily get back
exactly the number you put in for reals when making this round trip.

Quoted strings within S can use either the apostrophe (‘'’) or the
double quote (‘"’) as the beginning and ending quote character.
Whichever one is used is also the one that can be twinned internally to
represent that character.  Apart from reducing those twins, ‘unstr’ is
completely literal about how it interprets what is inside a quoted
string.  Even backslashes are not special, in contrast to string
literals in SETL source code or equivalently strings interpreted by
‘unpretty’.

Radix-prefixed integer denotations (see ‘strad’) are allowed to have
trailing sharp signs (redundantly), just as in SETL source code.

Arbitrary whitespace, and/or a comma, is allowed wherever ‘str’ would
put a single blank between elements of sets and tuples.  Whitespace is
permitted around the overall denotation in S.

The ‘denotype’ operator can be used to check whether a string is
acceptable to ‘unstr’.

See also ‘reada’, ‘reads’, and ‘val’.


File: setl-lib.info,  Node: untie,  Next: val,  Prev: unstr,  Up: The Library

‘untie’  -  dissolve stream association made by ‘tie’
=====================================================

     proc untie (stream, stream)

For symmetry with ‘tie’.


File: setl-lib.info,  Node: val,  Next: wait,  Prev: untie,  Up: The Library

‘val’  -  read number from string
=================================

     op val (string) : integer
     op val (string) : real

This is similar to ‘unstr’ but expects a numeric denotation as an
operand.  Another difference from ‘unstr’ is that ‘val’ will return ‘om’
instead of throwing tantrums if the operand string does not satisfy its
syntactic requirements (which are the same as for numeric literals in
SETL source code).

See also ‘denotype’ and ‘strad’.


File: setl-lib.info,  Node: wait,  Next: waitpid,  Prev: val,  Up: The Library

‘wait’  -  wait for any child process status change
===================================================

     proc wait : integer
     proc wait (boolean WAITFLAG) : integer

Equivalent to ‘waitpid (-1)’ or ‘waitpid (-1, WAITFLAG)’.


File: setl-lib.info,  Node: waitpid,  Next: whole,  Prev: wait,  Up: The Library

‘waitpid’  -  wait for child process status change
==================================================

     proc waitpid (integer P): integer
     proc waitpid (integer P, boolean WAITFLAG) : integer

Tries to obtain the status of a child process identified by P.

If successful, it returns the process ID (pid) of a child process that
has terminated, stopped (suspended), or continued (resumed).  The child
status appears in ‘status’.

The rules for P follow those of POSIX waitpid():

   • If P is -1, status is requested for any child process (like
     ‘wait’).

   • If P is greater than 0, P specifies the pid of a single child
     process for which status is requested.

   • If P is 0, status is requested for any child process whose process
     group ID is equal to that of the calling process.

   • If P is less than -1, status is requested for any child process
     whose process group ID is equal to the absolute value of P.

The optional WAITFLAG argument, which defaults to ‘true’, specifies
whether the calling process should block, waiting for a child process to
terminate, stop, or continue.  If ‘false’, meaning don’t block, and the
caller has at least one child identified by P, and no child in that set
has a state change to report, ‘waitpid’ sets ‘status’ to ‘om’ and
returns 0.  Otherwise, one such child is selected, ‘status’ gets the
state change details, and the pid is returned, just as in the blocking
case.

In the case of termination, the child process and its exit status are
said to be “reaped”, and the system clears its record of both.

If there are no child processes identified by P, ‘waitpid’ sets ‘status’
to ‘om’, sets ‘last_error’, and returns -1.

The use of ‘waitpid’ is seldom necessary except after applying ‘close’
in mode ‘close_zombie’ to a pipe or pump stream, or when programming at
the more foundational level of ‘fork’.  Otherwise, you might reap away
the status of a child created by ‘pipe_from_child’, ‘pipe_to_child’,
‘pump’, ‘tty_pump’, or one of the ‘open’ modes "pipe-from", "pipe-to",
"pump", or "tty-pump", before ‘close’ gets a chance to.

Child processes that have not been waited for when the SETL program
terminates are inherited by a POSIX system process that reaps and
discards their statuses when they terminate, if ever.

See also ‘system’, ‘filter’, ‘kill’, ‘pid’, ‘pexists’, and ‘time’.


File: setl-lib.info,  Node: whole,  Next: with,  Prev: waitpid,  Up: The Library

‘whole’  -  format integer
==========================

     proc whole (integer X, integer WID) : string
     proc whole (real X, integer WID) : string

The number ‘round X’ is converted to a string of length ‘abs WID’ or
more.

If ‘abs WID’ is larger than necessary, the string is padded with blanks
on the left (for positive WID) or on the right (for negative WID).

If ‘abs WID’ is too small, a longer string is produced as necessary to
accommodate the number.

Although this operator is intended primarily for rendering ‘integer’
values, the automatic rounding in the case of ‘real’ can result in the
string "nan", "inf", or "infinity", with or without a minus sign in
front.

See also ‘fixed’, ‘floating’, ‘str’, and ‘strad’.


File: setl-lib.info,  Node: with,  Next: write,  Prev: whole,  Up: The Library

‘with’  -  set plus one element
===============================

     op with (set S, var X) : set

Definition: ‘S with X = S + {X}’.

See the set union (“plus”) operator (‘+’), and see also ‘less’.


File: setl-lib.info,  Node: write,  Next: writea,  Prev: with,  Up: The Library

‘write’  -  write values to ‘stdout’
====================================

     proc write (var ARGS(*))

Equivalent to ‘writea (stdout, ARGS(*))’.

See also ‘print’ and ‘nprint’.


File: setl-lib.info,  Node: writea,  Prev: write,  Up: The Library

‘writea’  -  write values to stream
===================================

     proc writea (stream F, var ARGS(*))

The 0 or more ARGS are written in sequence to the stream F, separated by
single spaces and followed by a newline character (‘\n’).  All of them
are converted as if by ‘str’ first, with no exception for strings
(contrast ‘printa’).

Values written by ‘writea’, except for atoms (see ‘newat’) and procedure
references (see ‘routine’), can be read by ‘reada’ and ‘getb’.

If F is not already open, an attempt is made to auto-open it.  *Note
Automatic opening::.

On output error, output may be incomplete and ‘last_error’ may be set.

A synonym for ‘writea’ is ‘putb’.

See also ‘write’ and ‘nprinta’.


File: setl-lib.info,  Node: Operator Precedence,  Next: Restricted Mode,  Prev: The Library,  Up: Top

Operator Precedence
*******************

From highest precedence (most tightly binding) to lowest:

operators                                                  associativity
------------------------------------------------------------------------
unary non-predicates, user-declared unary operators           right
“power” (‘**’)                                                right
“star” (‘*’), “slash” (‘/’), ‘atan2’, ‘div’, ‘mod’,           left
‘rem’, ‘bit_and’
binary “plus” (‘+’), binary “minus” (‘-’), ‘max’, ‘min’,      left
‘bit_or’, ‘bit_xor’
‘less’, ‘lessf’, ‘with’                                       left
‘npow’                                                        left
“query” (‘?’)                                                 left
user-declared binary operators                                left
binary predicates: “equalities” (‘=’, ‘/=’),                  none
“comparatives” (‘<’, ‘>’, ‘<=’, ‘>=’), ‘in’, ‘notin’,
‘subset’, ‘incs’
unary predicates: ‘not’, ‘even’, ‘odd’, ‘fexists’,            right
‘lexists’, ‘pexists’, ‘is_open’, “type-testing”
operators (‘is_TYPE’)
‘and’                                                         left
‘or’                                                          left
‘impl’                                                        left

Predicates are intrinsic operators that return ‘boolean’, and have lower
precedence than all non-predicate operators.

Unary combining forms such as ‘+/ [1..9]’, where a left-associative
operator is followed by slash, have the highest precedence, like other
non-predicate unary forms.  Binary combining forms such as
‘0 +/ [1..9]’, where the left-associative operator is followed by a
slash but also preceded by an operand, have the same precedence as the
binary operator.

The associativity of “power” (‘**’) is changed from the original CIMS
SETL to agree with SETL2 and Fortran.  To avoid confusion, it is not
allowed in the combining forms, which use a left-to-right chaining rule.


File: setl-lib.info,  Node: Restricted Mode,  Next: Index,  Prev: Operator Precedence,  Up: Top

Restricted Mode
***************

It is an error to call the following intrinsics in “restricted” mode
(‘--restricted’ (*note (setl-user)--restricted::) command-line option):

     ‘callout’,
     ‘chdir’,
     ‘close’ (except on streams that were opened by the SETL program),
     ‘dup’, ‘dup2’,
     ‘exec’,
     ‘fexists’,
     ‘filter’ (except where permitted by an ‘--allow-filter’ (*note
     (setl-user)--allow-filter::) command-line option),
     ‘fork’,
     ‘fsize’,
     ‘getegid’,
     ‘getenv’,
     ‘geteuid’,
     ‘getgid’,
     ‘getsid’ with a non-zero argument,
     ‘getuid’,
     ‘getwd’,
     ‘glob’,
     ‘kill’ (except on processes spawned by ‘pipe_from_child’,
     ‘pipe_to_child’, ‘pump’, or ‘tty_pump’),
     ‘lexists’,
     ‘link’,
     ‘mkstemp’ (except where permitted by an ‘--allow-mkstemp’ (*note
     (setl-user)--allow-mkstemp::) command-line option),
     ‘open’ (except on a timer or where permitted by an ‘--allow-open’
     (*note (setl-user)--allow-open::) or ‘--allow-fd-open’ (*note
     (setl-user)--allow-fd-open::) command-line option),
     ‘pexists’,
     ‘pipe’,
     ‘rename’,
     ‘setctty’,
     ‘setegid’,
     ‘setenv’,
     ‘seteuid’,
     ‘setgid’,
     ‘setpgid’,
     ‘setsid’,
     ‘setuid’,
     ‘socketpair’,
     ‘symlink’,
     ‘system’ (except where permitted by an ‘--allow-system’ (*note
     (setl-user)--allow-system::) command-line option),
     ‘sys_read’, ‘sys_write’,
     ‘tcgetpgrp’, ‘tcsetpgrp’,
     ‘unlink’,
     ‘unsetctty’, and
     ‘unsetenv’.

Also, ‘umask’ in restricted mode ORs its argument with the mask that was
in effect when the SETL program was started.


File: setl-lib.info,  Node: Index,  Prev: Restricted Mode,  Up: Top

Concept Index
*************

 [index ]
* Menu:

* # (sharp):                             sharp.                 (line 6)
* * (star):                              star.                  (line 6)
* ** (power):                            power.                 (line 6)
* + (plus):                              plus.                  (line 6)
* +:= (plus and assign):                 query.                 (line 6)
* - (minus):                             minus.                 (line 6)
* / (slash):                             slash.                 (line 6)
* / (slash) <1>:                         intslash.              (line 6)
* /bin/sh:                               filter.                (line 6)
* /bin/sh <1>:                           open arguments.        (line 6)
* /bin/sh <2>:                           system.                (line 6)
* 2-norm:                                abs.                   (line 6)
* <, >, <=, >= (comparatives):           comparatives.          (line 6)
* =, /= (equalities):                    equalities.            (line 6)
* ? (query):                             query.                 (line 6)
* abs:                                   abs.                   (line 6)
* absolute value:                        abs.                   (line 6)
* accept connection on server socket:    accept.                (line 6)
* acos (arc cosine):                     acos.                  (line 6)
* addition:                              plus.                  (line 6)
* all subsets (power set):               pow.                   (line 6)
* alternative open mode args:            open apocrypha.        (line 6)
* and (conjunction):                     and.                   (line 6)
* any (extract leading character):       any.                   (line 6)
* arb (arbitrary element of set):        arb.                   (line 6)
* arbitrary vs. random:                  arb.                   (line 6)
* arbitrary vs. random <1>:              from.                  (line 6)
* arc cosine:                            acos.                  (line 6)
* arc sine:                              asin.                  (line 6)
* arc tangent:                           atan.                  (line 6)
* arc tangent of quotient:               atan2.                 (line 6)
* ASCII:                                 pretty.                (line 6)
* ASCII <1>:                             unpretty.              (line 6)
* asin (arc sine):                       asin.                  (line 6)
* asterisk:                              star.                  (line 6)
* asterisk <1>:                          str.                   (line 6)
* atan (arc tangent):                    atan.                  (line 6)
* atan2 (arc tangent of quotient):       atan2.                 (line 6)
* atom type:                             newat.                 (line 6)
* auto-open and auto-close:              Automatic opening.     (line 6)
* automatic flushing:                    Buffering.             (line 6)
* backslash escapes:                     pretty.                (line 6)
* backslash escapes <1>:                 unpretty.              (line 6)
* bitwise logical operators:             bitwise logical ops.   (line 6)
* bit_and (bitwise and):                 bitwise logical ops.   (line 6)
* bit_not (bitwise not):                 bitwise logical ops.   (line 6)
* bit_or (bitwise or):                   bitwise logical ops.   (line 6)
* bit_xor (bitwise exclusive or):        bitwise logical ops.   (line 6)
* break (extract leading substring):     break.                 (line 6)
* buffering output:                      flush.                 (line 6)
* buffering output <1>:                  Buffering.             (line 6)
* byte value:                            char.                  (line 6)
* byte value <1>:                        ichar.                 (line 6)
* calendar time:                         fdate.                 (line 6)
* calendar time in milliseconds:         tod.                   (line 6)
* call (indirect call):                  call.                  (line 6)
* callbacks:                             select.                (line 6)
* callout (call C function):             callout.               (line 6)
* cardinality of set:                    sharp.                 (line 6)
* ceil (least integer upper bound):      ceil.                  (line 6)
* change directory:                      chdir.                 (line 6)
* char (character of integer code):      char.                  (line 6)
* character code:                        char.                  (line 6)
* character code <1>:                    ichar.                 (line 6)
* character code value:                  abs.                   (line 6)
* chdir (change directory):              chdir.                 (line 6)
* checking type:                         type-testing.          (line 6)
* child process:                         close.                 (line 6)
* child process <1>:                     filter.                (line 6)
* child process <2>:                     fork.                  (line 6)
* child process <3>:                     Pipes and pumps.       (line 6)
* child process <4>:                     pid.                   (line 6)
* child process <5>:                     pipe_from_child.       (line 6)
* child process <6>:                     pipe_to_child.         (line 6)
* child process <7>:                     pump.                  (line 6)
* child process <8>:                     status.                (line 6)
* child process <9>:                     system.                (line 6)
* child process <10>:                    time.                  (line 6)
* child process <11>:                    tty_pump.              (line 6)
* child process <12>:                    waitpid.               (line 6)
* choice, set element:                   arb.                   (line 6)
* choice, set element <1>:               from.                  (line 6)
* CIMS SETL:                             get.                   (line 6)
* CIMS SETL <1>:                         open.                  (line 6)
* CIMS SETL <2>:                         put.                   (line 6)
* clear_error (clear system error indicator): clear_error.      (line 6)
* client socket:                         open arguments.        (line 6)
* client socket <1>:                     Network sockets.       (line 6)
* client socket <2>:                     Local sockets.         (line 6)
* client socket <3>:                     recv.                  (line 6)
* client socket <4>:                     send.                  (line 6)
* clock (elapsed time in ms):            clock.                 (line 6)
* close (close stream):                  close.                 (line 6)
* close_await, close_autoreap, close_zombie: close constants.   (line 6)
* command, run from within program:      filter.                (line 6)
* command, run from within program <1>:  open arguments.        (line 6)
* command, run from within program <2>:  Pipes and pumps.       (line 6)
* command, run from within program <3>:  system.                (line 6)
* command_line (program arguments):      command_line.          (line 6)
* command_name (program name):           command_name.          (line 6)
* comparatives (<, >, <=, >=):           comparatives.          (line 6)
* comparison, order-based:               max.                   (line 6)
* comparison, order-based <1>:           min.                   (line 6)
* complex numbers:                       atan2.                 (line 6)
* concatenate tuple of strings, with delimiter: join.           (line 6)
* concatenation, string or tuple:        star.                  (line 6)
* concatenation, string or tuple <1>:    plus.                  (line 6)
* conjunction:                           and.                   (line 6)
* controlling process:                   setctty.               (line 6)
* controlling terminal:                  setctty.               (line 6)
* controlling terminal <1>:              tcsetpgrp.             (line 6)
* controlling terminal <2>:              unsetctty.             (line 6)
* conversion to string, implicit:        plus.                  (line 6)
* convert arbitrary value to string:     str.                   (line 6)
* convert character to integer:          abs.                   (line 6)
* convert character to integer <1>:      ichar.                 (line 6)
* convert from hexadecimal:              unhex.                 (line 6)
* convert from string:                   reads.                 (line 6)
* convert from string <1>:               unstr.                 (line 6)
* convert from string <2>:               val.                   (line 6)
* convert number to string:              fixed.                 (line 6)
* convert number to string <1>:          floating.              (line 6)
* convert number to string <2>:          str.                   (line 6)
* convert number to string <3>:          strad.                 (line 6)
* convert number to string <4>:          whole.                 (line 6)
* convert small integer to character:    char.                  (line 6)
* convert string to lowercase:           to_lower.              (line 6)
* convert string to uppercase:           to_upper.              (line 6)
* convert to integer:                    ceil.                  (line 6)
* convert to integer <1>:                fix.                   (line 6)
* convert to integer <2>:                floor.                 (line 6)
* convert to integer <3>:                round.                 (line 6)
* convert to real:                       float.                 (line 6)
* coprocess:                             Pipes and pumps.       (line 6)
* coprocess <1>:                         pump.                  (line 6)
* coprocess <2>:                         tty_pump.              (line 6)
* cos (cosine):                          cos.                   (line 6)
* cosh (hyperbolic cosine):              cosh.                  (line 6)
* CPU time:                              time.                  (line 6)
* current working directory:             chdir.                 (line 6)
* current working directory <1>:         getwd.                 (line 6)
* datagram:                              recv.                  (line 6)
* datagram <1>:                          recvfrom.              (line 6)
* datagram <2>:                          send.                  (line 6)
* datagram <3>:                          sendto.                (line 6)
* datatype:                              denotype.              (line 6)
* datatype <1>:                          type-testing.          (line 6)
* datatype <2>:                          type.                  (line 6)
* date:                                  fdate.                 (line 6)
* date <1>:                              tod.                   (line 6)
* date (date and time of day):           date.                  (line 6)
* decimal point:                         fixed.                 (line 6)
* decimal point <1>:                     floating.              (line 6)
* delimiter:                             break.                 (line 6)
* delimiter <1>:                         join.                  (line 6)
* delimiter <2>:                         rbreak.                (line 6)
* delimiter <3>:                         split.                 (line 6)
* denotype (type of denotation in string): denotype.            (line 6)
* destroy file reference:                unlink.                (line 6)
* difference:                            minus.                 (line 6)
* direct access:                         gets.                  (line 6)
* direct access <1>:                     mkstemp.               (line 6)
* direct access <2>:                     open arguments.        (line 6)
* direct access <3>:                     puts.                  (line 6)
* direct access <4>:                     seek.                  (line 6)
* directory, change:                     chdir.                 (line 6)
* disjunction:                           or.                    (line 6)
* div (integer division):                div.                   (line 6)
* divisible by 2:                        even.                  (line 6)
* divisible by 2 <1>:                    odd.                   (line 6)
* division:                              slash.                 (line 6)
* division <1>:                          div.                   (line 6)
* division <2>:                          intslash.              (line 6)
* domain (map domain):                   domain.                (line 6)
* dup, dup2 (duplicate a file descriptor): dup; dup2.           (line 6)
* dynamic type:                          type-testing.          (line 6)
* effective group ID:                    getegid.               (line 6)
* effective group ID <1>:                setegid.               (line 6)
* effective group ID <2>:                setgid.                (line 6)
* effective user ID:                     geteuid.               (line 6)
* effective user ID <1>:                 seteuid.               (line 6)
* effective user ID <2>:                 setuid.                (line 6)
* elapsed CPU time:                      time.                  (line 6)
* elapsed time:                          clock.                 (line 6)
* element of domain:                     lessf.                 (line 6)
* element of set:                        arb.                   (line 6)
* element of set <1>:                    from.                  (line 6)
* element of set <2>:                    less.                  (line 6)
* element of set <3>:                    with.                  (line 6)
* element of set, string, tuple:         in.                    (line 6)
* element of set, string, tuple <1>:     notin.                 (line 6)
* end of file:                           eof.                   (line 6)
* environment variable:                  getenv.                (line 6)
* environment variable <1>:              setenv.                (line 6)
* environment variable <2>:              unsetenv.              (line 6)
* eof (end-of-file indicators):          eof.                   (line 6)
* epoch:                                 clock.                 (line 6)
* epoch <1>:                             fdate.                 (line 6)
* epoch <2>:                             tod.                   (line 6)
* equalities and inequalities (=, /=):   equalities.            (line 6)
* ERE (extended regular expression):     gmark.                 (line 6)
* ERE (extended regular expression) <1>: gsub.                  (line 6)
* ERE (extended regular expression) <2>: magic.                 (line 6)
* ERE (extended regular expression) <3>: mark.                  (line 6)
* ERE (extended regular expression) <4>: set_magic.             (line 6)
* ERE (extended regular expression) <5>: split.                 (line 6)
* ERE (extended regular expression) <6>: sub.                   (line 6)
* Euclidean norm:                        abs.                   (line 6)
* even (test for integer divisible by 2): even.                 (line 6)
* event-driven programming:              select.                (line 6)
* exceptional I/O conditions:            select.                (line 6)
* exec (replace current process):        exec.                  (line 6)
* exp (natural exponential):             exp.                   (line 6)
* exponentiation:                        power.                 (line 6)
* extended regular expression (ERE):     gmark.                 (line 6)
* extended regular expression (ERE) <1>: gsub.                  (line 6)
* extended regular expression (ERE) <2>: magic.                 (line 6)
* extended regular expression (ERE) <3>: mark.                  (line 6)
* extended regular expression (ERE) <4>: set_magic.             (line 6)
* extended regular expression (ERE) <5>: split.                 (line 6)
* extended regular expression (ERE) <6>: sub.                   (line 6)
* extract arbitrary element from set:    from.                  (line 6)
* extract first element from string or tuple: fromb.            (line 6)
* extract last element from string or tuple: frome.             (line 6)
* extract leading character using character set: any.           (line 6)
* extract leading character using character set <1>: notany.    (line 6)
* extract leading substring by exact match: match.              (line 6)
* extract leading substring by length:   len.                   (line 6)
* extract leading substring using character set: break.         (line 6)
* extract leading substring using character set <1>: span.      (line 6)
* extract trailing character using character set: rany.         (line 6)
* extract trailing character using character set <1>: rnotany.  (line 6)
* extract trailing substring by exact match: rmatch.            (line 6)
* extract trailing substring by length:  rlen.                  (line 6)
* extract trailing substring using character set: rbreak.       (line 6)
* extract trailing substring using character set <1>: rspan.    (line 6)
* false (truth value):                   false.                 (line 6)
* fdate (format date and time):          fdate.                 (line 6)
* fexists (test for file existence):     fexists.               (line 6)
* file descriptor (fd):                  dup; dup2.             (line 6)
* file descriptor (fd) <1>:              filename.              (line 6)
* file descriptor (fd) <2>:              fileno.                (line 6)
* file descriptor (fd) <3>:              open.                  (line 6)
* file descriptor (fd) <4>:              recv_fd.               (line 6)
* file descriptor (fd) <5>:              select.                (line 6)
* file descriptor (fd) <6>:              send_fd.               (line 6)
* file descriptor (fd) <7>:              socketpair.            (line 6)
* file descriptor (fd) <8>:              standard streams.      (line 6)
* file mode creation mask:               Local sockets.         (line 6)
* file mode creation mask <1>:           umask.                 (line 6)
* file rename:                           rename.                (line 6)
* file size:                             fsize.                 (line 6)
* file size <1>:                         ftrunc.                (line 6)
* filename (name of stream):             filename.              (line 6)
* fileno (fd of stream):                 fileno.                (line 6)
* filepos (file position, #bytes transferred): filepos.         (line 6)
* filter (pass string through command):  filter.                (line 6)
* first element from string or tuple, extract: fromb.           (line 6)
* fix (truncate real to integer):        fix.                   (line 6)
* fixed (format with optional decimal point): fixed.            (line 6)
* float (convert to real:                float.                 (line 6)
* floating (format in scientific notation): floating.           (line 6)
* floating-point infinity:               star.                  (line 6)
* floating-point infinity <1>:           plus.                  (line 6)
* floating-point infinity <2>:           minus.                 (line 6)
* floating-point infinity <3>:           slash.                 (line 6)
* floating-point infinity <4>:           ceil.                  (line 6)
* floating-point infinity <5>:           fix.                   (line 6)
* floating-point infinity <6>:           float.                 (line 6)
* floating-point infinity <7>:           floor.                 (line 6)
* floating-point infinity <8>:           random.                (line 6)
* floating-point infinity <9>:           round.                 (line 6)
* floor (greatest integer lower bound):  floor.                 (line 6)
* flush (flush output buffer):           flush.                 (line 6)
* flush (flush output buffer) <1>:       Buffering.             (line 6)
* flush (flush output buffer) <2>:       tie.                   (line 6)
* fork (create child process):           fork.                  (line 6)
* format date and time:                  fdate.                 (line 6)
* format number as string:               fixed.                 (line 6)
* format number as string <1>:           floating.              (line 6)
* format number as string <2>:           strad.                 (line 6)
* format number as string <3>:           whole.                 (line 6)
* from (take arbitrary element from set): from.                 (line 6)
* fromb (take from beginning of string or tuple): fromb.        (line 6)
* frome (take from end of string or tuple): frome.              (line 6)
* fsize (file size):                     fsize.                 (line 6)
* ftrunc (set file size):                ftrunc.                (line 6)
* function reference:                    call.                  (line 6)
* function reference <1>:                routine.               (line 6)
* get (read lines from stdin):           get.                   (line 6)
* get number from string:                val.                   (line 6)
* get value from string:                 unstr.                 (line 6)
* get values from string:                reads.                 (line 6)
* geta (read lines from stream):         geta.                  (line 6)
* getb (read values from stream):        getb.                  (line 6)
* getc (read character from stream):     getc.                  (line 6)
* getchar (read character from stdin):   getchar.               (line 6)
* getegid (get effective group ID):      getegid.               (line 6)
* getenv (get value of environment variable): getenv.           (line 6)
* geteuid (get effective user ID):       geteuid.               (line 6)
* getfile (get file contents as string): getfile.               (line 6)
* getgid (get group ID):                 getgid.                (line 6)
* getline (read line from stream):       getline.               (line 6)
* getn (read n characters from stream):  getn.                  (line 6)
* getpgrp (get process group ID):        getpgrp.               (line 6)
* getpid (get process ID):               getpid.                (line 6)
* getppid (get parent process ID):       getppid.               (line 6)
* gets (direct-access read):             gets.                  (line 6)
* getsid (get session ID):               getsid.                (line 6)
* getuid (get real user ID):             getuid.                (line 6)
* getwd (current working directory):     getwd.                 (line 6)
* glob (pathname wildcard expansion):    glob.                  (line 6)
* gmark (find occurrences of pattern):   gmark.                 (line 6)
* greater than, etc.:                    comparatives.          (line 6)
* greatest integer below:                floor.                 (line 6)
* group ID:                              getegid.               (line 6)
* group ID <1>:                          getgid.                (line 6)
* group ID <2>:                          setegid.               (line 6)
* group ID <3>:                          setgid.                (line 6)
* gsub (replace patterns in string):     gsub.                  (line 6)
* half-close:                            shutdown.              (line 6)
* hard link:                             link.                  (line 6)
* hex (convert string to hexadecimal):   hex.                   (line 6)
* hexadecimal string:                    hex.                   (line 6)
* hexadecimal string <1>:                unhex.                 (line 6)
* host address (Internet):               hostaddr.              (line 6)
* host address (Internet) <1>:           ip_addresses.          (line 6)
* host address (Internet) <2>:           open arguments.        (line 6)
* host address (Internet) <3>:           Network sockets.       (line 6)
* host address (Internet) <4>:           peer_address.          (line 6)
* host address (Internet) <5>:           recvfrom.              (line 6)
* host address (Internet) <6>:           sendto.                (line 6)
* host name (Internet):                  filename.              (line 6)
* host name (Internet) <1>:              hostname.              (line 6)
* host name (Internet) <2>:              ip_addresses.          (line 6)
* host name (Internet) <3>:              ip_names.              (line 6)
* host name (Internet) <4>:              open arguments.        (line 6)
* host name (Internet) <5>:              Network sockets.       (line 6)
* host name (Internet) <6>:              peer_name.             (line 6)
* host name (Internet) <7>:              sendto.                (line 6)
* hostaddr (current host address):       hostaddr.              (line 6)
* hostname (current host name):          hostname.              (line 6)
* hyperbolic cosine:                     cosh.                  (line 6)
* hyperbolic sine:                       sinh.                  (line 6)
* hyperbolic tangent:                    tanh.                  (line 6)
* ichar (integer code for character):    ichar.                 (line 6)
* IEEE 754:                              star.                  (line 6)
* IEEE 754 <1>:                          power.                 (line 6)
* IEEE 754 <2>:                          plus.                  (line 6)
* IEEE 754 <3>:                          minus.                 (line 6)
* IEEE 754 <4>:                          slash.                 (line 6)
* IEEE 754 <5>:                          float.                 (line 6)
* IEEE 754 <6>:                          random.                (line 6)
* impl (implies):                        impl.                  (line 6)
* implicit conversion to string:         plus.                  (line 6)
* in (membership test; iterator form):   in.                    (line 6)
* incs (subset test):                    incs.                  (line 6)
* incs (subset test) <1>:                subset.                (line 6)
* indirect call:                         call.                  (line 6)
* indirect call <1>:                     routine.               (line 6)
* integer division:                      slash.                 (line 6)
* integer division <1>:                  div.                   (line 6)
* integer division <2>:                  intslash.              (line 6)
* integer modulus:                       mod.                   (line 6)
* integer remainder:                     rem.                   (line 6)
* integer, convert from real:            ceil.                  (line 6)
* integer, convert from real <1>:        fix.                   (line 6)
* integer, convert from real <2>:        floor.                 (line 6)
* integer, convert from real <3>:        round.                 (line 6)
* integer, convert to real:              float.                 (line 6)
* Internet address, IPv4, IPv6:          filename.              (line 6)
* Internet address, IPv4, IPv6 <1>:      hostaddr.              (line 6)
* Internet address, IPv4, IPv6 <2>:      ip_addresses.          (line 6)
* Internet address, IPv4, IPv6 <3>:      ip_names.              (line 6)
* Internet address, IPv4, IPv6 <4>:      Network sockets.       (line 6)
* Internet address, IPv4, IPv6 <5>:      peer_address.          (line 6)
* Internet address, IPv4, IPv6 <6>:      peer_sockaddr.         (line 6)
* Internet address, IPv4, IPv6 <7>:      recvfrom.              (line 6)
* Internet address, IPv4, IPv6 <8>:      sendto.                (line 6)
* Internet address, IPv4, IPv6 <9>:      sockaddr.              (line 6)
* intersection of sets:                  star.                  (line 6)
* intslash (integer quotient type switch): intslash.            (line 6)
* intslash (integer quotient type switch) <1>: set_intslash.    (line 6)
* ip_addresses (Internet host addresses): ip_addresses.         (line 6)
* ip_names (Internet host names):        ip_names.              (line 6)
* is_atom:                               type-testing.          (line 6)
* is_boolean:                            type-testing.          (line 6)
* is_integer:                            type-testing.          (line 6)
* is_map:                                type-testing.          (line 6)
* is_mmap:                               type-testing.          (line 6)
* is_numeric:                            type-testing.          (line 6)
* is_om:                                 type-testing.          (line 6)
* is_open (is a stream):                 is_open.               (line 6)
* is_real:                               type-testing.          (line 6)
* is_routine:                            type-testing.          (line 6)
* is_set:                                type-testing.          (line 6)
* is_smap:                               type-testing.          (line 6)
* is_string:                             type-testing.          (line 6)
* is_tuple:                              type-testing.          (line 6)
* is_TYPE (type testers):                type-testing.          (line 6)
* iterator:                              in.                    (line 6)
* job control:                           getsid.                (line 6)
* job control <1>:                       setctty.               (line 6)
* job control <2>:                       setpgid.               (line 6)
* job control <3>:                       setsid.                (line 6)
* job control <4>:                       tcgetpgrp.             (line 6)
* job control <5>:                       tcsetpgrp.             (line 6)
* job control <6>:                       unsetctty.             (line 6)
* join (delimited concatenation):        join.                  (line 6)
* kill (send signal to process):         kill.                  (line 6)
* last element from string or tuple, extract: frome.            (line 6)
* last_error (error message from system call): last_error.      (line 6)
* least integer above:                   ceil.                  (line 6)
* len (extract leading substring):       len.                   (line 6)
* length, string or tuple:               sharp.                 (line 6)
* less (set less given element):         less.                  (line 6)
* less than, etc.:                       comparatives.          (line 6)
* lessf (map less given domain element): lessf.                 (line 6)
* lexists (existence of file or symlink): lexists.              (line 6)
* line buffering:                        Pipes and pumps.       (line 6)
* line buffering <1>:                    tty_pump.              (line 6)
* link (create hard link):               link.                  (line 6)
* local socket:                          Local sockets.         (line 6)
* log (natural logarithm):               log.                   (line 6)
* logical operators:                     and.                   (line 6)
* logical operators <1>:                 not.                   (line 6)
* logical operators <2>:                 or.                    (line 6)
* logical operators, bitwise:            bitwise logical ops.   (line 6)
* lowercase, convert to:                 to_lower.              (line 6)
* lpad (pad string on left with blanks): lpad.                  (line 6)
* magic (recognize regular expressions): magic.                 (line 6)
* magic (recognize regular expressions) <1>: set_magic.         (line 6)
* magnitude:                             abs.                   (line 6)
* map domain:                            domain.                (line 6)
* map domain <1>:                        lessf.                 (line 6)
* map range:                             range.                 (line 6)
* mark (find first occurrence of pattern): mark.                (line 6)
* match (extract leading substring):     match.                 (line 6)
* max (maximum):                         max.                   (line 6)
* membership test:                       in.                    (line 6)
* membership test <1>:                   notin.                 (line 6)
* min (minimum):                         min.                   (line 6)
* minus (-):                             minus.                 (line 6)
* mkstemp (create and open temporary file): mkstemp.            (line 6)
* mod (modulus; symmetric set difference): mod.                 (line 6)
* mode, open:                            open arguments.        (line 6)
* modulus:                               abs.                   (line 6)
* monotonic clock:                       clock.                 (line 6)
* multiplication:                        star.                  (line 6)
* mutex:                                 link.                  (line 6)
* mutex <1>:                             symlink.               (line 6)
* name of stream:                        filename.              (line 6)
* NaN:                                   star.                  (line 6)
* NaN <1>:                               plus.                  (line 6)
* NaN <2>:                               minus.                 (line 6)
* NaN <3>:                               slash.                 (line 6)
* NaN <4>:                               equalities.            (line 6)
* NaN <5>:                               comparatives.          (line 6)
* NaN <6>:                               ceil.                  (line 6)
* NaN <7>:                               fix.                   (line 6)
* NaN <8>:                               floor.                 (line 6)
* NaN <9>:                               max.                   (line 6)
* NaN <10>:                              min.                   (line 6)
* NaN <11>:                              round.                 (line 6)
* nargs (number of arguments given by caller): nargs.           (line 6)
* natural exponential:                   exp.                   (line 6)
* natural logarithm:                     log.                   (line 6)
* nearest integer:                       round.                 (line 6)
* negation:                              minus.                 (line 6)
* newat (create new atom):               newat.                 (line 6)
* nondeterministic choice:               arb.                   (line 6)
* nondeterministic choice <1>:           from.                  (line 6)
* not (logical negation):                not.                   (line 6)
* notany (extract leading character):    notany.                (line 6)
* notin (membership test):               notin.                 (line 6)
* no_error:                              no_error.              (line 6)
* npow (all subsets of a given size):    npow.                  (line 6)
* nprint (print to stdout sans newline): nprint.                (line 6)
* nprinta (print to stream sans newline): nprinta.              (line 6)
* number of arguments given by caller:   nargs.                 (line 6)
* numeric affirmation:                   plus.                  (line 6)
* numeric comparisons:                   equalities.            (line 6)
* numeric comparisons <1>:               comparatives.          (line 6)
* numeric conversion:                    ceil.                  (line 6)
* numeric conversion <1>:                fix.                   (line 6)
* numeric conversion <2>:                float.                 (line 6)
* numeric conversion <3>:                floor.                 (line 6)
* numeric conversion <4>:                round.                 (line 6)
* odd (test for integer not divisible by 2): odd.               (line 6)
* om (the undefined value):              om.                    (line 6)
* open (open a stream):                  open.                  (line 6)
* open compatibility:                    open.                  (line 6)
* open, stream:                          is_open.               (line 6)
* operator precedence:                   Operator Precedence.   (line 6)
* or (disjunction):                      or.                    (line 6)
* order-based comparison:                comparatives.          (line 6)
* order-based comparison <1>:            max.                   (line 6)
* order-based comparison <2>:            min.                   (line 6)
* parent process:                        fork.                  (line 6)
* parent process <1>:                    getppid.               (line 6)
* passing file descriptors:              recv_fd.               (line 6)
* passing file descriptors <1>:          send_fd.               (line 6)
* pathname accessibility and existence:  fexists.               (line 6)
* pathname accessibility and existence <1>: lexists.            (line 6)
* pathname wildcard expansion:           glob.                  (line 6)
* pathname, socket:                      close.                 (line 6)
* pathname, socket <1>:                  filename.              (line 6)
* pathname, socket <2>:                  open arguments.        (line 6)
* pathname, socket <3>:                  Local sockets.         (line 6)
* pathname, socket <4>:                  recvfrom.              (line 6)
* pathname, socket <5>:                  sendto.                (line 6)
* pattern matching, regexp-based:        gmark.                 (line 6)
* pattern matching, regexp-based <1>:    gsub.                  (line 6)
* pattern matching, regexp-based <2>:    magic.                 (line 6)
* pattern matching, regexp-based <3>:    mark.                  (line 6)
* pattern matching, regexp-based <4>:    set_magic.             (line 6)
* pattern matching, regexp-based <5>:    split.                 (line 6)
* pattern matching, regexp-based <6>:    sub.                   (line 6)
* pattern matching, SNOBOL-inspired:     any.                   (line 6)
* pattern matching, SNOBOL-inspired <1>: break.                 (line 6)
* pattern matching, SNOBOL-inspired <2>: len.                   (line 6)
* pattern matching, SNOBOL-inspired <3>: match.                 (line 6)
* pattern matching, SNOBOL-inspired <4>: notany.                (line 6)
* pattern matching, SNOBOL-inspired <5>: rany.                  (line 6)
* pattern matching, SNOBOL-inspired <6>: rbreak.                (line 6)
* pattern matching, SNOBOL-inspired <7>: rlen.                  (line 6)
* pattern matching, SNOBOL-inspired <8>: rmatch.                (line 6)
* pattern matching, SNOBOL-inspired <9>: rnotany.               (line 6)
* pattern matching, SNOBOL-inspired <10>: rspan.                (line 6)
* pattern matching, SNOBOL-inspired <11>: span.                 (line 6)
* peekc (peek at next input character):  peekc.                 (line 6)
* peekchar (peek at next character in stdin): peekchar.         (line 6)
* peer_address (peer host address):      peer_address.          (line 6)
* peer_name (peer host name):            peer_name.             (line 6)
* peer_port (peer port number):          peer_port.             (line 6)
* peer_sockaddr (peer address and port number): peer_sockaddr.  (line 6)
* pexists (test for existence of processes): pexists.           (line 6)
* phase, atan2 operator:                 atan2.                 (line 6)
* pid (process ID of connected child):   pid.                   (line 6)
* pipe:                                  Pipes and pumps.       (line 6)
* pipe (create primitive pipe):          pipe.                  (line 6)
* pipe_from_child (pipe from child process): pipe_from_child.   (line 6)
* pipe_to_child (pipe to child process): pipe_to_child.         (line 6)
* piping to and from programs:           open arguments.        (line 6)
* plus (+):                              plus.                  (line 6)
* port (Internet port number):           port.                  (line 6)
* port number (Internet):                open arguments.        (line 6)
* port number (Internet) <1>:            Network sockets.       (line 6)
* port number (Internet) <2>:            peer_port.             (line 6)
* port number (Internet) <3>:            peer_sockaddr.         (line 6)
* port number (Internet) <4>:            port.                  (line 6)
* port number (Internet) <5>:            recvfrom.              (line 6)
* port number (Internet) <6>:            sendto.                (line 6)
* port number (Internet) <7>:            sockaddr.              (line 6)
* POSIX errno:                           clear_error.           (line 6)
* POSIX errno <1>:                       last_error.            (line 6)
* POSIX errno <2>:                       no_error.              (line 6)
* pow (power set):                       pow.                   (line 6)
* power (**):                            power.                 (line 6)
* power set members of a given size:     npow.                  (line 6)
* power, raise number to:                power.                 (line 6)
* precedence of operators:               Operator Precedence.   (line 6)
* pretty (printable ASCII rendering of string): pretty.         (line 6)
* print (print to stdout):               print.                 (line 6)
* print lines:                           nprint.                (line 6)
* print lines <1>:                       nprinta.               (line 6)
* printa (print to stream):              printa.                (line 6)
* printable characters:                  pretty.                (line 6)
* printable characters <1>:              unpretty.              (line 6)
* procedure reference:                   call.                  (line 6)
* procedure reference <1>:               routine.               (line 6)
* process group ID:                      getpgrp.               (line 6)
* process group ID <1>:                  kill.                  (line 6)
* process group ID <2>:                  pexists.               (line 6)
* process group ID <3>:                  setpgid.               (line 6)
* process ID (pid):                      fork.                  (line 6)
* process ID (pid) <1>:                  getpgrp.               (line 6)
* process ID (pid) <2>:                  getpid.                (line 6)
* process ID (pid) <3>:                  getppid.               (line 6)
* process ID (pid) <4>:                  getsid.                (line 6)
* process ID (pid) <5>:                  kill.                  (line 6)
* process ID (pid) <6>:                  pexists.               (line 6)
* process ID (pid) <7>:                  pid.                   (line 6)
* process ID (pid) <8>:                  setpgid.               (line 6)
* process ID (pid) <9>:                  setsid.                (line 6)
* process ID (pid) <10>:                 waitpid.               (line 6)
* process image, replace:                exec.                  (line 6)
* process, existence:                    pexists.               (line 6)
* product:                               star.                  (line 6)
* program arguments (command-line):      command_line.          (line 6)
* program name:                          command_name.          (line 6)
* pseudo-fd:                             Signal streams.        (line 6)
* pseudo-fd <1>:                         Timer streams.         (line 6)
* pseudo-random:                         random.                (line 6)
* pseudo-random <1>:                     setrandom.             (line 6)
* pseudo-terminal (pty):                 Pipes and pumps.       (line 6)
* pseudo-terminal (pty) <1>:             setctty.               (line 6)
* pseudo-terminal (pty) <2>:             tty_pump.              (line 6)
* pump:                                  open arguments.        (line 6)
* pump <1>:                              Pipes and pumps.       (line 6)
* pump (bidirectional stream to child process): pump.           (line 6)
* push characters back into stream:      ungetc.                (line 6)
* put (write lines to stdout):           put.                   (line 6)
* puta (write lines to stream):          puta.                  (line 6)
* putb (write values to stream):         putb.                  (line 6)
* putc (write characters to stream):     putc.                  (line 6)
* putchar (write characters to stdout):  putchar.               (line 6)
* putfile (write characters to stream):  putfile.               (line 6)
* putline (write lines to stream):       putline.               (line 6)
* puts (direct-access write):            puts.                  (line 6)
* query (?):                             query.                 (line 6)
* quotient:                              slash.                 (line 6)
* quotient <1>:                          div.                   (line 6)
* quotient <2>:                          intslash.              (line 6)
* radix-prefixed number:                 strad.                 (line 6)
* raise number to power:                 power.                 (line 6)
* random (numbers and selections):       random.                (line 6)
* random access:                         gets.                  (line 6)
* random access <1>:                     mkstemp.               (line 6)
* random access <2>:                     open arguments.        (line 6)
* random access <3>:                     puts.                  (line 6)
* random access <4>:                     seek.                  (line 6)
* range (map range):                     range.                 (line 6)
* rany (extract trailing character):     rany.                  (line 6)
* rbreak (extract trailing substring):   rbreak.                (line 6)
* read (get values from stdin):          read.                  (line 6)
* read character:                        getc.                  (line 6)
* read character <1>:                    getchar.               (line 6)
* read characters:                       getfile.               (line 6)
* read line:                             getline.               (line 6)
* read lines:                            get.                   (line 6)
* read lines <1>:                        geta.                  (line 6)
* read n characters:                     getn.                  (line 6)
* read number from string:               unstr.                 (line 6)
* read number from string <1>:           val.                   (line 6)
* read value from string:                unstr.                 (line 6)
* read values:                           getb.                  (line 6)
* read values <1>:                       read.                  (line 6)
* read values <2>:                       reada.                 (line 6)
* read values from string:               reads.                 (line 6)
* read, low-level:                       sys_read.              (line 6)
* reada (get values from stream):        reada.                 (line 6)
* readlink (symbolic link referent):     readlink.              (line 6)
* reads (read values from string):       reads.                 (line 6)
* real division:                         slash.                 (line 6)
* real division <1>:                     intslash.              (line 6)
* real group ID:                         getgid.                (line 6)
* real group ID <1>:                     setgid.                (line 6)
* real time:                             clock.                 (line 6)
* real time <1>:                         open arguments.        (line 6)
* real time <2>:                         Timer streams.         (line 6)
* real user ID:                          getuid.                (line 6)
* real user ID <1>:                      setuid.                (line 6)
* real, convert from integer:            float.                 (line 6)
* real, convert to integer:              ceil.                  (line 6)
* real, convert to integer <1>:          fix.                   (line 6)
* real, convert to integer <2>:          floor.                 (line 6)
* real, convert to integer <3>:          round.                 (line 6)
* reap termination status:               close.                 (line 6)
* reap termination status <1>:           filter.                (line 6)
* reap termination status <2>:           system.                (line 6)
* reap termination status <3>:           waitpid.               (line 6)
* recv (receive on UDP client socket):   Network sockets.       (line 6)
* recv (receive on UDP client socket) <1>: recv.                (line 6)
* recvfrom (receive datagram on server socket): recvfrom.       (line 6)
* recvfrom (receive on datagram server socket): Network sockets.
                                                                (line 6)
* recvfrom (receive on datagram server socket) <1>: Local sockets.
                                                                (line 6)
* recv_fd (receive file descriptor):     recv_fd.               (line 6)
* regular expression:                    gmark.                 (line 6)
* regular expression <1>:                gsub.                  (line 6)
* regular expression <2>:                magic.                 (line 6)
* regular expression <3>:                mark.                  (line 6)
* regular expression <4>:                set_magic.             (line 6)
* regular expression <5>:                split.                 (line 6)
* regular expression <6>:                sub.                   (line 6)
* relational operators:                  equalities.            (line 6)
* relational operators <1>:              comparatives.          (line 6)
* rem (integer remainder):               rem.                   (line 6)
* remove arbitrary element from set:     from.                  (line 6)
* remove first element from string or tuple: fromb.             (line 6)
* remove last element from string or tuple: frome.              (line 6)
* rename (rename file):                  rename.                (line 6)
* replace process image:                 exec.                  (line 6)
* replication, string or tuple:          star.                  (line 6)
* restricted mode:                       Restricted Mode.       (line 6)
* reverse (reverse string):              reverse.               (line 6)
* rewind (rewind direct-access stream):  rewind.                (line 6)
* rlen (extract trailing substring):     rlen.                  (line 6)
* rmatch (extract trailing substring):   rmatch.                (line 6)
* rnotany (extract trailing character):  rnotany.               (line 6)
* round (round to nearest integer):      round.                 (line 6)
* routine (create procedure reference):  routine.               (line 6)
* rpad (pad string on right with blanks): rpad.                 (line 6)
* rspan (extract trailing substring):    rspan.                 (line 6)
* run command from within program:       filter.                (line 6)
* run command from within program <1>:   open arguments.        (line 6)
* run command from within program <2>:   Pipes and pumps.       (line 6)
* run command from within program <3>:   system.                (line 6)
* saved user ID:                         setuid.                (line 6)
* scientific notation:                   floating.              (line 6)
* seed, pseudo-random number generation: setrandom.             (line 6)
* seek (reposition direct-access stream): seek.                 (line 6)
* seekable (direct access):              gets.                  (line 6)
* seekable (direct access) <1>:          mkstemp.               (line 6)
* seekable (direct access) <2>:          open arguments.        (line 6)
* seekable (direct access) <3>:          puts.                  (line 6)
* seekable (direct access) <4>:          seek.                  (line 6)
* seek_set, seek_cur, seek_end:          seek constants.        (line 6)
* select (wait for event or timeout):    select.                (line 6)
* send (send datagram on client socket): send.                  (line 6)
* send (send on datagram client socket): Network sockets.       (line 6)
* send (send on datagram client socket) <1>: Local sockets.     (line 6)
* sendto (send datagram on server socket): sendto.              (line 6)
* sendto (send on datagram server socket): Network sockets.     (line 6)
* sendto (send on datagram server socket) <1>: Local sockets.   (line 6)
* send_fd (send file descriptor):        send_fd.               (line 6)
* server socket:                         accept.                (line 6)
* server socket <1>:                     open arguments.        (line 6)
* server socket <2>:                     Network sockets.       (line 6)
* server socket <3>:                     Local sockets.         (line 6)
* server socket <4>:                     recvfrom.              (line 6)
* server socket <5>:                     sendto.                (line 6)
* service name (Internet):               open arguments.        (line 6)
* service name (Internet) <1>:           Network sockets.       (line 6)
* service name (Internet) <2>:           sendto.                (line 6)
* session ID:                            getsid.                (line 6)
* session ID <1>:                        setsid.                (line 6)
* set difference:                        minus.                 (line 6)
* set element choice:                    arb.                   (line 6)
* set element choice <1>:                from.                  (line 6)
* set intersection:                      star.                  (line 6)
* set less given element:                less.                  (line 6)
* set membership:                        in.                    (line 6)
* set membership <1>:                    notin.                 (line 6)
* set plus one element:                  with.                  (line 6)
* set union:                             plus.                  (line 6)
* set, number of members:                sharp.                 (line 6)
* setctty (acquire controlling terminal): setctty.              (line 6)
* setegid (set effective group ID):      setegid.               (line 6)
* setenv (set environment variable):     setenv.                (line 6)
* seteuid (set effective user ID):       seteuid.               (line 6)
* setgid (set group ID):                 setgid.                (line 6)
* setl command:                          command_name.          (line 6)
* SETL2:                                 slash.                 (line 6)
* SETL2 <1>:                             callout.               (line 6)
* SETL2 <2>:                             get.                   (line 6)
* SETL2 <3>:                             intslash.              (line 6)
* SETL2 <4>:                             open.                  (line 6)
* SETL2 <5>:                             put.                   (line 6)
* setpgid (set process group ID):        setpgid.               (line 6)
* setrandom (set random seed):           setrandom.             (line 6)
* setsid (create new session):           setsid.                (line 6)
* setuid (set user ID):                  setuid.                (line 6)
* set_intslash (integer quotient type):  intslash.              (line 6)
* set_intslash (integer quotient type) <1>: set_intslash.       (line 6)
* set_magic (regular expression recognition): set_magic.        (line 6)
* sharp (#):                             sharp.                 (line 6)
* short-circuiting operators:            query.                 (line 6)
* short-circuiting operators <1>:        and.                   (line 6)
* short-circuiting operators <2>:        or.                    (line 6)
* shutdown (close I/O in one or both directions): shutdown.     (line 6)
* shut_rd, shut_wr, shut_rdwr:           shutdown constants.    (line 6)
* SIGALRM:                               Signal streams.        (line 6)
* SIGCHLD:                               Signal streams.        (line 6)
* sign (sign of number):                 sign.                  (line 6)
* signal:                                kill.                  (line 6)
* signal stream:                         open arguments.        (line 6)
* signal stream <1>:                     Signal streams.        (line 6)
* sin (sine):                            sin.                   (line 6)
* sinh (hyperbolic sine):                sinh.                  (line 6)
* size of file:                          fsize.                 (line 6)
* size of file <1>:                      ftrunc.                (line 6)
* size of set:                           sharp.                 (line 6)
* slash (/):                             slash.                 (line 6)
* SNOBOL-inspired pattern matching:      any.                   (line 6)
* SNOBOL-inspired pattern matching <1>:  break.                 (line 6)
* SNOBOL-inspired pattern matching <2>:  len.                   (line 6)
* SNOBOL-inspired pattern matching <3>:  match.                 (line 6)
* SNOBOL-inspired pattern matching <4>:  notany.                (line 6)
* SNOBOL-inspired pattern matching <5>:  rany.                  (line 6)
* SNOBOL-inspired pattern matching <6>:  rbreak.                (line 6)
* SNOBOL-inspired pattern matching <7>:  rlen.                  (line 6)
* SNOBOL-inspired pattern matching <8>:  rmatch.                (line 6)
* SNOBOL-inspired pattern matching <9>:  rnotany.               (line 6)
* SNOBOL-inspired pattern matching <10>: rspan.                 (line 6)
* SNOBOL-inspired pattern matching <11>: span.                  (line 6)
* sockaddr (Internet address and port number): sockaddr.        (line 6)
* socket:                                accept.                (line 6)
* socket <1>:                            open arguments.        (line 6)
* socket <2>:                            Network sockets.       (line 6)
* socket <3>:                            Local sockets.         (line 6)
* socket <4>:                            peer_address.          (line 6)
* socket <5>:                            peer_name.             (line 6)
* socket <6>:                            peer_port.             (line 6)
* socket <7>:                            peer_sockaddr.         (line 6)
* socket <8>:                            port.                  (line 6)
* socket <9>:                            recv.                  (line 6)
* socket <10>:                           recvfrom.              (line 6)
* socket <11>:                           send.                  (line 6)
* socket <12>:                           sendto.                (line 6)
* socket <13>:                           sockaddr.              (line 6)
* socketpair:                            Pipes and pumps.       (line 6)
* socketpair <1>:                        pump.                  (line 6)
* socketpair (create bidirectional local channel): socketpair.  (line 6)
* span (extract leading substring):      span.                  (line 6)
* split (split string into tuple):       split.                 (line 6)
* sqrt (square root):                    sqrt.                  (line 6)
* star (*):                              star.                  (line 6)
* status (child process status):         status.                (line 6)
* status, child process:                 close.                 (line 6)
* status, child process <1>:             filter.                (line 6)
* status, child process <2>:             system.                (line 6)
* status, child process <3>:             waitpid.               (line 6)
* stderr (standard error output):        Predefined streams.    (line 6)
* stderr (standard error output) <1>:    standard streams.      (line 6)
* stdin (standard input):                Predefined streams.    (line 6)
* stdin (standard input) <1>:            standard streams.      (line 6)
* stdout (standard output):              Predefined streams.    (line 6)
* stdout (standard output) <1>:          standard streams.      (line 6)
* str (string representation of value):  str.                   (line 6)
* strad (integer as radix-prefixed string): strad.              (line 6)
* stream buffering:                      flush.                 (line 6)
* stream buffering <1>:                  Buffering.             (line 6)
* stream handle:                         open.                  (line 6)
* stream, open:                          is_open.               (line 6)
* string concatenation:                  star.                  (line 6)
* string concatenation <1>:              plus.                  (line 6)
* string length:                         sharp.                 (line 6)
* string membership:                     in.                    (line 6)
* string membership <1>:                 notin.                 (line 6)
* string padding:                        lpad.                  (line 6)
* string padding <1>:                    rpad.                  (line 6)
* string replication:                    star.                  (line 6)
* string splitting:                      split.                 (line 6)
* string substitution:                   gsub.                  (line 6)
* string substitution <1>:               sub.                   (line 6)
* sub (replace pattern in string):       sub.                   (line 6)
* subnormal:                             star.                  (line 6)
* subnormal <1>:                         plus.                  (line 6)
* subnormal <2>:                         minus.                 (line 6)
* subnormal <3>:                         slash.                 (line 6)
* subset (subset test):                  incs.                  (line 6)
* subset (subset test) <1>:              subset.                (line 6)
* subtraction:                           minus.                 (line 6)
* sum:                                   plus.                  (line 6)
* symbolic link:                         fexists.               (line 6)
* symbolic link <1>:                     lexists.               (line 6)
* symbolic link <2>:                     readlink.              (line 6)
* symbolic link <3>:                     symlink.               (line 6)
* symlink (create symbolic link):        symlink.               (line 6)
* symmetric set difference:              mod.                   (line 6)
* system (run command in subshell):      system.                (line 6)
* system call errors:                    clear_error.           (line 6)
* system call errors <1>:                last_error.            (line 6)
* system call errors <2>:                no_error.              (line 6)
* sys_read (low-level read):             sys_read.              (line 6)
* sys_write (low-level write):           sys_write.             (line 6)
* take arbitrary element from set:       from.                  (line 6)
* take first element from string or tuple: fromb.               (line 6)
* take last element from string or tuple: frome.                (line 6)
* tan (tangent):                         tan.                   (line 6)
* tanh (hyperbolic tangent):             tanh.                  (line 6)
* tcgetpgrp (get foreground process group ID): tcgetpgrp.       (line 6)
* TCP:                                   accept.                (line 6)
* TCP <1>:                               open arguments.        (line 6)
* TCP <2>:                               Network sockets.       (line 6)
* TCP <3>:                               peer_port.             (line 6)
* TCP <4>:                               peer_sockaddr.         (line 6)
* TCP <5>:                               port.                  (line 6)
* TCP <6>:                               shutdown.              (line 6)
* TCP <7>:                               sockaddr.              (line 6)
* tcsetpgrp (put process group into foreground): tcsetpgrp.     (line 6)
* temporary filename, unique:            mkstemp.               (line 6)
* terminal, controlling:                 setctty.               (line 6)
* terminal, controlling <1>:             unsetctty.             (line 6)
* termination status, child process:     close.                 (line 6)
* termination status, child process <1>: filter.                (line 6)
* termination status, child process <2>: status.                (line 6)
* termination status, child process <3>: system.                (line 6)
* termination status, child process <4>: waitpid.               (line 6)
* test for being a stream:               is_open.               (line 6)
* testing type:                          type-testing.          (line 6)
* tie (flush output upon input elsewhere): Buffering.           (line 6)
* tie (flush output upon input elsewhere) <1>: tie.             (line 6)
* time (elapsed CPU time in ms):         time.                  (line 6)
* time of day:                           date.                  (line 6)
* time of day <1>:                       fdate.                 (line 6)
* time of day <2>:                       tod.                   (line 6)
* time, real:                            clock.                 (line 6)
* timer stream:                          open arguments.        (line 6)
* timer stream <1>:                      Timer streams.         (line 6)
* tod (calendar time in ms):             tod.                   (line 6)
* to_lower (convert to lowercase):       to_lower.              (line 6)
* to_upper (convert to uppercase):       to_upper.              (line 6)
* true (truth value):                    true.                  (line 6)
* truncation, numeric:                   fix.                   (line 6)
* truth table:                           impl.                  (line 6)
* tty-pump:                              open arguments.        (line 6)
* tty-pump <1>:                          Pipes and pumps.       (line 6)
* tuple concatenation:                   star.                  (line 6)
* tuple concatenation <1>:               plus.                  (line 6)
* tuple membership:                      in.                    (line 6)
* tuple membership <1>:                  notin.                 (line 6)
* tuple replication:                     star.                  (line 6)
* tuple, length:                         sharp.                 (line 6)
* type (type of SETL value):             type.                  (line 6)
* type of value unstr will yield:        denotype.              (line 6)
* type, checking:                        type-testing.          (line 6)
* UDP:                                   open arguments.        (line 6)
* UDP <1>:                               Network sockets.       (line 6)
* UDP <2>:                               peer_port.             (line 6)
* UDP <3>:                               peer_sockaddr.         (line 6)
* UDP <4>:                               port.                  (line 6)
* UDP <5>:                               recv.                  (line 6)
* UDP <6>:                               recvfrom.              (line 6)
* UDP <7>:                               send.                  (line 6)
* UDP <8>:                               sendto.                (line 6)
* UDP <9>:                               sockaddr.              (line 6)
* umask (set file mode creation mask):   umask.                 (line 6)
* undefined:                             om.                    (line 6)
* ungetc (push characters back into stream): ungetc.            (line 6)
* ungetchar (push characters back into stdin): ungetchar.       (line 6)
* unhex (convert from hexadecimal):      unhex.                 (line 6)
* uninitialized SETL variable:           om.                    (line 6)
* union of sets:                         plus.                  (line 6)
* unique temporary filename:             mkstemp.               (line 6)
* Unix-domain socket:                    accept.                (line 6)
* Unix-domain socket <1>:                filename.              (line 6)
* Unix-domain socket <2>:                open arguments.        (line 6)
* Unix-domain socket <3>:                Local sockets.         (line 6)
* Unix-domain socket <4>:                Pipes and pumps.       (line 6)
* Unix-domain socket <5>:                pump.                  (line 6)
* Unix-domain socket <6>:                recvfrom.              (line 6)
* Unix-domain socket <7>:                recv_fd.               (line 6)
* Unix-domain socket <8>:                send.                  (line 6)
* Unix-domain socket <9>:                sendto.                (line 6)
* Unix-domain socket <10>:               send_fd.               (line 6)
* Unix-domain socket <11>:               socketpair.            (line 6)
* unlink (destroy file reference):       unlink.                (line 6)
* unpretty (convert string from pretty form): unpretty.         (line 6)
* unsetctty (relinquish controlling terminal): unsetctty.       (line 6)
* unsetenv (remove environment variable): unsetenv.             (line 6)
* unstr (read value from string):        unstr.                 (line 6)
* uppercase, convert to:                 to_upper.              (line 6)
* user ID:                               geteuid.               (line 6)
* user ID <1>:                           getuid.                (line 6)
* user ID <2>:                           seteuid.               (line 6)
* user ID <3>:                           setuid.                (line 6)
* UTC:                                   fdate.                 (line 6)
* val (read number from string):         val.                   (line 6)
* variable number of arguments:          nargs.                 (line 6)
* wait (wait for any child process status change): wait.        (line 6)
* waitpid (wait for child process status change): waitpid.      (line 6)
* whitespace:                            getb.                  (line 6)
* whitespace <1>:                        reada.                 (line 6)
* whitespace <2>:                        split.                 (line 6)
* whitespace <3>:                        unstr.                 (line 6)
* whole (format integer):                whole.                 (line 6)
* wildcard expansion, pathname:          glob.                  (line 6)
* with (set plus one element):           with.                  (line 6)
* working directory, current:            chdir.                 (line 6)
* working directory, current <1>:        getwd.                 (line 6)
* write (write values to stdout):        write.                 (line 6)
* write characters:                      putc.                  (line 6)
* write characters <1>:                  putchar.               (line 6)
* write characters <2>:                  putfile.               (line 6)
* write lines:                           put.                   (line 6)
* write lines <1>:                       puta.                  (line 6)
* write lines <2>:                       putline.               (line 6)
* write values:                          putb.                  (line 6)
* write values <1>:                      write.                 (line 6)
* write values <2>:                      writea.                (line 6)
* write, low-level:                      sys_write.             (line 6)
* writea (write values to stream):       writea.                (line 6)
* zombie process:                        close.                 (line 6)
* zombie process <1>:                    waitpid.               (line 6)



Tag Table:
Node: Top227
Node: Overview1073
Node: The Library1517
Node: sharp15216
Node: star15621
Node: power17071
Node: plus18237
Node: minus20763
Node: slash21828
Node: equalities23271
Node: comparatives23849
Node: query25453
Node: abs25935
Node: accept26583
Node: acos27588
Node: and27870
Node: any28821
Node: arb29799
Node: asin30144
Node: atan30420
Node: atan230674
Node: bitwise logical ops31459
Node: break32088
Node: call32857
Node: callout33489
Node: ceil34386
Node: char34906
Node: chdir35403
Node: clear_error36260
Node: clock36760
Node: close37212
Node: close constants41138
Node: command_line41525
Node: command_name41899
Node: cos42936
Node: cosh43168
Node: date43415
Node: denotype43671
Node: div44220
Node: domain44624
Node: dup; dup245001
Node: eof46368
Node: even49427
Node: exec49917
Node: exp52511
Node: false52828
Node: fdate53091
Node: fexists54224
Node: filename55225
Node: fileno57433
Node: filepos58204
Node: filter59218
Node: fix61465
Node: fixed61984
Node: float62985
Node: floating63967
Node: floor65118
Node: flush65643
Node: fork66447
Node: from67876
Node: fromb68436
Node: frome68992
Node: fsize69536
Node: ftrunc70478
Node: get71343
Node: geta71800
Node: getb73206
Node: getc74592
Node: getchar75801
Node: getegid76043
Node: getenv76437
Node: geteuid76810
Node: getfile77202
Node: getgid78880
Node: getline79343
Node: getn80767
Node: getpgrp81623
Node: getpid82039
Node: getppid82393
Node: gets82667
Node: getsid83895
Node: getuid84410
Node: getwd84786
Node: glob85042
Node: gmark85679
Node: gsub86552
Node: hex87510
Node: hostaddr87889
Node: hostname88711
Node: ichar89184
Node: impl89567
Node: in90476
Node: incs91848
Node: intslash92245
Node: ip_addresses92768
Node: ip_names93689
Node: type-testing94630
Node: is_open95937
Node: join96927
Node: kill97576
Node: last_error99414
Node: len100166
Node: less100719
Node: lessf101054
Node: lexists101459
Node: link102446
Node: log103265
Node: lpad103519
Node: magic103964
Node: mark104743
Node: match106606
Node: max107219
Node: min108447
Node: mkstemp109556
Node: mod110494
Node: nargs111555
Node: newat112032
Node: no_error112682
Node: not113022
Node: notany113563
Node: notin114229
Node: npow114546
Node: nprint114991
Node: nprinta115316
Node: odd116167
Node: om116456
Node: open117134
Node: open arguments119122
Node: Network sockets124407
Node: Local sockets127679
Node: Pipes and pumps130479
Node: Signal streams132729
Node: Timer streams138033
Node: Predefined streams138840
Node: Automatic opening140063
Node: Buffering142494
Node: open apocrypha148690
Node: or152406
Node: peekc153028
Node: peekchar153716
Node: peer_address153981
Node: peer_name154903
Node: peer_port155679
Node: peer_sockaddr156364
Node: pexists157138
Node: pid158027
Node: pipe158762
Node: pipe_from_child159130
Node: pipe_to_child159748
Node: port160350
Node: pow160951
Node: pretty161225
Node: print162523
Node: printa162795
Node: pump163470
Node: put164998
Node: puta165453
Node: putb165997
Node: putc166805
Node: putchar167258
Node: putfile167536
Node: putline168450
Node: puts169010
Node: random170290
Node: range172165
Node: rany172520
Node: rbreak173184
Node: rlen173957
Node: rmatch174516
Node: rnotany175121
Node: rspan175793
Node: read176486
Node: reada176769
Node: readlink178541
Node: reads179265
Node: recv179812
Node: recvfrom180712
Node: recv_fd182229
Node: rem183762
Node: rename184435
Node: reverse184803
Node: rewind185018
Node: round185254
Node: routine185788
Node: rpad186565
Node: seek187016
Node: seek constants188980
Node: select189317
Node: send195196
Node: sendto195854
Node: send_fd197208
Node: setctty199083
Node: setegid200878
Node: setenv201294
Node: seteuid201856
Node: setgid202268
Node: setpgid202661
Node: setrandom204020
Node: setsid204486
Node: setuid205405
Node: set_intslash207308
Node: set_magic207712
Node: shutdown208079
Node: shutdown constants209557
Node: sign209909
Node: sin210214
Node: sinh210434
Node: sockaddr210659
Node: socketpair211680
Node: span213312
Node: split214003
Node: sqrt215053
Node: status215271
Node: standard streams217566
Node: str217963
Node: strad219675
Node: sub220698
Node: subset222403
Node: symlink222743
Node: system223823
Node: sys_read225775
Node: sys_write226415
Node: tan227015
Node: tanh227290
Node: tcgetpgrp227520
Node: tcsetpgrp228140
Node: tie229395
Node: time230256
Node: to_lower230848
Node: to_upper231200
Node: tod231551
Node: true231911
Node: tty_pump232297
Node: type232907
Node: umask233258
Node: ungetc234340
Node: ungetchar235321
Node: unhex235590
Node: unlink235959
Node: unpretty236583
Node: unsetctty239028
Node: unsetenv239726
Node: unstr240134
Node: untie241909
Node: val242171
Node: wait242743
Node: waitpid243071
Node: whole245645
Node: with246505
Node: write246807
Node: writea247091
Node: Operator Precedence247932
Node: Restricted Mode250239
Node: Index252204

End Tag Table


Local Variables:
coding: utf-8
End:
