<!-- $Id: lib.html,v 1.4 2007/11/07 04:01:19 bacon Exp $ -->
<HTML>
<HEAD>
<TITLE>The SETL Library</TITLE>
</HEAD>

<BODY>

<H1>The SETL Library of Built-Ins</H1>

This documents the standard operators,
functions, and procedures, collectively called ``intrinsics'' or
``built-ins'', that help make SETL useful as well as elegant.<p>

<H2>
<A name="multicol">Index to the intrinsics</A>
</H2>

[Later I should extend this table to include all the words that are
``reserved'' in the default stropping mode, even those which are
obsolescent (and therefore will lack hyperlinks).  For now, this table
just lists the routines (and ``sysvars'' and ``sysvals'').]
<p>

<!-- The part between (but not including) <TABLE> and </TABLE> is
     generated by table.setl  -->
<TABLE>
<TR> <TD><A HREF="##"><b>#</b></A></TD>                <TD><A HREF="#floating"><b>floating</b></A></TD>  <TD><A HREF="#not"><b>not</b></A></TD>            <TD><A HREF="#send"><b>send</b></A></TD>          </TR>
<TR> <TD><A HREF="#*"><b>*</b></A></TD>                <TD><A HREF="#floor"><b>floor</b></A></TD>        <TD><A HREF="#notany"><b>notany</b></A></TD>      <TD><A HREF="#sendto"><b>sendto</b></A></TD>      </TR>
<TR> <TD><A HREF="#**"><b>**</b></A></TD>              <TD><A HREF="#flush"><b>flush</b></A></TD>        <TD><A HREF="#notin"><b>notin</b></A></TD>        <TD><A HREF="#send_fd"><b>send_fd</b></A></TD>    </TR>
<TR> <TD><A HREF="#+"><b>+</b></A></TD>                <TD><A HREF="#fork"><b>fork</b></A></TD>          <TD><A HREF="#npow"><b>npow</b></A></TD>          <TD><A HREF="#setenv"><b>setenv</b></A></TD>      </TR>
<TR> <TD><A HREF="#-"><b>-</b></A></TD>                <TD><A HREF="#from"><b>from</b></A></TD>          <TD><A HREF="#nprint"><b>nprint</b></A></TD>      <TD><A HREF="#setgid"><b>setgid</b></A></TD>      </TR>
<TR> <TD><A HREF="#/"><b>/</b></A></TD>                <TD><A HREF="#fromb"><b>fromb</b></A></TD>        <TD><A HREF="#nprinta"><b>nprinta</b></A></TD>    <TD><A HREF="#setpgrp"><b>setpgrp</b></A></TD>    </TR>
<TR> <TD><A HREF="#="><b>=</b></A></TD>                <TD><A HREF="#frome"><b>frome</b></A></TD>        <TD><A HREF="#odd"><b>odd</b></A></TD>            <TD><A HREF="#setrandom"><b>setrandom</b></A></TD> </TR>
<TR> <TD><A HREF="#/="><b>/=</b></A></TD>              <TD><A HREF="#fsize"><b>fsize</b></A></TD>        <TD><A HREF="#om"><b>om</b></A></TD>              <TD><A HREF="#setuid"><b>setuid</b></A></TD>      </TR>
<TR> <TD><A HREF="#&lt;"><b>&lt;</b></A></TD>          <TD><A HREF="#get"><b>get</b></A></TD>            <TD><A HREF="#open"><b>open</b></A></TD>          <TD><A HREF="#set_intslash"><b>set_intslash</b></A></TD> </TR>
<TR> <TD><A HREF="#&gt;"><b>&gt;</b></A></TD>          <TD><A HREF="#geta"><b>geta</b></A></TD>          <TD><A HREF="#or"><b>or</b></A></TD>              <TD><A HREF="#set_magic"><b>set_magic</b></A></TD> </TR>
<TR> <TD><A HREF="#&lt;="><b>&lt;=</b></A></TD>        <TD><A HREF="#getb"><b>getb</b></A></TD>          <TD><A HREF="#pack_..."><b>pack_...</b></A></TD>  <TD><A HREF="#shutdown"><b>shutdown</b></A></TD>  </TR>
<TR> <TD><A HREF="#&gt;="><b>&gt;=</b></A></TD>        <TD><A HREF="#getc"><b>getc</b></A></TD>          <TD><A HREF="#peekc"><b>peekc</b></A></TD>        <TD><A HREF="#shut_rd"><b>shut_rd</b></A></TD>    </TR>
<TR> <TD><A HREF="#query"><b>?</b></A></TD>                <TD><A HREF="#getchar"><b>getchar</b></A></TD>    <TD><A HREF="#peekchar"><b>peekchar</b></A></TD>  <TD><A HREF="#shut_wr"><b>shut_wr</b></A></TD>    </TR>
<TR> <TD><A HREF="#abs"><b>abs</b></A></TD>            <TD><A HREF="#getegid"><b>getegid</b></A></TD>    <TD><A HREF="#peer_address"><b>peer_address</b></A></TD> <TD><A HREF="#shut_rdwr"><b>shut_rdwr</b></A></TD> </TR>
<TR> <TD><A HREF="#accept"><b>accept</b></A></TD>      <TD><A HREF="#getenv"><b>getenv</b></A></TD>      <TD><A HREF="#peer_name"><b>peer_name</b></A></TD> <TD><A HREF="#sign"><b>sign</b></A></TD>          </TR>
<TR> <TD><A HREF="#acos"><b>acos</b></A></TD>          <TD><A HREF="#geteuid"><b>geteuid</b></A></TD>    <TD><A HREF="#peer_port"><b>peer_port</b></A></TD> <TD><A HREF="#sin"><b>sin</b></A></TD>            </TR>
<TR> <TD><A HREF="#and"><b>and</b></A></TD>            <TD><A HREF="#getfile"><b>getfile</b></A></TD>    <TD><A HREF="#pexists"><b>pexists</b></A></TD>    <TD><A HREF="#sinh"><b>sinh</b></A></TD>          </TR>
<TR> <TD><A HREF="#any"><b>any</b></A></TD>            <TD><A HREF="#getgid"><b>getgid</b></A></TD>      <TD><A HREF="#pid"><b>pid</b></A></TD>            <TD><A HREF="#span"><b>span</b></A></TD>          </TR>
<TR> <TD><A HREF="#arb"><b>arb</b></A></TD>            <TD><A HREF="#getline"><b>getline</b></A></TD>    <TD><A HREF="#pipe"><b>pipe</b></A></TD>          <TD><A HREF="#split"><b>split</b></A></TD>        </TR>
<TR> <TD><A HREF="#asin"><b>asin</b></A></TD>          <TD><A HREF="#getn"><b>getn</b></A></TD>          <TD><A HREF="#pipe_from_child"><b>pipe_from_child</b></A></TD> <TD><A HREF="#sqrt"><b>sqrt</b></A></TD>          </TR>
<TR> <TD><A HREF="#atan"><b>atan</b></A></TD>          <TD><A HREF="#getpgrp"><b>getpgrp</b></A></TD>    <TD><A HREF="#pipe_to_child"><b>pipe_to_child</b></A></TD> <TD><A HREF="#status"><b>status</b></A></TD>      </TR>
<TR> <TD><A HREF="#atan2"><b>atan2</b></A></TD>        <TD><A HREF="#gets"><b>gets</b></A></TD>          <TD><A HREF="#port"><b>port</b></A></TD>          <TD><A HREF="#std..."><b>stdin</b></A></TD>        </TR>
<TR> <TD><A HREF="#bit_and"><b>bit_and</b></A></TD>    <TD><A HREF="#getuid"><b>getuid</b></A></TD>      <TD><A HREF="#pow"><b>pow</b></A></TD>            <TD><A HREF="#std..."><b>stdout</b></A></TD>      </TR>
<TR> <TD><A HREF="#bit_not"><b>bit_not</b></A></TD>    <TD><A HREF="#getwd"><b>getwd</b></A></TD>        <TD><A HREF="#pretty"><b>pretty</b></A></TD>      <TD><A HREF="#std..."><b>stderr</b></A></TD>      </TR>
<TR> <TD><A HREF="#bit_or"><b>bit_or</b></A></TD>      <TD><A HREF="#gmark"><b>gmark</b></A></TD>        <TD><A HREF="#print"><b>print</b></A></TD>        <TD><A HREF="#store_..."><b>store_...</b></A></TD> </TR>
<TR> <TD><A HREF="#bit_xor"><b>bit_xor</b></A></TD>    <TD><A HREF="#gsub"><b>gsub</b></A></TD>          <TD><A HREF="#printa"><b>printa</b></A></TD>      <TD><A HREF="#str"><b>str</b></A></TD>            </TR>
<TR> <TD><A HREF="#break"><b>break</b></A></TD>        <TD><A HREF="#hex"><b>hex</b></A></TD>            <TD><A HREF="#pump"><b>pump</b></A></TD>          <TD><A HREF="#strad"><b>strad</b></A></TD>        </TR>
<TR> <TD><A HREF="#call"><b>call</b></A></TD>          <TD><A HREF="#hostaddr"><b>hostaddr</b></A></TD>  <TD><A HREF="#put"><b>put</b></A></TD>            <TD><A HREF="#sub"><b>sub</b></A></TD>            </TR>
<TR> <TD><A HREF="#callout"><b>callout</b></A></TD>    <TD><A HREF="#hostname"><b>hostname</b></A></TD>  <TD><A HREF="#puta"><b>puta</b></A></TD>          <TD><A HREF="#subset"><b>subset</b></A></TD>      </TR>
<TR> <TD><A HREF="#ceil"><b>ceil</b></A></TD>          <TD><A HREF="#ichar"><b>ichar</b></A></TD>        <TD><A HREF="#putb"><b>putb</b></A></TD>          <TD><A HREF="#symlink"><b>symlink</b></A></TD>    </TR>
<TR> <TD><A HREF="#char"><b>char</b></A></TD>          <TD><A HREF="#impl"><b>impl</b></A></TD>          <TD><A HREF="#putc"><b>putc</b></A></TD>          <TD><A HREF="#system"><b>system</b></A></TD>      </TR>
<TR> <TD><A HREF="#chdir"><b>chdir</b></A></TD>        <TD><A HREF="#in"><b>in</b></A></TD>              <TD><A HREF="#putchar"><b>putchar</b></A></TD>    <TD><A HREF="#sys_read"><b>sys_read</b></A></TD>  </TR>
<TR> <TD><A HREF="#clear_error"><b>clear_error</b></A></TD> <TD><A HREF="#incs"><b>incs</b></A></TD>          <TD><A HREF="#putenv"><b>putenv</b></A></TD>      <TD><A HREF="#sys_write"><b>sys_write</b></A></TD> </TR>
<TR> <TD><A HREF="#clock"><b>clock</b></A></TD>        <TD><A HREF="#intslash"><b>intslash</b></A></TD>  <TD><A HREF="#putfile"><b>putfile</b></A></TD>    <TD><A HREF="#tan"><b>tan</b></A></TD>            </TR>
<TR> <TD><A HREF="#close"><b>close</b></A></TD>        <TD><A HREF="#ip_addresses"><b>ip_addresses</b></A></TD> <TD><A HREF="#putline"><b>putline</b></A></TD>    <TD><A HREF="#tanh"><b>tanh</b></A></TD>          </TR>
<TR> <TD><A HREF="#command_line"><b>command_line</b></A></TD> <TD><A HREF="#ip_names"><b>ip_names</b></A></TD>  <TD><A HREF="#puts"><b>puts</b></A></TD>          <TD><A HREF="#tie"><b>tie</b></A></TD>            </TR>
<TR> <TD><A HREF="#command_name"><b>command_name</b></A></TD> <TD><A HREF="#is_..."><b>is_...</b></A></TD>      <TD><A HREF="#random"><b>random</b></A></TD>      <TD><A HREF="#time"><b>time</b></A></TD>          </TR>
<TR> <TD><A HREF="#cos"><b>cos</b></A></TD>            <TD><A HREF="#is_open"><b>is_open</b></A></TD>    <TD><A HREF="#range"><b>range</b></A></TD>        <TD><A HREF="#tmpnam"><b>tmpnam</b></A></TD>      </TR>
<TR> <TD><A HREF="#cosh"><b>cosh</b></A></TD>          <TD><A HREF="#kill"><b>kill</b></A></TD>          <TD><A HREF="#rany"><b>rany</b></A></TD>          <TD><A HREF="#to_lower"><b>to_lower</b></A></TD>  </TR>
<TR> <TD><A HREF="#date"><b>date</b></A></TD>          <TD><A HREF="#last_error"><b>last_error</b></A></TD> <TD><A HREF="#rbreak"><b>rbreak</b></A></TD>      <TD><A HREF="#to_upper"><b>to_upper</b></A></TD>  </TR>
<TR> <TD><A HREF="#denotype"><b>denotype</b></A></TD>  <TD><A HREF="#len"><b>len</b></A></TD>            <TD><A HREF="#rlen"><b>rlen</b></A></TD>          <TD><A HREF="#tod"><b>tod</b></A></TD>            </TR>
<TR> <TD><A HREF="#div"><b>div</b></A></TD>            <TD><A HREF="#less"><b>less</b></A></TD>          <TD><A HREF="#rmatch"><b>rmatch</b></A></TD>      <TD><A HREF="#true"><b>true</b></A></TD>          </TR>
<TR> <TD><A HREF="#domain"><b>domain</b></A></TD>      <TD><A HREF="#lessf"><b>lessf</b></A></TD>        <TD><A HREF="#rnotany"><b>rnotany</b></A></TD>    <TD><A HREF="#type"><b>type</b></A></TD>          </TR>
<TR> <TD><A HREF="#dup"><b>dup</b></A></TD>            <TD><A HREF="#lexists"><b>lexists</b></A></TD>    <TD><A HREF="#rspan"><b>rspan</b></A></TD>        <TD><A HREF="#umask"><b>umask</b></A></TD>        </TR>
<TR> <TD><A HREF="#dup2"><b>dup2</b></A></TD>          <TD><A HREF="#link"><b>link</b></A></TD>          <TD><A HREF="#read"><b>read</b></A></TD>          <TD><A HREF="#ungetc"><b>ungetc</b></A></TD>      </TR>
<TR> <TD><A HREF="#eof"><b>eof</b></A></TD>            <TD><A HREF="#log"><b>log</b></A></TD>            <TD><A HREF="#reada"><b>reada</b></A></TD>        <TD><A HREF="#ungetchar"><b>ungetchar</b></A></TD> </TR>
<TR> <TD><A HREF="#even"><b>even</b></A></TD>          <TD><A HREF="#lpad"><b>lpad</b></A></TD>          <TD><A HREF="#readlink"><b>readlink</b></A></TD>  <TD><A HREF="#unhex"><b>unhex</b></A></TD>        </TR>
<TR> <TD><A HREF="#exec"><b>exec</b></A></TD>          <TD><A HREF="#magic"><b>magic</b></A></TD>        <TD><A HREF="#reads"><b>reads</b></A></TD>        <TD><A HREF="#unlink"><b>unlink</b></A></TD>      </TR>
<TR> <TD><A HREF="#exp"><b>exp</b></A></TD>            <TD><A HREF="#mark"><b>mark</b></A></TD>          <TD><A HREF="#recv"><b>recv</b></A></TD>          <TD><A HREF="#unpack_..."><b>unpack_...</b></A></TD> </TR>
<TR> <TD><A HREF="#false"><b>false</b></A></TD>        <TD><A HREF="#match"><b>match</b></A></TD>        <TD><A HREF="#recvfrom"><b>recvfrom</b></A></TD>  <TD><A HREF="#unpretty"><b>unpretty</b></A></TD>  </TR>
<TR> <TD><A HREF="#fdate"><b>fdate</b></A></TD>        <TD><A HREF="#max"><b>max</b></A></TD>            <TD><A HREF="#recv_fd"><b>recv_fd</b></A></TD>    <TD><A HREF="#unsetenv"><b>unsetenv</b></A></TD>  </TR>
<TR> <TD><A HREF="#fetch_..."><b>fetch_...</b></A></TD> <TD><A HREF="#mem_alloc"><b>mem_alloc</b></A></TD> <TD><A HREF="#rem"><b>rem</b></A></TD>            <TD><A HREF="#unstr"><b>unstr</b></A></TD>        </TR>
<TR> <TD><A HREF="#fexists"><b>fexists</b></A></TD>    <TD><A HREF="#mem_copy"><b>mem_copy</b></A></TD>  <TD><A HREF="#reverse"><b>reverse</b></A></TD>    <TD><A HREF="#val"><b>val</b></A></TD>            </TR>
<TR> <TD><A HREF="#filename"><b>filename</b></A></TD>  <TD><A HREF="#mem_free"><b>mem_free</b></A></TD>  <TD><A HREF="#rewind"><b>rewind</b></A></TD>      <TD><A HREF="#wait"><b>wait</b></A></TD>          </TR>
<TR> <TD><A HREF="#fileno"><b>fileno</b></A></TD>      <TD><A HREF="#min"><b>min</b></A></TD>            <TD><A HREF="#round"><b>round</b></A></TD>        <TD><A HREF="#whole"><b>whole</b></A></TD>        </TR>
<TR> <TD><A HREF="#filter"><b>filter</b></A></TD>      <TD><A HREF="#mod"><b>mod</b></A></TD>            <TD><A HREF="#routine"><b>routine</b></A></TD>    <TD><A HREF="#with"><b>with</b></A></TD>          </TR>
<TR> <TD><A HREF="#fix"><b>fix</b></A></TD>            <TD><A HREF="#nargs"><b>nargs</b></A></TD>        <TD><A HREF="#rpad"><b>rpad</b></A></TD>          <TD><A HREF="#write"><b>write</b></A></TD>        </TR>
<TR> <TD><A HREF="#float"><b>float</b></A></TD>        <TD><A HREF="#newat"><b>newat</b></A></TD>        <TD><A HREF="#seek"><b>seek</b></A></TD>          <TD><A HREF="#writea"><b>writea</b></A></TD>      </TR>
<TR> <TD><A HREF="#fixed"><b>fixed</b></A></TD>        <TD><A HREF="#no_error"><b>no_error</b></A></TD>  <TD><A HREF="#select"><b>select</b></A></TD>      <TD><A HREF="#"><b></b></A></TD>                  </TR>
</TABLE>
<p>

The syntax of this presentation looks ahead to the SETL in
which operators, functions, and procedures can be overloaded.
For example, the cardinality operator (the first one below) is
declared as three overloadings of ``#'', but if you were to
define your own operator <b>card</b> in the existing SETL,
it would have to be something like this:
<p>

<DL>
<DT><b>op card (</b><i>s</i><b>);</b>
  <DL>
  <DT><b>case</b>
  <DT><b>is_string</b> <i>s</i> <b>=&gt;</b>   &nbsp;&nbsp;-- length of string
    <DL>
    <DT><i>n</i> <b>:=</b> 0<b>;</b>
    <DT><b>for</b> <i>x</i> <b>in</b> <i>s</i> <b>loop</b> <i>n</i> <b>+:=</b> 1<b>; end loop;</b>
    <DT><b>return</b> <i>n</i><b>;</b>
    </DL>
  <DT><b>is_set</b> <i>s</i> <b>=&gt;</b>      &nbsp;&nbsp;-- cardinality of set
    <DL>
    <DT><i>n</i> <b>:=</b> 0<b>;</b>
    <DT><b>for</b> <i>x</i> <b>in</b> <i>s</i> <b>loop</b> <i>n</i> <b>+:=</b> 1<b>; end loop;</b>
    <DT><b>return</b> <i>n</i><b>;</b>
    </DL>
  <DT><b>is_tuple</b> <i>s</i> <b>=&gt;</b>    &nbsp;&nbsp;-- length of tuple
    <DL>
    <DT><i>n</i> <b>:=</b> 0<b>;</b>
    <DT><b>for</b> <i>x</i> <b>in</b> <i>s</i> <b>loop</b> <i>n</i> <b>+:=</b> 1<b>; end loop;</b>
    <DT><b>return</b> <i>n</i><b>;</b>
    </DL>
  <DT><b>otherwise =&gt;</b>
    <DL>
    <DT><b>printa(stderr,</b>"card:  invalid argument type: "<b>,type</b> <i>s</i><b>);</b>
    <DT><b>stop</b> 1<b>;</b>
    </DL>
  <DT><b>end case;</b>
  </DL>
<DT><b>end op card;</b>
</DL>
<P>

In a proposed version of SETL [to be discussed in my thesis], you
will be able to implement the same operator as three overloaded ones
like this, with exactly the same effect in the case of a valid
argument (and just a possibly different error message otherwise):
<p>

<DL>
<DT><b>op card (set</b> <i>s</i><b>) : integer</b>
  <DL>
  <DT><i>n</i> <b>:=</b> 0
  <DT><b>for</b> <i>x</i> <b>in</b> <i>s</i> <b>loop</b> <i>n</i> <b>+:=</b> 1<b>; end loop</b>
  <DT><b>return</b> <i>n</i>
  </DL>
<DT><b>end op card</b>
<P>
<DT><b>op card (string</b> <i>s</i><b>) : integer</b>
  <DL>
  <DT><i>n</i> <b>:=</b> 0
  <DT><b>for</b> <i>x</i> <b>in</b> <i>s</i> <b>loop</b> <i>n</i> <b>+:=</b> 1<b>; end loop</b>
  <DT><b>return</b> <i>n</i>
  </DL>
<DT><b>end op card</b>
<P>
<DT><b>op card (tuple</b> <i>t</i><b>) : integer</b>
  <DL>
  <DT><i>n</i> <b>:=</b> 0
  <DT><b>for</b> <i>x</i> <b>in</b> <i>t</i> <b>loop</b> <i>n</i> <b>+:=</b> 1<b>; end loop</b>
  <DT><b>return</b> <i>n</i>
  </DL>
<DT><b>end op card</b>
</DL>
<P>

Noting that the original definition could be written as follows
(in old-style syntax for variety), you might wonder what the advantage
to overloading is.  Ultimately, if you were a computer scientist, the
question would lead you into the world of ``polymorphic'' functions; the
body of the following operator definition is clearly applicable to all
kinds of aggregates, and the restriction to sets, tuples, and strings
is an artifice from that point of view (or would be, if you could
define other kinds of aggregates as first-class types in SETL).
<p>

<DL>
<DT><b>op card (</b><i>s</i><b>);</b>
  <DL>
  <DT><b>case of</b>
  <DT><b>(is_set</b> <i>s</i><b>, is_string</b> <i>s</i><b>, is_tuple</b> <i>s</i><b>):</b>
    <DL>
    <DT><i>n</i> <b>:=</b> 0<b>;</b>
    <DT><b>(for</b> <i>x</i> <b>in</b> <i>s</i><b>)</b> <i>n</i> <b>+:=</b> 1<b>; end;</b>
    <DT><b>return</b> <i>n</i><b>;</b>
    </DL>
  <DT><b>else</b>
    <DL>
    <DT><b>printa(stderr,</b>"card:  invalid argument type: "<b>,type</b> <i>s</i><b>);</b>
    <DT><b>stop</b> 1<b>;</b>
    </DL>
  <DT><b>end case;</b>
  </DL>
<DT><b>end op card;</b>
</DL>

It is interesting
to note that you could actually just delete the type check in the
above, producing the seemingly very tidy definition below.
If the argument <i>s</i> were not of a type susceptible to
<b>in</b>-style iteration, you would get a different error message,
that is all.  The computer scientist would consider that a kind of
uncontrolled polymorphism, because ideally the inappropriateness of the
type would be caught at entry to <b>card</b> instead of at the
point where iteration was attempted.  That is an advantage that
overloading always has over the old free-and-easy approach, though
it is perhaps clearer in non-polymorphic cases.  But even in cases
like the present one, languages such as Griffin <!-- ref? -->
and ML <!-- ref? --> can describe an argument such as
<i>s</i> purely in terms of the operations (such as iteration)
supported by <i>s</i>.  If you later add a type called ``list'' that
supports <b>in</b>-iteration, your polymorphic definition would still
be valid without adding the new case.
<p>

<DL>
<DT><b>op card (</b><i>s</i><b>);</b>
  <DL>
  <DT><i>n</i> <b>:=</b> 0<b>;</b>
  <DT><b>loop for</b> <i>x</i> <b>in</b> <i>s</i> <b>do</b> <i>n</i> <b>+:=</b> 1<b>; end loop;</b>
  <DT><b>return</b> <i>n</i><b>;</b>
  </DL>
<DT><b>end op card;</b>
</DL>

Unfortunately, we cannot give the ``controlled'' polymorphic
version in SETL, which means we must spell out a few cases where
some languages would be able to express a whole group of such
generically related operators in a single sweeping flourish.
On the other hand, features like this require considerable
implementation effort and are widely regarded as exotic, even
though they provide extra opportunities for static checking.  They
seem to be mainly of value to programmers who are designing highly
general libraries and interfaces, and for that erudite audience a
language more at the level of Ada 95 is really much more suitable
than a language like SETL, whose ``high level'' nature consists
mainly in predefining abstractions that are useful in prototyping
and data processing.
<p>

Indeed, since polymorphism is much like having different versions of
code around, in many cases, people will often in fact prefer to generate
code with their own tools rather than learn the conventions of a
particular programming language (such as how to define ``templates'' or
``generics'' in it).  Rolling your own code by your own rules has the
advantage that you maintain complete flexibility in how it is generated.
This sometimes wins over the disciplined approach, though perhaps not
as often as some of us hacks would like to believe.
<p>

Finally, getting back to the presentation conventions in the detailed
descriptions of built-in routines below, the still miraculously alert
reader will note that in two cases (<A HREF="#**">``<b>**</b>''</A>
on <b>integer</b> arguments, and <A HREF="#val"><b>val</b></A>), the
notation steps beyond any reasonable proposal for overloading in SETL,
because the return type actually depends on the input <i>values</i>,
not just the input <i>types</i>.  This presents no problem as a
mnemonic notation, but it would be rather difficult to accommodate
such declarations formally.
<p>

In fact, there is also one case (<A HREF="#/">``<b>/</b>''</A> on
<b>integer</b> arguments) where the return type depends on the current
value of a switch (<A HREF="#intslash"><b>intslash</b></A>) that can be
toggled at run-time, and several cases where a return value of <b>om</b>
is possible even though this is not apparent from the given signature
but instead is just mentioned in the description of the routine.
<p>

For all these cases where multiple return types are listed or
described for a single combination of input types, the reality is
that barring some extraordinary proposal, there will only ever be one
declaration for that combination of input types, and its return type
will be general enough to include the union of all the possible
return types.  In the notation here, only one such union is invoked,
and is called <b>var</b>, representing the universe of all SETL values.
See for example <A HREF="#unstr"><b>unstr</b></A>, which takes
<b>string</b>s to various types, all lumped together as <b>var</b>.
<p>

[I didn't bother introducing <b>number*</b> as the union of
<b>integer</b> and <b>real</b>, because there are really very few
cases (all mentioned above) where it would have been useful; in a
notation meant for human consumption, it is better to have the
explicit, short, and infrequent list of possibilities each time.
Is this worth blathering on about?  Would it be better to put
<b>number*</b> in and change the existing blathering to mention it,
lauding it as looking ahead to when there is <b>rational*</b> and
<b>complex*</b> as well?  I don't think so, and in fact that would
miss the point, because obviously (for example) the slash operator
would choose just between <b>rational*</b> and <b>integer</b> for
the quotient of integers; you still wouldn't want <b>number*</b> given
as the return type for that case.]
<p>

(*) Imaginary keywords, like <b>spam*</b>, are indicated by a trailing
asterisk, to show that they may have been in Indo-European but are not
to be found in modern-day SETL.
<p>

<HR>

<H2>
<A name="asciibet">The intrinsics, in asciibetical order</A>
</H2>

In the following, <b>var</b> is used to denote an argument or return
value of any type.  Three dots indicate 0 or more optional arguments.
(To repeat, there are no type declarations in
this SETL, but we pretend there are in the signatures listed here.
If a routine can return a result other than <b>om</b>, this is
signified by a colon and a typename.  A slight liberty is taken with
the typenames where a result is normally of a particular type but
sometimes <b>om</b>.  In such cases, the particular typename is used
to stand for both possibilities.  As a general guideline, there's no
point in your checking for <b>om</b> if the operation is so outrageous
that it raises an exception.  If you take a chance and don't bother
checking for <b>om</b>, your program will probably crash almost
immediately if an unintended one does crop up anyway, so <i>not</i>
checking for <b>om</b> can even be perfectly reasonable style in
circumstances where <b>om</b> is technically possible.  Conversely,
checking for <b>om</b> where it cannot occur is at worst redundant.
But the documentation should really have been strict on this.  Patches
will be gratefully accepted.)
<p>

<A NAME="#"></A>
<HR><p>
<FONT SIZE=+2>Size of set, length of string or tuple</FONT>
<DL>
<DT><b>op # (set) : integer</b>
<DT><b>op # (string) : integer</b>
<DT><b>op # (tuple) : integer</b>
</DL>

<A NAME="*"></A>
<HR><p>
<FONT SIZE=+2>Numeric multiplication, set intersection, string or tuple replication</FONT>
<DL>
<DT><b>op * (integer, integer) : integer</b>
<DT><b>op * (real, real) : real</b>
<DT><b>op * (real, integer) : real</b>
<DT><b>op * (integer, real) : real</b>
<DT><b>op * (set, set) : set</b>
<DT><b>op * (string, integer) : string</b>
<DT><b>op * (integer, string) : string</b>
<DT><b>op * (tuple, integer) : tuple</b>
<DT><b>op * (integer, tuple) : tuple</b>
</DL>

<A NAME="**"></A>
<HR><p>
<FONT SIZE=+2>Exponentiation</FONT>
<DL>
<DT><b>op ** (integer, integer) : integer</b>
<DT><b>op ** (integer, integer) : real</b>
<DT><b>op ** (real, real) : real</b>
<DT><b>op ** (real, integer) : real</b>
<DT><b>op ** (integer, real) : real</b>
<p>
When both arguments are of <b>integer</b> type, the return type is
<b>real</b> if and only if the second argument is negative.
</DL>

<A NAME="+"></A>
<HR><p>
<FONT SIZE=+2>Numeric affirmation or addition, set union, string or tuple concatenation</FONT>
<DL>
<DT><b>op + (integer) : integer</b>
<DT><b>op + (real) : real</b>
<DT><b>op + (integer, integer) : integer</b>
<DT><b>op + (real, real) : real</b>
<DT><b>op + (real, integer) : real</b>
<DT><b>op + (integer, real) : real</b>
<DT><b>op + (set, set) : set</b>
<DT><b>op + (string, string) : string</b>
<DT><b>op + (tuple, tuple) : tuple</b>
<DT><b>op + (string, string) : string</b>
<DT><b>op + (string, var) : string</b>
<DT><b>op + (var, string) : string</b>
<p>
The binary forms in which one argument is a <b>real</b> and the other
is an <b>integer</b> are treated as if the <b>integer</b> is
``promoted'' to a <b>real</b> before addition using
<A HREF="#float"><b>float</b></A> (which see for more information
about floating-point overflow).
<p>
The binary forms in which one argument is a <b>string</b> and the other
is <i>not</i> are treated as if <A HREF="#str"><b>str</b></A> is first
applied to the non-<b>string</b> argument to convert it preparatory
to string concatenation.
<p>
See also <A HREF="#query">``<b>?</b>''</A> regarding special-case
treatment of the ``<b>+:=</b>'' operator when the left-hand argument
has the initial value <b>om</b>.
</DL>

<A NAME="-"></A>
<HR><p>
<FONT SIZE=+2>Numeric negation or subtraction, set difference</FONT>
<DL>
<DT><b>op - (integer) : integer</b>
<DT><b>op - (real) : real</b>
<DT><b>op - (integer, integer) : integer</b>
<DT><b>op - (real, real) : real</b>
<DT><b>op - (real, integer) : real</b>
<DT><b>op - (integer, real) : real</b>
<DT><b>op - (set, set) : set</b>
</DL>

<A NAME="/"></A>
<HR><p>
<FONT SIZE=+2>Numeric quotient</FONT>
<DL>
<DT><b>op / (integer, integer) : real</b>
<DT><b>op / (integer, integer) : integer</b>
<DT><b>op / (real, real) : real</b>
<DT><b>op / (real, integer) : real</b>
<DT><b>op / (integer, real) : real</b>
<p>
Note the return type of integer division here.  You can cause
<b>integer / integer</b> to return a truncated (<b>integer</b>) result
by setting <A HREF="#intslash"><b>intslash</b></A>&nbsp;:=&nbsp;<b>true</b>
(or equivalently, by calling
<A HREF="#set_intslash"><b>set_intslash</b></A> with an argument
of <b>true</b>), but you do so at your peril.  Consider a program that
reads pairs of numbers and computes their quotients.  Unless you are
careful to ensure that each number (or at least one of each pair)
is <b>real</b>, your program will sometimes truncate quotients
and sometimes not, depending (mostly!) on whether the input
numbers happen to have decimal points in them or not.  You can still
get truncated integer division using the <A HREF="#div"><b>div</b></A>
operator, as in the Algol tradition.  This has the advantage of
making explicit the fact that the division is not the kind implied
by the customary mathematical symbol.  C and Fortran programmers
trip constantly over the bad design decision made in those
languages for them.  Even when they know the rule, it is an easy one
to forget when trying to stare down a bug.  In such a mode one
usually focuses intensely on the ``logic''---my favourite story
in that connection is by Jack Schwartz, who reports spending hours
once upon a time trying to puzzle out why a particular segment of
Fortran code wasn't working.  He had isolated the problem down to a
single line, and almost succeeded in convincing himself that there was
a code generation bug in the compiler, when he finally noticed the
comment symbol in column 1.  Anyway, I helped a student only yesterday
(summer solstice, 1995) with one of these pestilent C integer
division things.  It hits almost everyone who uses C at some time
or other; usually what happens is that you are thinking that at least
one operand is floating-point but actually have them both declared
as int.  Okay, enough diatribe.  This is supposed to be a reference
guide, isn't it.
</DL>

<A NAME="="></A>
<A NAME="/="></A>
<HR><p>
<FONT SIZE=+2>Equality and inequality</FONT>
<DL>
<DT><b>op = (var, var) : boolean</b>
<DT><b>op /= (var, var) : boolean</b>
</DL>

<A NAME="&lt;"></A>
<A NAME="&gt;"></A>
<A NAME="&lt;="></A>
<A NAME="&gt;="></A>
<HR><p>
<FONT SIZE=+2>Numeric and lexicographic comparisons</FONT>
<DL>
<DT><b>op &lt; (integer, integer) : boolean</b>
<DT><b>op &lt; (real, real) : boolean</b>
<DT><b>op &lt; (real, integer) : boolean</b>
<DT><b>op &lt; (integer, real) : boolean</b>
<DT><b>op &lt; (string, string) : boolean</b>
<DT><b>op &gt; (integer, integer) : boolean</b>
<DT><b>op &gt; (real, real) : boolean</b>
<DT><b>op &gt; (real, integer) : boolean</b>
<DT><b>op &gt; (integer, real) : boolean</b>
<DT><b>op &gt; (string, string) : boolean</b>
<DT><b>op &lt;= (integer, integer) : boolean</b>
<DT><b>op &lt;= (real, real) : boolean</b>
<DT><b>op &lt;= (real, integer) : boolean</b>
<DT><b>op &lt;= (integer, real) : boolean</b>
<DT><b>op &lt;= (string, string) : boolean</b>
<DT><b>op &gt;= (integer, integer) : boolean</b>
<DT><b>op &gt;= (real, real) : boolean</b>
<DT><b>op &gt;= (real, integer) : boolean</b>
<DT><b>op &gt;= (integer, real) : boolean</b>
<DT><b>op &gt;= (string, string) : boolean</b>
</DL>

<A NAME="query"></A>
<HR><p>
<FONT SIZE=+2>Query</FONT>
<DL>
<DT><b>op ? (var, var) : var</b>
<p>
The expression <i>a</i>&nbsp;<b>?</b>&nbsp;<i>b</i> is equivalent to the expression
<b>if</b>&nbsp;<i>a</i>&nbsp;<b>=&nbsp;om&nbsp;then</b>&nbsp;<i>b</i> <b>else</b>&nbsp;<i>a</i> <b>end</b>.
Thus the query operator is ``short-circuited'' like
<A HREF="#and"><b>and</b></A> and <A HREF="#or"><b>or</b></A>.
For a map <i>m</i> used to count occurrences of items, the sequence
<p>
  <DL>
  <DT><i>m</i><b>(</b><i>item</i><b>) ?:=</b> 0<b>;</b>&nbsp;&nbsp;-- initialize if undefined
  <DT><i>m</i><b>(</b><i>item</i><b>) +:=</b> 1<b>;</b>&nbsp;&nbsp;-- accumulate
  </DL>
<p>
is idiomatic in SETL.  There is in fact a case to be made for treating
an undefined operand of <A HREF="#+">``<b>+</b>''</A> as 0 if the other argument is
numeric, or as the null string if the other argument is a string, or as
<b>{}</b> if it is a set, or as <b>[]</b> if it is a tuple.  The fact
that ``<b>*</b>'' has overloadings like <b>(integer, string)</b>
suggests that it probably should <em>not</em> treat <b>om</b> as the
identity element for multiplication (1) even when one argument is
numeric.  <a href="mailto:bacon@cs.nyu.edu">Opinions are welcome</a>.
<p>
Experimentally, it has been decided that the above sequence is more
idiotic than idiomatic.  Bob Paige, if I (dB) recall correctly,
thought it was more of a nuisance than a useful guard against
failure-to-initialize errors to have to do the ``<b>?:=</b>&nbsp;0''
part, and I agree.
<p>
So, whenever the left-hand side of ``<b>+:=</b>''
has the (initial) value <b>om</b>, and the right-hand side is an
<b>integer</b>, <b>real</b>, <b>string</b>, <b>set</b>, or <b>tuple</b>,
the left-hand side will be treated as if it had the appropriate
identity element as its initial value, i.e. 0, 0.0, "", <b>{}</b>,
or <b>[]</b> respectively.  Thus the above sequence can be shortened
to the (more rational?)
<p>
<DL>
<DT><i>m</i><b>(</b><i>item</i><b>) +:=</b> 1<b>;</b>&nbsp;&nbsp;-- initialize if undefined, and accumulate
</DL>
<p>
This rule takes precedence over the non-assigning-form rule for the
``<b>+</b>'' operator, which makes
<b>om&nbsp;+</b>&nbsp;<i>s</i>&nbsp;<b>=&nbsp;<A HREF="#str">str</A>&nbsp;om&nbsp;+</b>&nbsp;<i>s</i> for any <b>string</b> <i>s</i>.
</DL>

<A NAME="abs"></A>
<HR><p>
<FONT SIZE=+2>Numeric absolute value, integer value of character</FONT>
<DL>
<DT><b>op abs (integer) : integer</b>
<DT><b>op abs (real) : real</b>
<DT><b>op abs (string) : integer</b>
<p>
For a <b>string</b> operand, <b>abs</b> is equivalent to
<A HREF="#ichar"><b>ichar</b></A>.
</DL>

<HR><p>
[The reason there is no <b>access</b> routine is that the Unix
<i>access</i>(2) permissions relate to the
<i>real</i> user and group ids, whereas the success of
<A HREF="#open"><b>open</b></A> depends on the <i>effective</i>
uid and gid.  I don't want any routines in the SETL library with
such subtle semantics.  Use <A HREF="#system"><b>system</b></A>
with the <i>test</i>(1) command to get the information <b>access</b>
would retrieve if you really need it.  See also
<A HREF="#fexists"><b>fexists</b></A> (the file existence predicate).]
[That seems a little silly, doesn't it, dB?]
<p>

<A NAME="accept"></A>
<HR><p>
<FONT SIZE=+2>Accept connection on socket</FONT>
<DL>
<DT><b>proc accept (integer) : integer</b>
<DT><b>proc accept (string) : integer</b>
<p>
The argument must be a server socket opened by
<A HREF="#open"><b>open</b></A>.
The <b>accept</b> procedure blocks until a client connection comes in,
and then returns a new socket for that connection.  The
<A HREF="#select"><b>select</b></A> procedure can be used to test
whether an <b>accept</b> would block on the given server socket, and
<A HREF="#pump"><b>pump</b></A> or <A HREF="#fork"><b>fork</b></A>
is often used to help programs serve clients concurrently instead of
making them queue for service.
<p>
It is possible for <b>accept</b> to fail due to conditions arising
between the time of a successful <b>select</b> and the issuing of the
<b>accept</b> call.  In this case <b>accept</b> returns <b>om</b>.
<p>
<!-- See also my <A HREF="./survey-pap/index.html">survey paper</A> -->
See also my <a href="http://www.cs.nyu.edu/bacon/phd-thesis/">Ph.D. dissertation</a>
for detailed guidance on network programming in SETL.
<!--
<p>
[That should soon change to a reference to my Ph.D.&nbsp;dissertation.]
-->
</DL>

<A NAME="acos"></A>
<HR><p>
<FONT SIZE=+2>Arc cosine</FONT>
<DL>
<DT><b>op acos (real) : real</b>
<DT><b>op acos (integer) : real</b>
</DL>

<A NAME="and"></A>
<HR><p>
<FONT SIZE=+2>Logical conjunction</FONT>
<DL>
<DT><b>op and (boolean, boolean) : boolean</b>
<p>
The expression <i>a</i>&nbsp;<b>and</b>&nbsp;<i>b</i> is equivalent to the expression
<b>if</b>&nbsp;<i>a</i>&nbsp;<b>then</b>&nbsp;<i>b</i> <b>else&nbsp;false end</b>.
The <b>and</b> operator is ``short-circuited'' in that it only evaluates
its second argument if necessary.  This makes it suitable for use as a
``guard'' against erroneous evaluations such as subscripting a tuple
with a nonpositive integer (see also <A HREF="#or"><b>or</b></A>):
<p>
  <DL>
  <DT><b>if</b> <i>i</i> <b>&gt;</b> 0 <b>and</b> <i>t</i><b>(</b><i>i</i><b>) =</b> "banana" <b>then ...</b>
  </DL>
</DL>

<A NAME="any"></A>
<HR><p>
<FONT SIZE=+2>Break out initial character</FONT>
<DL>
<DT><b>proc any (rw string</b> <i>s</i><b>, string</b> <i>p</i><b>) : string</b>
<p>
If the first character of <i>s</i> appears anywhere in the string
<i>p</i>, that character is removed from <i>s</i> and returned as the
function result.  Otherwise, nothing happens to <i>s</i>, and the null
string is returned.  See also <A HREF="#notany"><b>notany</b></A>,
<A HREF="#rany"><b>rany</b></A>, and <A HREF="#rnotany"><b>rnotany</b></A>.
</DL>

<A NAME="arb"></A>
<HR><p>
<FONT SIZE=+2>Arbitrary element of set</FONT>
<DL>
<DT><b>op arb (set) : var</b>
<p>
An arbitrary (which is not to say ``random'' but rather
<i>nondeterministically chosen</i>) element of the argument set is
returned.  If the set is empty, <b>om</b> is returned.
</DL>

<A NAME="asin"></A>
<HR><p>
<FONT SIZE=+2>Arc sine</FONT>
<DL>
<DT><b>op asin (real) : real</b>
<DT><b>op asin (integer) : real</b>
</DL>

<A NAME="atan"></A>
<HR><p>
<FONT SIZE=+2>Arc tangent</FONT>
<DL>
<DT><b>op atan (real) : real</b>
<DT><b>op atan (integer) : real</b>
<p>
See also <A HREF="#atan2"><b>atan2</b></A>.
</DL>

<A NAME="atan2"></A>
<HR><p>
<FONT SIZE=+2>Arc tangent of quotient</FONT>
<DL>
<DT><b>op atan2 (real, real) : real</b>
<DT><b>op atan2 (real, integer) : real</b>
<DT><b>op atan2 (integer, real) : real</b>
<DT><b>op atan2 (integer, integer) : real</b>
<p>
Suppose <i>y</i>&nbsp;=&nbsp;<i>c</i>&nbsp;<b>*&nbsp;sin</b>&nbsp;<i>t</i> and
<i>x</i>&nbsp;=&nbsp;<i>c</i>&nbsp;<b>*&nbsp;cos</b>&nbsp;<i>t</i>, for some <i>c</i> and <i>t</i>.
Then <i>y</i>&nbsp;<b>atan2</b>&nbsp;<i>x</i>&nbsp;=&nbsp;<i>t</i> can be safely
evaluated even when the otherwise equivalent expression
<b>atan</b>(<i>y</i>/<i>x</i>) would overflow, i.e.,
when <b>cos</b>&nbsp;<i>t</i>&nbsp;=&nbsp;0.
</DL>

<A NAME="bit_and"></A>
<A NAME="bit_not"></A>
<A NAME="bit_or"></A>
<A NAME="bit_xor"></A>
<HR><p>
<FONT SIZE=+2>Bitwise logical operators</FONT>
<DL>
<DT><b>op bit_and (integer, integer) : integer</b>
<DT><b>op bit_not (integer) : integer</b>
<DT><b>op bit_or (integer, integer) : integer</b>
<DT><b>op bit_xor (integer, integer) : integer</b>
<p>
These operators treat their operands as binary integers, that is
to say as bit patterns.  They are machine-dependent with respect to
word size, but have some use in expressing certain algorithms that
do specialized tricks with bit patterns.
</DL>

<A NAME="break"></A>
<HR><p>
<FONT SIZE=+2>Break out initial substring based on delimiter</FONT>
<DL>
<DT><b>proc break (rw string</b> <i>s</i><b>, string</b> <i>p</i><b>) : string</b>
<p>
If <i>s</i> contains a character that appears in <i>p</i>, the
substring of <i>s</i> up to but not including that character is
``broken off'' from the beginning of <i>s</i> and returned as the
function result, while <i>s</i> itself is updated to reflect the
loss.  Otherwise (no character from <i>p</i> appears in <i>s</i>),
the function result is the input value of <i>s</i>, and <i>s</i>
is reduced to the null string by the operation.  See also
<A HREF="#span"><b>span</b></A>, <A HREF="#rbreak"><b>rbreak</b></A>,
and <A HREF="#rspan"><b>rspan</b></A>.
</DL>

<A NAME="call"></A>
<HR><p>
<FONT SIZE=+2>Indirect call</FONT>
<DL>
<DT><b>proc call (proc_ref, ...) : var</b>
<p>
See <A HREF="#routine"><b>routine</b></A>.  Note that all arguments
to <b>call</b> are read-only, so the procedure referenced through
the <b>proc_ref</b> value must not have any <b>rw</b> or <b>wr</b>
arguments.  It may, however, <b>return</b> a result of any type,
including <b>tuple</b>, so multiple values can be returned at
relatively minor syntactic cost to the caller like this:
<p>
  <DL>
  <DT><i>f_ref</i> <b>:= routine</b> <i>f</i><b>;</b>
  <DT><b>...</b>
  <DT><b>[</b><i>x</i><b>,</b> <i>y</i><b>,</b> <i>z</i><b>] := call (</b><i>f_ref</i><b>,</b> <i>a</i><b>,</b> <i>b</i><b>, ...)</b>
  </DL>
</DL>

<A NAME="callout"></A>
<HR><p>
<FONT SIZE=+2>Call C function</FONT>
<DL>
<DT><b>proc callout (integer, om, tuple) : string</b>
<p>
This is a SETL2 compatibility feature of dubious value.
It is easier to use the SETL customization protocol, and
you get a superior result (the interface you want) that way.
The SETL2 callout interface is very awkward, and was invented
so that the SETL2 interpreter could be extended without
the need for any of its source code to be revealed.  Basically,
you had to supply a C function with a predetermined name and have
it dispatch on the <b>integer</b> argument.  You would then link your
C function with the SETL2 interpreter in place of the default no-op
version.
</DL>

<A NAME="ceil"></A>
<HR><p>
<FONT SIZE=+2>Ceiling (lowest integer upper bound)</FONT>
<DL>
<DT><b>op ceil (real) : integer</b>
<DT><b>op ceil (integer) : integer</b>
<p>
See also <A HREF="#floor"><b>floor</b></A>, <A HREF="#round"><b>round</b></A>,
and <A HREF="#fix"><b>fix</b></A>.
</DL>

<A NAME="char"></A>
<HR><p>
<FONT SIZE=+2>Character representation of small integer</FONT>
<DL>
<DT><b>op char (integer) : string</b>
<p>
For example <b>char</b>&nbsp;97&nbsp;=&nbsp;"a" in an ASCII environment.
Note that in SETL, it is safe to include null characters (characters
corresponding to the integer 0) inside strings, so <b>char</b>&nbsp;0 is
well-defined.  See also <A HREF="#ichar"><b>ichar</b></A> and
<A HREF="#abs"><b>abs</b></A>.
</DL>

<A NAME="chdir"></A>
<HR><p>
<FONT SIZE=+2>Change directory</FONT>
<DL>
<DT><b>proc chdir</b>
<DT><b>proc chdir (string</b> <i>s</i><b>)</b>
<p>
The current working directory is changed to <i>s</i> if given,
otherwise to the user's ``home'' directory as found in the HOME
environment variable.  See also <A HREF="#getwd"><b>getwd</b></A>.
</DL>

<A NAME="clear_error"></A>
<HR><p>
<FONT SIZE=+2>Clear error indicator</FONT>
<DL>
<DT><b>proc clear_error</b>
<p>
The local system's ``last error'' indicator is cleared.
It is a good idea to do this just before a call if you
intend to check <A HREF="#last_error"><b>last_error</b></A>
after the call, as in this example:
<p>
  <DL>
  <DT><b>clear_error;</b>
  <DT><b>kill(</b><i>p</i><b>, 0);</b>
  <DT><b>if last_error = no_error then</b>
    <DL>
    <DT>-- The process <i>p</i> exists and can be sent a signal.
    <DT>...
    </DL>
  <DT><b>else</b>
    <DL>
    <DT>-- "No such process", or else the process exists but
    <DT>-- we can't signal it.
    <DT>...
    </DL>
  <DT><b>end if;</b>
  </DL>
<p>
This approach can be used whenever you want to check for
errors after calling a ``system'' routine like
<A HREF="#kill"><b>kill</b></A> or <A HREF="#close"><b>close</b></A>,
which are normally silent about errors.
Contrast this with <A HREF="#open"><b>open</b></A>,
which returns <b>om</b> instead of a file descriptor if there is
an error, allowing you to test the result directly.
<p>
Note that the above example is for illustrative purposes only; in
practice, you would use the <A HREF="#pexists"><b>pexists</b></A>
operator to test for process existence more directly.
</DL>

<A NAME="clock"></A>
<HR><p>
<FONT SIZE=+2>Elapsed time in milliseconds</FONT>
<DL>
<DT><b>proc clock : integer</b>
<p>
This is the total amount of wall-clock (``real'') time, in
milliseconds, that has passed since the current process began.
See also <A HREF="#time"><b>time</b></A> and
<A HREF="#tod"><b>tod</b></A>.
</DL>

<A NAME="close"></A>
<HR><p>
<FONT SIZE=+2>Close stream</FONT>
<DL>
<DT><b>proc close (string</b> <i>f</i><b>)</b>
<DT><b>proc close (integer</b> <i>f</i><b>)</b>
<p>
The stream <i>f</i> previously passed to or returned by
<A HREF="#open"><b>open</b></A> (or returned by
<A HREF="#accept"><b>accept</b></A>) is closed.  It is
also permissible to <b>close</b> a predefined stream such as
<A HREF="#std..."><b>stdin</b></A>, <A HREF="#std..."><b>stdout</b></A>,
and <A HREF="#std..."><b>stderr</b></A> (or equivalently 0, 1, and 2
respectively), and to <b>close</b> a file descriptor (<b>integer</b>
<i>f</i>) that is not open at the SETL level but may be open at the
underlying system level.  Closing a SETL pipe, pump, or line-pump
stream causes the associated subprocess to be waited for, and
<A HREF="#status"><b>status</b></A> to be set to its exit status.
<p>
See also <A HREF="#shutdown"><b>shutdown</b></A>.
</DL>

<A NAME="command_line"></A>
<HR><p>
<FONT SIZE=+2>Command-line parameters</FONT>
<DL>
<DT><b>command_line : const tuple</b>
<p>
This is a <b>tuple</b> of <b>string</b>s giving the
command-line parameters that were passed to the SETL
program at execution time.  In a Unix script that
uses the ``#!'' kernel escape, or a SETL program
compiled to machine code, these are all the
parameters after (but not including) the command name.
If the program is being run under the standard Unix driver
(usually the ``setl'' command), <b>command_line</b> lists
all the arguments after the ``-x'' flag.  See also
<A HREF="#command_name"><b>command_name</b></A>.
</DL>

<A NAME="command_name"></A>
<HR><p>
<FONT SIZE=+2>Command name</FONT>
<DL>
<DT><b>command_name : const string</b>
<p>
This <b>string</b> is the name by which the SETL program was
invoked from the system.  In Unix, this is usually the name
of a file containing a SETL script (see example below), or of a
file containing the machine-code version of a SETL program.  If,
however, the program was run under the standard Unix driver
(usually the ``setl'' command), then <b>command_name</b> instead
returns the name of the SETL interpreter (usually ``setlrun'').
<p>
As a Unix example, suppose the standard executables of the SETL system
have been installed in ``/usr/bin''.  Then if the following
script is stored in the executable file ``Yhwh'' and invoked, it will
write "I'm Yhwh" and a newline character to the standard output:
<PRE>
#! /usr/bin/setl -k
print("I'm", command_name);  -- like sh $0 or C argv[0]
</PRE>
Note the use of the ``#!'' kernel escape.
See also <A HREF="#command_line"><b>command_line</b></A>.
</DL>

<A NAME="cos"></A>
<HR><p>
<FONT SIZE=+2>Trigonometric cosine</FONT>
<DL>
<DT><b>op cos (real) : real</b>
<DT><b>op cos (integer) : real</b>
</DL>

<A NAME="cosh"></A>
<HR><p>
<FONT SIZE=+2>Hyperbolic cosine</FONT>
<DL>
<DT><b>op cosh (real) : real</b>
<DT><b>op cosh (integer) : real</b>
</DL>

<A NAME="date"></A>
<HR><p>
<FONT SIZE=+2>Date and time of day</FONT>
<DL>
<DT><b>proc date : string</b>
<p>
See also <A HREF="#fdate"><b>fdate</b></A>,
<A HREF="#tod"><b>tod</b></A>, <A HREF="#clock"><b>clock</b></A>, and
<A HREF="#time"><b>time</b></A>.
</DL>

<A NAME="denotype"></A>
<HR><p>
<FONT SIZE=+2>Type of denotation within string</FONT>
<DL>
<DT><b>op denotype (string</b> <i>s</i><b>) : string</b>
<p>
If <i>s</i> contains a denotation that would be acceptable to
<A HREF="#unstr"><b>unstr</b></A>, then <b>denotype</b>&nbsp;<i>s</i>&nbsp;<b>=&nbsp;<A HREF="#type">type</A>&nbsp;unstr</b>&nbsp;<i>s</i>, but if <i>s</i>
is some other <b>string</b>, then the advantage of checking it with
<b>denotype</b> first is that <b>denotype</b> returns <b>om</b>
in that case instead of raising an exception as <b>unstr</b> would.
<p>
See also <A HREF="#val"><b>val</b></A> and
<A HREF="#str"><b>str</b></A>.
</DL>

<A NAME="div"></A>
<HR><p>
<FONT SIZE=+2>Integer division</FONT>
<DL>
<DT><b>op div (integer, integer) : integer</b>
<p>
SETL guarantees that <b>div</b> always truncates fractional results
towards zero.  (In C, it is machine-dependent for negative quotients.)
See also <A HREF="#mod"><b>mod</b></A> and
<A HREF="#rem"><b>rem</b></A>.
</DL>

<A NAME="domain"></A>
<HR><p>
<FONT SIZE=+2>Domain of map</FONT>
<DL>
<DT><b>op domain (set) : set</b>
<p>
The argument must be a set of ordered pairs, that is, a set
of tuples each of size 2.  The result is the set of all first
members of those tuples.  See also <A HREF="#range"><b>range</b></A>.
</DL>

<A NAME="dup"></A>
<A NAME="dup2"></A>
<HR><p>
<FONT SIZE=+2>Duplicate file descriptor</FONT>
<DL>
<DT><b>op dup (integer) : integer</b>
<DT><b>op dup2 (integer, integer) : integer</b>
<p>
These are direct interfaces to the low-level Posix routines
<i>dup</i>(2) and <i>dup2</i>(2), useful when you need close control over
system-level file descriptors, typically in
<A HREF="#fork"><b>fork</b></A>-and-<A HREF="#exec"><b>exec</b></A>
situations.
</DL>

<A NAME="eof"></A>
<HR><p>
<FONT SIZE=+2>Test for end of file</FONT>
<DL>
<DT><b>proc eof : boolean</b>
<DT><b>proc eof (string) : boolean</b>
<DT><b>proc eof (integer) : boolean</b>
Called with no arguments, <b>eof</b> indicates whether the last
input operation was incomplete because the end of the stream was
reached.  Called with a single argument referring to an open
stream, it returns the end-of-file status of that particular stream.
See also
<A HREF="#open"><b>open</b></A>,
<A HREF="#get"><b>get</b></A>,
<A HREF="#geta"><b>geta</b></A>,
<A HREF="#getb"><b>getb</b></A>,
<A HREF="#getc"><b>getc</b></A>,
<A HREF="#getchar"><b>getchar</b></A>,
<A HREF="#getline"><b>getline</b></A>,
<A HREF="#getn"><b>getn</b></A>,
<A HREF="#gets"><b>gets</b></A>,
<A HREF="#peekc"><b>peekc</b></A>,
<A HREF="#peekchar"><b>peekchar</b></A>,
<A HREF="#read"><b>read</b></A>,
<A HREF="#reada"><b>reada</b></A>,
<A HREF="#recv"><b>recv</b></A>, and
<A HREF="#recvfrom"><b>recvfrom</b></A>, but do not see
<A HREF="#getfile"><b>getfile</b></A>.  [(:-)]
</DL>

<A NAME="even"></A>
<HR><p>
<FONT SIZE=+2>Test for integer divisible by 2</FONT>
<DL>
<DT><b>op even (integer) : boolean</b>
</DL>

<A NAME="exec"></A>
<HR><p>
<FONT SIZE=+2>Replace current process</FONT>
<DL>
<DT><b>proc exec (string</b> <i>cmd</i><b>)</b>
<DT><b>proc exec (string</b> <i>cmd</i><b>, tuple</b> <i>argv</i><b>)</b>
<DT><b>proc exec (string</b> <i>cmd</i><b>, tuple</b> <i>argv</i><b>, tuple</b> <i>envp</i><b>)</b>
<p>
This is a low-level interface to the Posix routine <i>execve</i>(2).
The <i>cmd</i> is a full pathname identifying a command in the local
system.  If there is a second argument, <i>argv</i> it must be a <b>tuple</b>
of <b>string</b>s specifying the ``argv'' array that will be supplied
to the command.  This defaults to a one-element <b>tuple</b>,
<b>[</b><i>cmd</i><b>]</b>.  If <i>envp</i> is present, it must be
another <b>tuple</b> of <b>string</b>s defining ``envp'' for the command.
(See <i>execve</i>(2) for the meanings of ``argv'' and ``envp''.)
If <b>exec</b> is successful, it does not return; the current process
is overlaid by the new command.  The <i>execve</i>(2) routine does not
take the value of the PATH environment variable into consideration,
but you can get that effect easily without processing PATH yourself
by using something like:
<p>
  <DL>
  <DT><b>exec (</b>"/bin/sh"<b>, [</b>"-sh"<b>,</b> "-c"<b>,</b> "command and arguments"<b>]);</b>
  </DL>
<p>
<DT>Compare <A HREF="#filter"><b>filter</b></A>,
<A HREF="#system"><b>system</b></A>, and the
<A HREF="#open"><b>open</b></A> modes "PUMP", "LINE-PUMP",
"PIPE-IN", and "PIPE-OUT", one of will probably be able to achieve the
effect you want more conveniently than <b>exec</b> does.
<p>
See also <A HREF="#fork"><b>fork</b></A> and especially
<A HREF="#pump"><b>pump</b></A>.
<p>
[I'm not entirely happy with the PATH not applying to <i>cmd</i>,
even though <b>exec</b> is decidedly low-level.  Anyway, if you
stick to absolute pathnames for now, as in the above example with
"/bin/sh", you'll be safe even if PATH does get used later.
(Whatever that means.)  You accept shell expansion of your
"command and arguments" whether you like it or not with this
approach, though.]
</DL>

<A NAME="exp"></A>
<HR><p>
<FONT SIZE=+2>Natural exponential (<i>e</i> raised to a power)</FONT>
<DL>
<DT><b>op exp (real) : real</b>
<DT><b>op exp (integer) : real</b>
</DL>

<A NAME="false"></A>
<HR><p>
<FONT SIZE=+2>Predefined ``false'' boolean value</FONT>
<DL>
<DT><b>false : const boolean</b>
<p>
See also <A HREF="#true"><b>true</b></A>.
</DL>

<A NAME="fdate"></A>
<HR><p>
<FONT SIZE=+2>Format date and time</FONT>
<DL>
<DT><b>proc fdate (integer</b> <i>ms</i><b>, string</b> <i>fmt</i><b>) : string</b>
<DT><b>proc fdate (integer</b> <i>ms</i><b>) : string</b>
<p>
The <i>ms</i> argument represents some number of milliseconds since
1 January 1970 UTC, to be formatted as a date and time according to
<i>fmt</i>, which defaults to "%a %b %e %H:%M:%S.%s %Z %Y".  For
example, <b>fdate&nbsp;(</b>936433255069<b>)</b> is
"Sat&nbsp;Sep&nbsp;&nbsp;4&nbsp;04:20:55.069&nbsp;EDT&nbsp;1999" in the timezone the
author occupied at a certain moment in history, and
<b>fdate&nbsp;(<A HREF="#tod"><b>tod</b></A>)</b> is a similarly fancy
rendering of the current calendar time.
<p>
The %-sign patterns in <i>fmt</i> which expand to the various
slices of eternity embodied in <i>ms</i> are those patterns defined for
<i>strftime</i>(3) when applied to the result of applying
<i>localtime</i>(3) to <i>ms</i>&nbsp;<b>div</b>&nbsp;1000, together with one
extension:  %s will expand to the low-order 3 decimal digits of
<i>ms</i>.
<p>
See also <A HREF="#date"><b>date</b></A>, which should give the same
result as the expression <b>fdate&nbsp;(tod,&nbsp;</b>"%c"<b>)</b>.
</DL>

<A NAME="fetch_..."></A>
<A NAME="fetch_char"></A>
<A NAME="fetch_short"></A>
<A NAME="fetch_int"></A>
<A NAME="fetch_long"></A>
<A NAME="fetch_float"></A>
<A NAME="fetch_double"></A>
<A NAME="fetch_long_double"></A>
<A NAME="fetch_string"></A>
<A NAME="fetch_c_string"></A>
<HR><p>
<FONT SIZE=+2>Machine memory read</FONT>
<DL>
<DT><b>proc fetch_char (integer</b> <i>address</i><b>) : integer</b>
<DT><b>proc fetch_short (integer</b> <i>address</i><b>) : integer</b>
<DT><b>proc fetch_int (integer</b> <i>address</i><b>) : integer</b>
<DT><b>proc fetch_long (integer</b> <i>address</i><b>) : integer</b>
<DT><b>proc fetch_float (integer</b> <i>address</i><b>) : real</b>
<DT><b>proc fetch_double (integer</b> <i>address</i><b>) : real</b>
<DT><b>proc fetch_long_double (integer</b> <i>address</i><b>) : real</b>
<DT><b>proc fetch_string (integer</b> <i>address</i><b>, integer</b> <i>n</i><b>) : string</b>
<DT><b>proc fetch_c_string (integer</b> <i>address</i><b>) : string</b>
<p>
These are extremely low-level, machine-dependent, uncontrolled
procedures to get at specific locations in the computer's memory.
The <b>integer</b> <i>address</i> is assumed to contain a machine
address from which some number <i>n</i> of bytes will be read.  For
<b>fetch_string</b>, <i>n</i> is given by the second argument.  For
<b>fetch_c_string</b>, <i>n</i> is deduced using the C convention of
a null terminating character.  For <b>fetch_char</b>, <i>n</i>&nbsp;=&nbsp;1.
For all the rest, <i>n</i> is machine-dependent.  These procedures are
typically only used if you have customized a C library interface
rather roughly and want to peek inside structs based on pointers to
them without going to the trouble of mapping the structs to SETL
objects properly.
<p>
See also <A HREF="#store_..."><b>store_...</b></A>,
<A HREF="#pack_..."><b>pack_...</b></A>,
<A HREF="#unpack_..."><b>unpack_...</b></A>, and
<A HREF="#mem_copy"><b>mem_copy</b></A>.
</DL>

<A NAME="fexists"></A>
<HR><p>
<FONT SIZE=+2>Test for existence of file</FONT>
<DL>
<DT><b>op fexists (string) : boolean</b>
<p>
Return <b>true</b> if the Posix <i>stat</i>(2) routine returns 0,
indicating that the file named by the <b>string</b> exists, otherwise
<b>false</b>.
<p>
See also <A HREF="#lexists"><b>lexists</b></A>,
<A HREF="#link"><b>link</b></A>,
<A HREF="#symlink"><b>symlink</b></A>,
<A HREF="#readlink"><b>readlink</b></A>,
and <A HREF="#unlink"><b>unlink</b></A>.
</DL>

<A NAME="filename"></A>
<HR><p>
<FONT SIZE=+2>Return filename of open stream</FONT>
<DL>
<DT><b>op filename (string) : string</b>
<DT><b>op filename (integer) : string</b>
<p>
The <b>filename</b> operator returns the <b>string</b> originally
used as the first argument to <A HREF="#open"><b>open</b></A>,
if any.  Otherwise it returns <b>om</b>.
</DL>

<A NAME="fileno"></A>
<HR><p>
<FONT SIZE=+2>Return fd of open stream</FONT>
<DL>
<DT><b>op fileno (string) : integer</b>
<DT><b>op fileno (integer) : integer</b>
<p>
The <b>fileno</b> operator returns the ``file descriptor'' (fd)
associated with the open stream designated by the argument.
Applied to an fd, it should merely return that fd, but applied
to <b>om</b>, it will raise an exception, so the following idiom
is common for programs that would rather crash immediately than
continue with a non-fd result from <A HREF="#open"><b>open</b></A>:
<p>
<DL>
<DT><i>fd</i> <b>:= fileno open(...);</b>
</DL>
<p>
The nominal use of <b>fileno</b>, however, is to obtain the fd
associated with the <b>string</b> designation of a stream.
Note that SETL buffering is active regardless of whether you refer to
streams through their fd's or by their original names.  The use of
the fd is preferable from the standpoint of uniqueness, and on many
implementations is likely to be more efficient, so fd's
are the generally recommended stream designators.
</DL>

<A NAME="filter"></A>
<HR><p>
<FONT SIZE=+2>Filter string through external process</FONT>
<DL>
<DT><b>proc filter (string</b> <i>cmd</i><b>, string</b> <i>input</i><b>) : string</b>
<DT><b>proc filter (string</b> <i>cmd</i><b>) : string</b>
<p>
The <i>cmd</i> argument designates a command that reads from standard
input and writes to standard output.  The <i>input</i> argument is a
<b>string</b> (default null) that is fed into the command's
standard input, and the result <b>string</b> is the contents of
the command's standard output.  The command itself is processed by the
standard Bourne shell, <i>sh</i>(1).  Thus it may contain arguments
with patterns such as "2&gt;&amp;1" to redirect the standard error
stream into the same destination as the standard output refers to,
like the SETL call <b><A HREF="#dup2">dup2</A>&nbsp;(</b>1<b>,</b>&nbsp;2<b>)</b>
does, and may also contain special characters such as "*" for filename
``globbing''.
<p>
See also <A HREF="#status"><b>status</b></A>,
<A HREF="#system"><b>system</b></A>,
<A HREF="#pump"><b>pump</b></A>, and the
<A HREF="#open"><b>open</b></A> modes "PUMP", "LINE-PUMP",
"PIPE-IN", and "PIPE-OUT".
</DL>

<A NAME="fix"></A>
<HR><p>
<FONT SIZE=+2>Truncate floating-point number to integer</FONT>
<DL>
<DT><b>op fix (real) : integer</b>
<DT><b>op fix (integer) : integer</b>
<p>
Truncation is towards zero.  See also <A HREF="#ceil"><b>ceil</b></A>,
<A HREF="#floor"><b>floor</b></A>, and <A HREF="#round"><b>round</b></A>.
</DL>

<A NAME="float"></A>
<HR><p>
<FONT SIZE=+2>Convert to floating-point</FONT>
<DL>
<DT><b>op float (integer) : real</b>
<DT><b>op float (real) : real</b>
<p>
Note that since <b>integer</b>s in SETL are unbounded, but <b>real</b>s
are limited in an implementation-dependent way (usually to 64-bit IEEE
floating point or something close to that---the C ``double'' type for
local C implementations is likely to be the best guide to the actual
constraints), it is possible for this conversion to fail, with
unpredictable results.  Loss of precision is also possible for integers
whose absolute value is larger than what can fit in the ``mantissa''
of the local <b>real</b> representation, which is likely to be on the
order of only 50 bits or so.
<p>
[The specification for the overflow case may be tightened up at some
point to guarantee that the result be some representation of
floating-point infinity, which IEEE supports.  A clever SETL
implementation could work around a lack of such representational
support by maintaining the infinity indication in separate bits.]
</DL>

<A NAME="fixed"></A>
<A NAME="floating"></A>
<HR><p>
<FONT SIZE=+2>Format number</FONT>
<DL>
<DT><b>proc fixed (real</b> <i>x</i><b>, integer</b> <i>w</i><b>, integer</b> <i>a</i><b>) : string</b>
<DT><b>proc fixed (integer</b> <i>x</i><b>, integer</b> <i>w</i><b>, integer</b> <i>a</i><b>) : string</b>
<DT><b>proc floating (real</b> <i>x</i><b>, integer</b> <i>w</i><b>, integer</b> <i>a</i><b>) : string</b>
<DT><b>proc floating (integer</b> <i>x</i><b>, integer</b> <i>w</i><b>, integer</b> <i>a</i><b>) : string</b>
<p>
The number <i>x</i> is converted to a string of length <i>w</i>
having <i>a</i> digits after the decimal point.
The string is padded on the left with blanks.
If <i>a</i>&nbsp;=&nbsp;0, there is no decimal point.
If the converted string does not fit within the requested
length, a longer string will be produced as necessary
to accommodate the number, with no leading blanks.  The only
difference between <b>fixed</b> and <b>floating</b> is that
<b>floating</b> prints the number in ``scientific'' notation,
that is, with E+<i>dd</i> appended on the right to stand for
``times 10 to the power <i>dd</i>'', and <b>fixed</b> does not.
<p>
See also <A HREF="#whole"><b>whole</b></A>,
<A HREF="#str"><b>str</b></A>, and
<A HREF="#strad"><b>strad</b></A>.
</DL>

<A NAME="floor"></A>
<HR><p>
<FONT SIZE=+2>Greatest integer lower bound</FONT>
<DL>
<DT><b>op floor (real) : integer</b>
<DT><b>op floor (integer) : integer</b>
<p>
See also <A HREF="#ceil"><b>ceil</b></A>, <A HREF="#round"><b>round</b></A>,
and <A HREF="#fix"><b>fix</b></A>.
</DL>

<A NAME="flush"></A>
<HR><p>
<FONT SIZE=+2>Flush output buffer</FONT>
<DL>
<DT><b>proc flush (string)</b>
<DT><b>proc flush (integer)</b>
<p>
The open stream designated by the argument is ``flushed''.
This can be particularly important when streams are used to
communicate between processes.  Without a <b>flush</b>, data
can remain in a stream's output buffer for arbitrarily long
periods.  Note that the SETL implementation is supposed to
flush bidirectional streams automatically whenever a switch
is made from output to input.  This includes at least pumps,
line-pumps, sockets, some tty-like devices, and inherited ``rw''
file descriptors.
</DL>

<A NAME="fork"></A>
<HR><p>
<FONT SIZE=+2>Fork process</FONT>
<DL>
<DT><b>proc fork : integer</b>
<p>
This is a direct interface to the Posix <i>fork</i>(2) routine.
Your process splits into two processes.  In the ``parent'' process,
<b>fork</b> returns an <b>integer</b> representing the process id of
the ``child'' process.  In the child process, <b>fork</b> returns 0.
If the system cannot spawn a new process, <b>fork</b> returns
<b>om</b>, and no child process is created.
<p>
In many cases, <A HREF="#pump"><b>pump</b></A> will be preferable to
<A HREF="#fork"><b>fork</b></A> because <b>pump</b> also sets up
communication with the child without your having to go through the
customary low-level <A HREF="#pipe"><b>pipe</b></A>,
<A HREF="#dup2"><b>dup2</b></A>, and <A HREF="#close"><b>close</b></A>
calls to set up the child's environment the hard way.
<p>
See also <A HREF="#pipe_from_child"><b>pipe_from_child</b></A>,
<A HREF="#pipe_to_child"><b>pipe_to_child</b></A>,
<A HREF="#kill"><b>kill</b></A>, and
<A HREF="#exec"><b>exec</b></A>.
</DL>

<A NAME="from"></A>
<HR><p>
<FONT SIZE=+2>Take from set</FONT>
<DL>
<DT><b>op from (wr var</b> <i>x</i><b>, rw set</b> <i>s</i><b>)</b>
<p>
An arbitrary (which is not to say ``random'' but rather
<i>nondeterministically chosen</i>) element is removed from
<i>s</i> and assigned to <i>x</i>.
If <i>s</i> is empty, <i>x</i>&nbsp;:=&nbsp;<b>om</b> instead.  In this version
of SETL, <b>from</b> is actually a statement form, not an operator,
but this may be extended in the future so that the extracted
element (or <b>om</b>) is also returned as the result.
</DL>

<A NAME="fromb"></A>
<HR><p>
<FONT SIZE=+2>Take from beginning of string or tuple</FONT>
<DL>
<DT><b>op fromb (wr string</b> <i>x</i><b>, rw string</b> <i>s</i><b>)</b>
<DT><b>op fromb (wr var</b> <i>x</i><b>, rw tuple</b> <i>s</i><b>)</b>
<p>
The <b>string</b> or <b>tuple</b> <i>s</i> is
stripped of its first element, which is assigned to <i>x</i>.
If <i>s</i> is of length 0, <i>x</i>&nbsp;:=&nbsp;<b>om</b> instead.
In this version of SETL, <b>fromb</b> is actually a statement form,
not an operator, but this may be extended in the future so that
the extracted one-character string, tuple element, or <b>om</b> is
also returned as the result.
</DL>

<A NAME="frome"></A>
<HR><p>
<FONT SIZE=+2>Take from end of string or tuple</FONT>
<DL>
<DT><b>op frome (wr string</b> <i>x</i><b>, rw string</b> <i>s</i><b>)</b>
<DT><b>op frome (wr var</b> <i>x</i><b>, rw tuple</b> <i>s</i><b>)</b>
<p>
The <b>string</b> or <b>tuple</b> <i>s</i> is
stripped of its last element, which is assigned to <i>x</i>.
If <i>s</i> is of length 0, <i>x</i>&nbsp;:=&nbsp;<b>om</b> instead.
In this version of SETL, <b>frome</b> is actually a statement form,
not an operator, but this may be extended in the future so that
the extracted one-character string, tuple element, or <b>om</b> is
also returned as the result.
</DL>

<A NAME="fsize"></A>
<HR><p>
<FONT SIZE=+2>Size of disk file in bytes</FONT>
<DL>
<DT><b>op fsize (string) : integer</b>
<p>
The <b>string</b> argument should be a filename.
</DL>

<A NAME="get"></A>
<HR><p>
<FONT SIZE=+2>Get one or more lines from standard input</FONT>
<DL>
<DT><b>proc get (wr string...)</b>
<p>
Equivalent to
<A HREF="#geta"><b>geta</b></A>&nbsp;<b>(<A HREF="#std...">stdin</A>, ...)</b>.
</DL>

<A NAME="geta"></A>
<HR><p>
<FONT SIZE=+2>Get one or more lines from input stream</FONT>
<DL>
<DT><b>proc geta (string</b> <i>f</i><b>, wr string...)</b>
<DT><b>proc geta (integer</b> <i>f</i><b>, wr string...)</b>
<p>
Lines are read from the input stream <i>f</i>
and assigned to the succeeding arguments in order.
Lines are terminated by newline ("\n"), and there is no restriction
on line length.  The trailing newline character is not delivered as
part of the assigned string.  If an end-of-file condition occurs on
<i>f</i>, trailing arguments may be assigned
<b>om</b>.  The final line before the end of the input need not be
terminated by a newline.  If <i>f</i> is not already open, an attempt
will automatically be made to open it for reading.
</DL>

<A NAME="getb"></A>
<HR><p>
<FONT SIZE=+2>Get one or more values from input stream</FONT>
<DL>
<DT><b>proc getb (string</b> <i>f</i><b>, wr var...)</b>
<DT><b>proc getb (integer</b> <i>f</i><b>, wr var...)</b>
<p>
Values are read from the input stream <i>f</i> and assigned to the
succeeding arguments in order.  If the end of the input
is reached, trailing arguments may be
assigned <b>om</b>.  Values written by <A HREF="#putb"><b>putb</b></A>,
except for atoms (see <A HREF="#newat"><b>newat</b></A>) and
procedure references (see <A HREF="#routine"><b>routine</b></A>),
are guaranteed to be readable by <b>getb</b>.  If <i>f</i> is not
already open, an attempt will automatically be made to open it for
reading.
<p>
There is a subtle difference between <b>getb</b> and
<A HREF="#reada"><b>reada</b></A> in that <b>reada</b> will always
start reading at the beginning of a line, skipping ahead to just after
the next newline character if necessary, but <b>getb</b> will simply
start with the next available character in the input stream.  Both
routines will happily cross newline boundaries if necessary to obtain
more values, however.
</DL>

<A NAME="getc"></A>
<HR><p>
<FONT SIZE=+2>Get character from input stream</FONT>
<DL>
<DT><b>op getc (string</b> <i>f</i><b>) : string</b>
<DT><b>op getc (integer</b> <i>f</i><b>) : string</b>
<p>
One character is read from the input stream <i>f</i> and returned as a
string of length 1.  If there are no more characters (the end of the
file was reached), <b>getc</b> returns <b>om</b> instead.  If <i>f</i>
is not already open, an attempt will automatically be made to open it
for reading.
</DL>

<A NAME="getchar"></A>
<HR><p>
<FONT SIZE=+2>Get a character from standard input</FONT>
<DL>
<DT><b>proc getchar : string</b>
<p>
Equivalent to
<A HREF="#getc"><b>getc</b></A>&nbsp;<A HREF="#std..."><b>stdin</b></A>.
</DL>

<A NAME="getegid"></A>
<HR><p>
<FONT SIZE=+2>Get effective group id</FONT>
<DL>
<DT><b>proc getegid : integer</b>
<p>
Returns the result of calling the Posix <i>getegid</i>(2) routine.
See also <A HREF="#getgid"><b>getgid</b></A> and
<A HREF="#setgid"><b>setgid</b></A>.
</DL>

<A NAME="getenv"></A>
<HR><p>
<FONT SIZE=+2>Get value of environment variable</FONT>
<DL>
<DT><b>op getenv (string</b> <i>v</i><b>) : string</b>
<p>
If the environment variable named by the <b>string</b> <i>v</i>
exists, its value (a <b>string</b>) is returned; otherwise you get
<b>om</b>.  See also <A HREF="#putenv"><b>putenv</b></A> and
<A HREF="#setenv"><b>setenv</b></A>.
</DL>

<A NAME="geteuid"></A>
<HR><p>
<FONT SIZE=+2>Get effective user id</FONT>
<DL>
<DT><b>proc geteuid : integer</b>
<p>
Returns the result of calling the Posix <i>geteuid</i>(2) routine.
See also <A HREF="#getuid"><b>getuid</b></A> and
<A HREF="#setuid"><b>setuid</b></A>.
</DL>

<A NAME="getfile"></A>
<HR><p>
<FONT SIZE=+2>Read stream up to the end</FONT>
<DL>
<DT><b>op getfile (string</b> <i>f</i><b>) : string</b>
<DT><b>op getfile (integer</b> <i>f</i><b>) : string</b>
<p>
Characters are read into a string from the input stream <i>f</i> until
the end of the input is reached.  If the end-of-file condition is
immediate, <b>getfile</b> returns a null string.  If <i>f</i> is not
already open, an attempt will automatically be made to open it for
reading.  Since <b>getfile</b> always reads until it reaches the end
of the file, it does not alter the current value of
<A HREF="#eof"><b>eof</b></A>.
<p>
The <b>getfile</b> intrinsic is unique among routines that will
attempt to auto-open a file for input in that if <b>getfile</b>
fails on the auto-open attempt, it humbly returns <b>om</b> rather
than raising an exception.  This is part of an effort
to dissuade SETL programmers from writing racy code like
<p>
  <DL>
  <DT><i>x</i> <b>:= if fexists</b> <i>f</i> <b>then getfile</b> <i>f</i> <b>else</b> <i>default_string</i> <b>end;</b>
  </DL>
<p>
when the idiomatic
<p>
  <DL>
  <DT><i>x</i> <b>:= getfile</b> <i>f</i> <b>?</b> <i>default_string</i><b>;</b>
  </DL>
<p>
is race-free.  Of course, it would have been possible for the hardy
thinker to have coded
<p>
  <DL>
  <DT><b>if (</b><i>fd</i> <b>:= open(</b><i>f</i><b>,</b> "r"<b>)) /= om then</b>
    <DL>
    <DT><i>x</i> <b>:= getfile</b> <i>fd</i><b>;</b>
    <DT><b>close(</b><i>fd</i><b>);</b>
    </DL>
  <DT><b>else</b>
    <DL>
    <DT><i>x</i> <b>:=</b> <i>default_string</i><b>;</b>
    </DL>
  <DT><b>end if;</b>
  </DL>
<p>
but that is hardly in the spirit of a language which aims for
concise and natural expression.
</DL>

<A NAME="getgid"></A>
<HR><p>
<FONT SIZE=+2>Get real group id</FONT>
<DL>
<DT><b>proc getgid : integer</b>
<p>
Returns the result of calling the Posix <i>getgid</i>(2) routine.
See also <A HREF="#getegid"><b>getegid</b></A> and
<A HREF="#setgid"><b>setgid</b></A>.
</DL>

<A NAME="getline"></A>
<HR><p>
<FONT SIZE=+2>Get line from input stream</FONT>
<DL>
<DT><b>op getline (string</b> <i>f</i><b>) : string</b>
<DT><b>op getline (integer</b> <i>f</i><b>) : string</b>
<p>
This is an operator-form alternative to <A HREF="#geta"><b>geta</b></A>.
Characters are read up to the next newline character, and the accumulated
string is returned, not including the newline.  If the end of the input
is reached with no characters being read, <b>om</b> is returned.  If the
input stream <i>f</i> is not already open, an attempt will
automatically be made to open it for reading.
</DL>

<A NAME="getn"></A>
<HR><p>
<FONT SIZE=+2>Get fixed number of characters from input stream</FONT>
<DL>
<DT><b>proc getn (string</b> <i>f</i><b>, integer</b> <i>n</i><b>) : string</b>
<DT><b>proc getn (integer</b> <i>f</i><b>, integer</b> <i>n</i><b>) : string</b>
<p>
Exactly <i>n</i> characters are read from the input stream <i>f</i>
if at least that many remain before the end of the input.  If fewer
than <i>n</i> characters remain in the stream <i>f</i>, a shorter
string is returned.
</DL>

<A NAME="getpgrp"></A>
<HR><p>
<FONT SIZE=+2>Get process group id</FONT>
<DL>
<DT><b>proc getpgrp : integer</b>
<p>
Retrieve the process group id of the current process by calling the
Posix <i>getpgrp</i>(2) system routine.  This is the process id of the
process group leader.  See also <A HREF="#setpgrp"><b>setpgrp</b></A>
and <A HREF="#pid"><b>pid</b></A>.
</DL>

<A NAME="gets"></A>
<HR><p>
<FONT SIZE=+2>Direct-access read</FONT>
<DL>
<DT><b>proc gets (string</b> <i>f</i><b>, integer</b> <i>start</i><b>, integer</b> <i>n</i><b>, wr string</b> <i>x</i><b>)</b>
<DT><b>proc gets (integer</b> <i>f</i><b>, integer</b> <i>start</i><b>, integer</b> <i>n</i><b>, wr string</b> <i>x</i><b>)</b>
<p>
The direct-access stream <i>f</i> (see <A HREF="#open"><b>open</b></A> mode
"RANDOM") is viewed as a string, where <i>start</i> specifies the index (1 or
higher) of the first character to read.  The <b>gets</b> procedure will read
<i>n</i> characters from <i>f</i> if that many remain before the end of
the file, and assign that substring to <i>x</i>.  If fewer remain,
<i>x</i> will be assigned a shorter substring.  If the end-of-file
condition is immediate, <i>x</i>&nbsp;:=&nbsp;"" (the null string).  See also
<A HREF="#puts"><b>puts</b></A>, <A HREF="#seek"><b>seek</b></A>, and
<A HREF="#rewind"><b>rewind</b></A>.
</DL>

<A NAME="getuid"></A>
<HR><p>
<FONT SIZE=+2>Get real user id</FONT>
<DL>
<DT><b>proc getuid : integer</b>
<p>
Returns the result of calling the Posix <i>getuid</i>(2) routine.
See also <A HREF="#geteuid"><b>geteuid</b></A> and
<A HREF="#setuid"><b>setuid</b></A>.
</DL>

<A NAME="getwd"></A>
<HR><p>
<FONT SIZE=+2>Current working directory</FONT>
<DL>
<DT><b>proc getwd : string</b>
<p>
This is the current working directory of the process.
See also <A HREF="#chdir"><b>chdir</b></A>.
</DL>

<A NAME="gmark"></A>
<HR><p>
<FONT SIZE=+2>Find all occurrences of pattern in string</FONT>
<DL>
<DT><b>proc gmark (string</b> <i>s</i><b>, string</b> <i>p</i><b>) : tuple</b>
<DT><b>proc gmark (string</b> <i>s</i><b>, tuple</b> <i>p</i><b>) : tuple</b>
<p>
All non-overlapping leftmost occurrences of the regular
expression <i>p</i> are found in <i>s</i>, and the
result is returned as a tuple of pairs of integers
<b>[</b><i>i</i><b>,&nbsp;</b><i>j</i><b>]</b>,
where each matched substring of <i>s</i> can be addressed as
<i>s</i><b>(</b><i>i</i><b>..</b><i>j</i><b>)</b>.
See also <A HREF="#mark"><b>mark</b></A>,
<A HREF="#gsub"><b>gsub</b></A>, and <A HREF="#sub"><b>sub</b></A>.
<p>
[Need to spell out the exact rules for regular expressions, which
are similar to those supported by the <i>egrep</i>(1) command, and
how the ``tuple'' regexps work:  basically, the tuple must be a pair
of string regexps, meaning ``from this first regexp up to
the first subsequent occurrence of this second regexp''.  It would
also be helpful to show the near-correspondence between certain
slice-update operations and <b>sub</b>, and how the older-style
"pattern matching" operations can be regarded as degenerate forms
of the regexp-based operations.]
</DL>

<A NAME="gsub"></A>
<HR><p>
<FONT SIZE=+2>Substitute all occurrences of pattern in string</FONT>
<DL>
<DT><b>proc gsub (rw string</b> <i>s</i><b>, string</b> <i>p</i><b>) : tuple</b>
<DT><b>proc gsub (rw string</b> <i>s</i><b>, tuple</b> <i>p</i><b>) : tuple</b>
<DT><b>proc gsub (rw string</b> <i>s</i><b>, string</b> <i>p</i><b>, string</b> <i>r</i><b>) : tuple</b>
<DT><b>proc gsub (rw string</b> <i>s</i><b>, tuple</b> <i>p</i><b>, string</b> <i>r</i><b>) : tuple</b>
<p>
All non-overlapping leftmost occurrences in <i>s</i> of the pattern given
by the regular expression <i>p</i> are replaced by <i>r</i>, which
defaults to the null string.  The original substrings of <i>s</i>
replaced by this operation are returned as a <b>tuple</b> of
<b>string</b>s.  See also <A HREF="#sub"><b>sub</b></A>,
<A HREF="#gmark"><b>gmark</b></A>, and <A HREF="#mark"><b>mark</b></A>.
<p>
[Need rules for regexps, as mentioned under <A HREF="#gmark"><b>gmark</b></A>.]
</DL>

<A NAME="hex"></A>
<HR><p>
<FONT SIZE=+2>Convert to hexadecimal</FONT>
<DL>
<DT><b>op hex (string) : string</b>
<p>
For example, <b>hex</b>&nbsp;"djB"&nbsp;=&nbsp;"646A42" in an ASCII environment.
See also <A HREF="#unhex"><b>unhex</b></A>.
</DL>

<A NAME="hostaddr"></A>
<HR><p>
<FONT SIZE=+2>Local host address</FONT>
<DL>
<DT><b>proc hostaddr : string</b>
<p>
Primary Internet (IP) address of the current host, if it can be
found; otherwise <b>om</b>.
See also <A HREF="#peer_address"><b>peer_address</b></A>,
<A HREF="#ip_addresses"><b>ip_addresses</b></A>,
and <A HREF="#hostname"><b>hostname</b></A>.
</DL>

<A NAME="hostname"></A>
<HR><p>
<FONT SIZE=+2>Local hostname</FONT>
<DL>
<DT><b>proc hostname : string</b>
<p>
Primary Internet (DNS) name of the current host.
See also <A HREF="#peer_name"><b>peer_name</b></A>,
<A HREF="#ip_names"><b>ip_names</b></A>,
and <A HREF="#hostaddr"><b>hostaddr</b></A>.
</DL>

<A NAME="ichar"></A>
<HR><p>
<FONT SIZE=+2>Integer equivalent of character</FONT>
<DL>
<DT><b>op ichar (string) : integer</b>
<p>
For example, <b>ichar</b>&nbsp;"a"&nbsp;=&nbsp;97 in an ASCII environment.
<p>
The argument must be 1 character in length.  That will not
change with the advent of Unicode, but the range of the result
could then change from 0-255 to 0-65535.
<p>
See also <A HREF="#abs"><b>abs</b></A>.
</DL>

<A NAME="impl"></A>
<HR><p>
<FONT SIZE=+2>Implication</FONT>
<DL>
<DT><b>op impl (boolean, boolean) : boolean</b>
<p>
Here is the customary ``truth table'' defining this operator:
<p>
  <DL>
  <DT><b>true impl true = true</b>
  <DT><b>true impl false = false</b>
  <DT><b>false impl true = true</b>
  <DT><b>false impl false = true</b>
  </DL>
<p>
This rarely-used operator could have been ``short-circuited'' like
<A HREF="#and"><b>and</b></A>, <A HREF="#or"><b>or</b></A>, and the
query operator <A HREF="#query">``<b>?</b>''</A>, but it
isn't.
</DL>

<A NAME="in"></A>
<HR><p>
<FONT SIZE=+2>Membership test</FONT>
<DL>
<DT><b>op in (var</b> <i>x</i><b>, set</b> <i>s</i><b>) : boolean</b>
<DT><b>op in (var</b> <i>x</i><b>, tuple</b> <i>s</i><b>) : boolean</b>
<DT><b>op in (string</b> <i>x</i><b>, string</b> <i>s</i><b>) : boolean</b>
<p>
The keyword <b>in</b> is also used in a common iterator form, as in
<p>
<DL>
<DT><b>for</b> <i>x</i> <b>in</b> <i>s</i> <b>loop</b>
  <DL>
  <DT><b>...</b>
  </DL>
<DT><b>end loop;</b>
</DL>
or
<DL>
<DT><i>squares</i> <b>:= {</b><i>x</i><b>*</b><i>x</i> <b>:</b> <i>x</i> <b>in</b> <i>s</i><b>};</b>
</DL>
<p>
This use of <b>in</b> as an iterator should not be confused with its use
as a membership test, where it is simply a <b>boolean</b>-valued binary
operator.
<p>
For <b>string</b>s <i>x</i> and <i>s</i>, the expression
<i>x</i>&nbsp;<b>in</b>&nbsp;<i>s</i> is <b>true</b> if <i>x</i> is a substring
of <i>s</i>.
</DL>

<A NAME="incs"></A>
<HR><p>
<FONT SIZE=+2>Subset test</FONT>
<DL>
<DT><b>op incs (set</b> <i>s</i><b>, set</b> <i>ss</i><b>) : boolean</b>
<p>
Returns <b>true</b> if <i>ss</i> is a subset of <i>s</i>.
Thus
<b>(</b><i>s</i>&nbsp;<b>incs</b>&nbsp;<i>ss</i><b>)&nbsp;=&nbsp;(</b><i>ss</i>&nbsp;<A HREF="#subset"><b>subset</b></A>&nbsp;<i>s</i><b>)</b>.
</DL>

<A NAME="intslash"></A>
<HR><p>
<FONT SIZE=+2>Integer quotient type switch</FONT>
<DL>
<DT><b>intslash : boolean</b>
<p>
By default, the result of dividing two <b>integer</b> values in SETL is
<b>real</b>, as in Pascal and in the Algol family (and as opposed to
the Fortran/C/SETL2 family).  This default corresponds to
<b>intslash&nbsp;=&nbsp;false</b>.  See <A HREF="#/">``<b>/</b>''</A> for a
rather heated and windy argument in favour of leaving it set this way,
and see also <A HREF="#set_intslash"><b>set_intslash</b></A> for the
preferred way of changing it should you desire to do so.
</DL>

<A NAME="ip_addresses"></A>
<HR><p>
<FONT SIZE=+2>Internet addresses</FONT>
<DL>
<DT><b>proc ip_addresses : set</b>
<DT><b>proc ip_addresses (string) : set</b>
<p>
Called with no parameters, <b>ip_addresses</b> returns the set of all
Internet (IP) addresses of the machine hosting the current process,
as strings like "128.122.129.66".  Otherwise, it returns a set of
such strings for the host whose name or IP address is given in
dotted notation by the <b>string</b> parameter.
<p>
See also <A HREF="#hostaddr"><b>hostaddr</b></A>,
<A HREF="#peer_address"><b>peer_address</b></A>, and
<A HREF="#ip_names"><b>ip_names</b></A>.
</DL>

<A NAME="ip_names"></A>
<HR><p>
<FONT SIZE=+2>Internet hostnames</FONT>
<DL>
<DT><b>proc ip_names : set</b>
<DT><b>proc ip_names (string) : set</b>
<p>
Called with no parameters, <b>ip_names</b> returns the set of all
Internet (IP) names of the machine hosting the current process,
as strings like "GALT.CS.NYU.EDU".  Otherwise, it returns a set of
such strings for the host whose name or IP address is given in
dotted notation by the <b>string</b> parameter.
<p>
See also <A HREF="#hostname"><b>hostname</b></A>,
<A HREF="#peer_name"><b>peer_name</b></A>, and
<A HREF="#ip_addresses"><b>ip_addresses</b></A>.
</DL>

<A NAME="is_..."></A>
<A NAME="is_atom"></A>
<A NAME="is_boolean"></A>
<A NAME="is_integer"></A>
<A NAME="is_map"></A>
<A NAME="is_mmap"></A>
<A NAME="is_numeric"></A>
<A NAME="is_om"></A>
<A NAME="is_real"></A>
<A NAME="is_routine"></A>
<A NAME="is_set"></A>
<A NAME="is_smap"></A>
<A NAME="is_string"></A>
<A NAME="is_tuple"></A>
<HR><p>
<FONT SIZE=+2>Type testers</FONT>
<DL>
<DT><b>op is_atom (var</b> <i>x</i><b>) : boolean</b>
<DT><b>op is_boolean (var</b> <i>x</i><b>) : boolean</b>
<DT><b>op is_integer (var</b> <i>x</i><b>) : boolean</b>
<DT><b>op is_map (var</b> <i>x</i><b>) : boolean</b>
<DT><b>op is_mmap (var</b> <i>x</i><b>) : boolean</b>
<DT><b>op is_numeric (var</b> <i>x</i><b>) : boolean</b>
<DT><b>op is_om (var</b> <i>x</i><b>) : boolean</b>
<DT><b>op is_real (var</b> <i>x</i><b>) : boolean</b>
<DT><b>op is_routine (var</b> <i>x</i><b>) : boolean</b>
<DT><b>op is_set (var</b> <i>x</i><b>) : boolean</b>
<DT><b>op is_smap (var</b> <i>x</i><b>) : boolean</b>
<DT><b>op is_string (var</b> <i>x</i><b>) : boolean</b>
<DT><b>op is_tuple (var</b> <i>x</i><b>) : boolean</b>
<p>
The operator <b>is_map</b> (or equivalently <b>is_mmap</b>) returns
<b>true</b> if <i>x</i> is a set consisting entirely of
ordered pairs (<b>tuple</b>s of length 2).  The operator <b>is_smap</b>
adds the further condition that <b>#domain</b>&nbsp;<i>x</i>&nbsp;=&nbsp;<b>#</b><i>x</i>,
which is to say that the map is ``single-valued'' in the sense of taking
every domain element to just one range element.
</DL>

<A NAME="is_open"></A>
<HR><p>
<FONT SIZE=+2>Test for open stream</FONT>
<DL>
<DT><b>op is_open (string</b> <i>f</i><b>) : boolean</b>
<DT><b>op is_open (integer</b> <i>f</i><b>) : boolean</b>
<p>
Returns <b>true</b> if <i>f</i> is one of the pre-opened
streams <A HREF="#stdin"><b>stdin</b></A>,
<A HREF="#stdout"><b>stdout</b></A>,
or <A HREF="#stderr"><b>stderr</b></A>,
a stream opened by <A HREF="#open"><b>open</b></A>,
or an automatically opened stream, provided the stream is still open.
</DL>

<A NAME="kill"></A>
<HR><p>
<FONT SIZE=+2>Send signal to process</FONT>
<DL>
<DT><b>proc kill (integer</b> <i>p</i><b>)</b>
<DT><b>proc kill (integer</b> <i>p</i><b>, integer</b> <i>signal</i><b>)</b>
<DT><b>proc kill (integer</b> <i>p</i><b>, string</b> <i>signal</i><b>)</b>
<p>
Calls the Posix <i>kill</i>(2) routine on <i>p</i>, which is a process
number if positive.  If <i>p</i> is negative and not equal to -1, then
<i>-p</i> is a process group id, and the signal is sent to every
process in that process group.  If <i>p</i> is -1, the signal is sent
to every process owned by the caller.  If <i>p</i> is 0, the
meaning is system-dependent, and if <i>p</i> indicates a nonexistent
process or process group, the call has no effect except to set
<A HREF="#last_error"><b>last_error</b></A>.
<p>
If <i>signal</i> is omitted, it defaults to "TERM", or equivalently
"SIGTERM".  Signals may be specified as integers or more portably
as strings.  Case is not significant.  The signal names
HUP, INT, QUIT, ILL, ABRT, FPE, KILL, SEGV, PIPE, ALRM, TERM,
USR1, USR2, CHLD, CONT, STOP, TSTP, TTIN, and TTOU
are defined by POSIX.1; see your local <i>kill</i>(2) documentation (or
perhaps <i>signal</i>(2) or <i>signal</i>(5), or the C ``header'' files
customarily found under the /usr/include directory) for additional
signal names that may also be available on your system.
<p>
See also <A HREF="#pid"><b>pid</b></A>, <A HREF="#fork"><b>fork</b></A>,
<A HREF="#pump"><b>pump</b></A>,
<A HREF="#pipe_from_child"><b>pipe_from_child</b></A>,
<A HREF="#pipe_to_child"><b>pipe_to_child</b></A>, and
<A HREF="#pexists"><b>pexists</b></A> for more details on processes, and
the <A HREF="#clear_error"><b>clear_error</b></A> example for more
information on detecting and handling errors.
</DL>

<A NAME="last_error"></A>
<HR><p>
<FONT SIZE=+2>Last error message from system routine</FONT>
<DL>
<DT><b>last_error : string</b>
<p>
This is the error message corresponding to the last setting
of the C global variable ``errno'' by a Posix routine.
See also <A HREF="#clear_error"><b>clear_error</b></A> and
<A HREF="#no_error"><b>no_error</b></A>.
</DL>

<A NAME="len"></A>
<HR><p>
<FONT SIZE=+2>Break out initial substring based on length</FONT>
<DL>
<DT><b>proc len (rw string</b> <i>s</i><b>, integer</b> <i>n</i><b>) : string</b>
<p>
The lesser of <i>n</i> and <b>#</b><i>s</i> characters are
removed from the beginning of <i>s</i> and returned as the function
result.  See also <A HREF="#rlen"><b>rlen</b></A>.
</DL>

<A NAME="less"></A>
<HR><p>
<FONT SIZE=+2>Set less one element</FONT>
<DL>
<DT><b>op less (set, var) : set</b>
<p>
Definition:
<i>s</i>&nbsp;<b>less</b>&nbsp;<i>x</i>&nbsp;=&nbsp;<i>s</i>&nbsp;<b>-&nbsp;{</b><i>x</i><b>}</b>.
</DL>

<A NAME="lessf"></A>
<HR><p>
<FONT SIZE=+2>Map less one domain element</FONT>
<DL>
<DT><b>op lessf (set</b> <i>s</i><b>, var</b> <i>x</i><b>) : set</b>
<p>
The <b>set</b> <i>s</i> must be a map.  The <b>lessf</b> operator
returns a copy of the map in which all pairs having <i>x</i> as a
domain element are removed.
</DL>

<A NAME="lexists"></A>
<HR><p>
<FONT SIZE=+2>Test for existence of symbolic link</FONT>
<DL>
<DT><b>op lexists (string) : boolean</b>
<p>
Return <b>true</b> if <i>lstat</i>(2) returns 0,
indicating that the symbolic link named by the <b>string</b> exists,
otherwise <b>false</b>.
<p>
See also <A HREF="#fexists"><b>fexists</b></A>,
<A HREF="#link"><b>link</b></A>,
<A HREF="#symlink"><b>symlink</b></A>,
<A HREF="#readlink"><b>readlink</b></A>, and
<A HREF="#unlink"><b>unlink</b></A>.
<p>
When <b>fexists</b> is applied to a symbolic link, it interrogates the
existence of the file referred to by that link, whereas when
<b>lexists</b> is applied to a symbolic link, it interrogates the
existence of the link itself.
<!--
<p>
[TODO:  introduce <b>readlink</b> after <i>readlink</i>(), to find out
what a symbolic link points to, i.e., what would be to the right of
the arrow in the output of ``<i>ls -l</i>''.]
-->
</DL>

<A NAME="link"></A>
<HR><p>
<FONT SIZE=+2>Create hard link</FONT>
<DL>
<DT><b>proc link (string</b> <i>existing</i><b>, string</b> <i>new</i><b>)</b>
<p>
Atomically create a ``hard link'' <i>new</i> to the existing file
<i>existing</i> using <i>link</i>(2), if
<i>new</i> does not exist before the call.  There is no return value,
but calling <A HREF="#clear_error"><b>clear_error</b></A> before the
operation and inspecting <A HREF="#last_error"><b>last_error</b></A>
after it can be used to determine whether the operation was successful.
Thus <b>link</b> can be used to implement a ``test and set'' mutex lock
in the file system:  assuming <i>existing</i> exists, then if
<i>new</i> also exists, the operation will fail; and if it doesn't
exist, it will be created and the calling process will then ``own'' the
lock.
<p>
See also <A HREF="#symlink"><b>symlink</b></A>,
<A HREF="#unlink"><b>unlink</b></A>, and
<A HREF="#fexists"><b>fexists</b></A>.
</DL>

<A NAME="log"></A>
<HR><p>
<FONT SIZE=+2>Natural logarithm</FONT>
<DL>
<DT><b>op log (real) : real</b>
<DT><b>op log (integer) : real</b>
</DL>

<A NAME="lpad"></A>
<HR><p>
<FONT SIZE=+2>Pad string on left with blanks</FONT>
<DL>
<DT><b>proc lpad (string</b> <i>s</i><b>, integer</b> <i>n</i><b>) : string</b>
<p>
If <i>n</i>&nbsp;<b>&gt;&nbsp;#</b><i>s</i>, the returned <b>string</b> is a
copy of <i>s</i> padded on the left with blanks to length <i>n</i>.
Otherwise, (a copy of) <i>s</i> is returned.  See also
<A HREF="#rpad"><b>rpad</b></A>.
</DL>

<A NAME="magic"></A>
<HR><p>
<FONT SIZE=+2>Regular expressions switch</FONT>
<DL>
<DT><b>magic : boolean</b>
<p>
By default, <b>magic&nbsp;=&nbsp;true</b>, meaning that subscripting and
slicing of strings by pattern strings causes the pattern strings to
be interpreted as regular expressions.  This also affects
<A HREF="#sub"><b>sub</b></A>, <A HREF="#gsub"><b>gsub</b></A>,
<A HREF="#mark"><b>mark</b></A>, <A HREF="#gmark"><b>gmark</b></A>,
and <A HREF="#split"><b>split</b></A>.  You can assign
<b>magic&nbsp;:=&nbsp;false</b> to turn off this behaviour, so that pattern
strings are interpreted literally.  It is a good idea to save and
restore the value of <b>magic</b> in any utility routines you write
that need to have it set one way or the other.  See also
<A HREF="#set_magic"><b>set_magic</b></A> for the preferred way of
setting this switch.
</DL>

<A NAME="mark"></A>
<HR><p>
<FONT SIZE=+2>Find first occurrence of pattern in string</FONT>
<DL>
<DT><b>proc mark (string</b> <i>s</i><b>, string</b> <i>p</i><b>) : tuple</b>
<DT><b>proc mark (string</b> <i>s</i><b>, tuple</b> <i>p</i><b>) : tuple</b>
<p>
The leftmost occurrence if any of the regular expression
<i>p</i> is found in <i>s</i>, and the
result is returned as a pair of integers
<b>[</b><i>i</i><b>,&nbsp;</b><i>j</i><b>]</b>
such that the matched substring of <i>s</i> can be addressed as
<i>s</i><b>(</b><i>i</i><b>..</b><i>j</i><b>)</b>.
If there is no such occurrence, <b>om</b> is returned.
See also <A HREF="#gmark"><b>gmark</b></A>,
<A HREF="#sub"><b>sub</b></A>, and
<A HREF="#gsub"><b>gsub</b></A>.
<p>
[Need rules for regexps, as mentioned under <A HREF="#gmark"><b>gmark</b></A>.]
</DL>

<A NAME="match"></A>
<HR><p>
<FONT SIZE=+2>Break out initial substring based on exact match</FONT>
<DL>
<DT><b>proc match (rw string</b> <i>s</i><b>, string</b> <i>p</i><b>) : string</b>
<p>
If <i>p</i> occurs as an initial substring of <i>s</i>,
it is removed from <i>s</i> and returned as the function result.
Otherwise, nothing happens to <i>s</i> and the null string is returned.
See also <A HREF="#rmatch"><b>rmatch</b></A>.
</DL>

<A NAME="max"></A>
<HR><p>
<FONT SIZE=+2>Numeric maximum</FONT>
<DL>
<DT><b>op max (integer, integer) : integer</b>
<DT><b>op max (integer, real) : real</b>
<DT><b>op max (real, integer) : real</b>
<DT><b>op max (real, real) : real</b>
</DL>

<A NAME="mem_alloc"></A>
<HR><p>
<FONT SIZE=+2>Allocate machine memory</FONT>
<DL>
<DT><b>proc mem_alloc (integer</b> <i>n</i><b>) : integer</b>
<p>
This is an extremely low-level interface to the <i>malloc</i>(3)
routine that should never be needed in ``normal'' SETL use.
It allocates <i>n</i> bytes of system memory and returns
the address of that memory.  It is typically only used if you
have customized a C library interface rather roughly and need to
supply the address of a struct to some C function without going
to the trouble of mapping the struct to a SETL value properly.
<p>
See also
<A HREF="#mem_copy"><b>mem_copy</b></A> and
<A HREF="#mem_free"><b>mem_free</b></A>.
</DL>

<A NAME="mem_copy"></A>
<HR><p>
<FONT SIZE=+2>Copy machine memory</FONT>
<DL>
<DT><b>proc mem_copy (integer</b> <i>dst</i><b>, integer</b> <i>src</i><b>, integer</b> <i>n</i><b>)</b>
<p>
This is an extremely low-level procedure for copying machine memory.
It is very dangerous and should be needed in ``normal'' SETL use.
It copies <i>n</i> bytes starting at any <i>src</i> address to
consecutive locations starting at any <i>dst</i> address.
If <b>{</b><i>src</i><b>..</b><i>src</i><b>+</b><i>n</i><b>-</b>1<b>} *
{</b><i>dst</i><b>..</b><i>dst</i><b>+</b><i>n</i><b>-</b>1<b>} /= {}</b>
(the memory regions overlap), the copying may produce unexpected results.
<p>
See also
<A HREF="#mem_alloc"><b>mem_alloc</b></A>,
<A HREF="#mem_free"><b>mem_free</b></A>,
<A HREF="#fetch_..."><b>fetch_...</b></A>, and
<A HREF="#store_..."><b>store_...</b></A>.
</DL>

<A NAME="mem_free"></A>
<HR><p>
<FONT SIZE=+2>Free machine memory</FONT>
<DL>
<DT><b>proc mem_free (integer)</b>
<p>
This is an extremely low-level interface to the <i>free</i>(3)
routine that should never be needed in ``normal'' SETL use.
Pass it an address as returned by <A HREF="#mem_alloc"><b>mem_alloc</b></A>
when (and only when) you are sure that the memory block
associated with that address can be released.  Wildly
unpredictable results can ensue if you try to free a given block
twice, or try in any way to refer to a block you have already freed.
<p>
See also <A HREF="#mem_copy"><b>mem_copy</b></A>.
</DL>

<A NAME="min"></A>
<HR><p>
<FONT SIZE=+2>Numeric minimum</FONT>
<DL>
<DT><b>op min (integer, integer) : integer</b>
<DT><b>op min (integer, real) : real</b>
<DT><b>op min (real, integer) : real</b>
<DT><b>op min (real, real) : real</b>
</DL>

<A NAME="mod"></A>
<HR><p>
<FONT SIZE=+2>Integer modulus, symmetric set difference</FONT>
<DL>
<DT><b>op mod (integer, integer) : integer</b>
<DT><b>op mod (set, set) : set</b>
<p>
SETL guarantees a non-negative remainder as the result of <b>mod</b>,
following the usual mathematical definition.  The sign of the divisor
is ignored, so:
<p>
  <DL>
  <DT>5 <b>mod</b> 3 <b>=</b> 2
  <DT><b>-</b>5 <b>mod</b> 3 <b>=</b> 1
  <DT>5 <b>mod -</b>3 <b>=</b> 2
  <DT><b>-</b>5 <b>mod -</b>3 <b>=</b> 1
  </DL>
<p>
The use of a single operator name for both the non-commutative,
non-associative operation of integer modulus and the commutative,
associative operation of symmetric set difference is an unfortunate
matter of history.
<p>
The set-theoretic <b>mod</b> is analogous to the boolean ``exclusive
or'' or ``not equals'' operator.
<p>
See also <A HREF="#div"><b>div</b></A> and
<A HREF="#rem"><b>rem</b></A>.
</DL>

<A NAME="nargs"></A>
<HR><p>
<FONT SIZE=+2>Number of arguments passed to subroutine</FONT>
<DL>
<DT><b>nargs : const integer</b>
<p>
This is particularly useful in cases where there
is a possibility of trailing <b>om</b> and/or writable
parameters on procedures that take a variable number of arguments.
Note that <b>nargs</b> is the <i>total</i> number of arguments
passed to the currently active routine, including the required ones.
It is a constant in that you cannot assign to it, but of course its
value will depend on which routine is currently active.
</DL>

<A NAME="newat"></A>
<HR><p>
<FONT SIZE=+2>Create new atom</FONT>
<DL>
<DT><b>proc newat : atom</b>
<p>
This creates a unique <b>atom</b>, whose salient property is
merely that it is different from all other <b>atom</b>s created
by the current process.
</DL>

<A NAME="no_error"></A>
<HR><p>
<FONT SIZE=+2>Non-error message</FONT>
<DL>
<DT><b>no_error : string</b>
<p>
This is the value <A HREF="#last_error"><b>last_error</b></A>
has immediately after a call to
<A HREF="#clear_error"><b>clear_error</b></A>.
</DL>

<A NAME="not"></A>
<HR><p>
<FONT SIZE=+2>Logical negation</FONT>
<DL>
<DT><b>op not (boolean) : boolean</b>
</DL>

<A NAME="notany"></A>
<HR><p>
<FONT SIZE=+2>Break out initial character</FONT>
<DL>
<DT><b>proc notany (rw string</b> <i>s</i><b>, string</b> <i>p</i><b>) : string</b>
<p>
If the first character of <i>s</i> does not appear anywhere in the string
<i>p</i>, that character is removed from <i>s</i> and returned as the
function result.  Otherwise, nothing happens to <i>s</i>, and the null
string is returned.  See also <A HREF="#any"><b>any</b></A>,
<A HREF="#rnotany"><b>rnotany</b></A>, and
<A HREF="#rany"><b>rany</b></A>.
</DL>

<A NAME="notin"></A>
<HR><p>
<FONT SIZE=+2>Membership test</FONT>
<DL>
<DT><b>op notin (var</b> <i>x</i><b>, set</b> <i>s</i><b>) : boolean</b>
<DT><b>op notin (var</b> <i>x</i><b>, tuple</b> <i>s</i><b>) : boolean</b>
<DT><b>op notin (string</b> <i>x</i><b>, string</b> <i>s</i><b>) : boolean</b>
<p>
Definition:
<i>x</i>&nbsp;<b>notin</b>&nbsp;<i>s</i>&nbsp;=&nbsp;<b>not&nbsp;(</b><i>x</i>&nbsp;<A HREF="#in"><b>in</b></A>&nbsp;<i>s</i><b>)</b>.
</DL>

<A NAME="npow"></A>
<HR><p>
<FONT SIZE=+2>All subsets of a given size</FONT>
<DL>
<DT><b>op npow (integer</b> <i>n</i><b>, set</b> <i>s</i><b>) : set</b>
<DT><b>op npow (set</b> <i>s</i><b>, integer</b> <i>n</i><b>) : set</b>
<p>
Definition: <i>s</i>&nbsp;<b>npow</b>&nbsp;<i>n</i>&nbsp;<b>=</b>&nbsp;<i>n</i>&nbsp;<b>npow</b>&nbsp;<i>s</i>&nbsp;<b>=&nbsp;{</b><i>ss</i>&nbsp;<b>in</b>&nbsp;<A HREF="#pow"><b>pow</b></A>&nbsp;<i>s</i>&nbsp;<b>|&nbsp;#</b><i>ss</i>&nbsp;<b>=</b>&nbsp;<i>n</i><b>}</b>,
i.e., the set of all subsets of <i>s</i> that have <i>n</i> members.
For <i>m</i>&nbsp;<b>=&nbsp;#</b><i>s</i>&nbsp;<b>&gt;=</b>&nbsp;<i>n</i>&nbsp;<b>&gt;=</b>&nbsp;0,
the number of such subsets is
<i>m</i><b>!/(</b><i>m</i><b>-</b><i>n</i><b>)!</b><i>n</i><b>!</b>.
</DL>

<A NAME="nprint"></A>
<HR><p>
<FONT SIZE=+2>Print to standard output with no trailing newline</FONT>
<DL>
<DT><b>proc nprint (...)</b>
<p>
Equivalent to
<A HREF="#nprinta"><b>nprinta</b></A>&nbsp;<b>(<A HREF="#std...">stdout</A>, ...)</b>.
</DL>

<A NAME="nprinta"></A>
<HR><p>
<FONT SIZE=+2>Print to output stream with no trailing newline</FONT>
<DL>
<DT><b>proc nprinta (string</b> <i>f</i><b>, ...)</b>
<DT><b>proc nprinta (integer</b> <i>f</i><b>, ...)</b>
<p>
There can be 0 or more arguments after <i>f</i>, of any type.
They are sent in sequence to the stream <i>f</i>, separated by single
spaces.  String arguments
are written directly; all others are written as if they had
been passed through <A HREF="#str"><b>str</b></A> first.
<p>
Note that the output of the program
<p>
  <DL>
  <DT><b>nprinta (<A HREF="#std...">stdout</A>,</b> 1<b>,</b> 2<b>);</b>
  </DL>
<p>
is ``1&nbsp;2'', which is not the same as the output of the program
<p>
  <DL>
  <DT><b>nprinta (stdout,</b> 1<b>);</b>
  <DT><b>nprinta (stdout,</b> 2<b>);</b>
  </DL>
<p>
which is ``12''.
<p>
See also <A HREF="#nprint"><b>nprint</b></A> and
<A HREF="#printa"><b>printa</b></A>.
</DL>

<A NAME="odd"></A>
<HR><p>
<FONT SIZE=+2>Test for integer not divisible by 2</FONT>
<DL>
<DT><b>op odd (integer) : boolean</b>
</DL>

<A NAME="om"></A>
<HR><p>
<FONT SIZE=+2>The ``undefined'' value</FONT>
<DL>
<DT><b>om</b>
<p>
This is the default value of all uninitialized SETL variables,
undefined set, range, or tuple elements, the implicit return value
of all <b>proc</b> routines that are not defined to return anything
else, and the default result of various operations when they do not
``succeed'' in obtaining a primary result.  <b>Om</b> really has no
type, but
<A HREF="#type"><b>type</b></A>&nbsp;<b>om&nbsp;=</b>&nbsp;"OM", and
<A HREF="#str"><b>str</b></A>&nbsp;<b>om&nbsp;=</b>&nbsp;"*".
</DL>

<A NAME="open"></A>
<HR><p>
<FONT SIZE=+2>Open stream</FONT>
<DL>
<DT><b>proc open (string</b> <i>f</i><b>, string</b> <i>how</i><b>) : integer</b>
<DT><b>proc open (integer</b> <i>f</i><b>, string</b> <i>how</i><b>) : integer</b>
<p>
This procedure returns an <b>integer</b> file descriptor (fd) for
<i>f</i>, which may be a <b>string</b> or may be an <b>integer</b> fd
that is open at the operating system level but not at the SETL level.
If <b>open</b> cannot open the file, pipe, command, socket, or whatever
<i>f</i> identifies, it raises an exception or returns <b>om</b>.
<p>
[Obviously the intention is to return <b>om</b> for things like
unwriteable files and unreachable hosts, and to trap for things
that look like clear mistakes.  But in the absence of a formal
specification of all relevant exceptional conditions, I must leave
the semantics of all <b>open</b>s that don't succeed as simply
``undefined''.  This does not even rule out erroneously returning an
integer when for example an open-on-fd looks good until the first
I/O operation is then attempted.  Implementations are implicitly
expected to catch as much as they can at the time of <b>open</b>,
but I know of no specific legal documents on this.  My dissertation
is a bit more specific.]
<p>
[I've been a bit schizophrenic about what to call fd's.  They seem to
be ``stream designators'' all over the place now, which isn't quite
right since the advent of UDP sockets (which are not streams).
``Streams'' is a good enough informal term anyway, but I think I
should adopt the traditional term ``file descriptor'' which after all
gave rise to this ``fd'' convention, and just point out here in the
<b>open</b> documentation that the ``file'' can be any of the world
of wonders suggested by the mighty list below.]
<p>
[On Unix-like systems, the fd's correspond directly to standard fd's,
which are small integers, but here again we stray from what should be
part of the standard semantics.  New programmers may be a bit mystified
as to what <b>open</b> actually <em>does</em>, and the best examples
are probably <em>not</em> old-fashioned files, but rather client sockets
(the connection to the server must be established) and pipes (the
co-process must be started).  Of course, implementations have to do
a bunch of other housekeeping, like setting up I/O buffers, and in
fact the existence of buffering should be written right into the
semantics of streams so that the programmer's responsibilities with
respect to flushing can be specified the more clearly.]
<p>
This is almost upward-compatible with the <b>open</b>
described in the Schwartz <i>et al.</i> textbook, and completely
compatible for programs which ignored the return value, because
all the I/O routines accept the argument that was originally
passed to <b>open</b> if it is unambiguous (i.e., if there isn't
more than one stream by that name open at once - note, however,
that multiple opens of a file, socket, or subcommand under the
same name are perfectly
reasonable under normal circumstances, so some danger of
ambiguity lurks in the direct use of the original <i>f</i> on
I/O calls for those cases).  This <b>open</b> is also compatible
with SETL2 in that the file descriptor serves as a unique handle.
<p>
But this <b>open</b> offers far more I/O modes, including network,
inter-process, pipe, co-process (pump), signal, and timing streams,
than any previous definition.  See the second table below.
<p>
There are three predefined streams with the following aliases:
<p>
<TABLE BORDER>
<TR> <TH>fd</TH>  <TH>aliases</TH>  <TH>meaning</TH> </TR>
<TR> <TD><A HREF="#std..."><b>stdin</b></A></TD>  <TD>0,"","-","input","INPUT","stdin"</TD>  <TD>standard input</TD> </TR>
<TR> <TD><A HREF="#std..."><b>stdout</b></A></TD>  <TD>1,"","-","output","OUTPUT","stdout"</TD> <TD>standard output</TD> </TR>
<TR> <TD><A HREF="#std..."><b>stderr</b></A></TD>  <TD>2,"error","ERROR","stderr"</TD>  <TD>standard error</TD> </TR>
</TABLE>
<p>
Files whose actual names are "input", "ERROR", etc.
may still be referred to by explicitly opening them
before starting I/O on them.  This will cause such
names not to act as standard aliases again until
they are closed as streams.
<p>
The null string acts as <b>stdin</b> or <b>stdout</b>depending on
the direction of the stream operation.  Likewise "-".
<p>
You can <A HREF="#close"><b>close</b></A> <b>stdin</b>, <b>stdout</b>,
or <b>stderr</b> at any time, and on Unix-like systems the next
<b>open</b> will choose the lowest fd, providing a mechanism by which
you can implement redirection &agrave; la shell.  See also
<A HREF="#dup2"><b>dup2</b></A>.
<p>
The <A HREF="#fileno"><b>fileno</b></A> operator
returns the fd of any open stream.
<p>
[Perhaps the deliberate violation of abstraction bears mention here:
<b>stdin</b>, <b>stdout</b>, and <b>stderr</b> really are the integers
0, 1, and 2 respectively, not (as you might think they should be) a
proper <b>file*</b> type or something.  The point is that integers are
easier to exchange with programs written in other languages, being more
universal than any particular language's ``file'' type.  This is a
communications feature, not an exercise in academic purity.
<p>
On the other hand, I am a would-be academic purist, so I am far from happy
with this, and I would suggest to those who are writing SETL programs
as prototypes of Ada programs that they introduce a unary <b>ifd*</b>
operator, implemented as the identity function on (some) integers, to
serve as a placeholder for an operator to extract the integer within a
<b>file*</b>.  This is not a conversion operator, and should have no
inverse.  The only way to obtain a <b>file*</b> from an <b>integer</b>
would be (as at present) to call <b>open</b> on a file descriptor that
is already open at the underlying system level.
<p>
Should <b>ifd*</b> be built in to SETL?  What do you think?  Send
<A HREF="mailto:bacon@cs.nyu.edu">me</A> your comments and opinions
before it's too late!]
<p>
The <A HREF="#is_open"><b>is_open</b></A> operator can be used to
test whether a stream is open without otherwise disturbing it,
and is in fact the only thing you can call without error or
side-effects on a stream that is not open.
<p>
Note that many input and output routines open files
automatically on first reference if they can.
<p>
Any file that has been automatically opened for input
will be automatically closed on end-of-file.  The only
routine that auto-closes an auto-opened output file is
<A HREF="#putfile"><b>putfile</b></A>.
<p>
Summary and hints:
<p>
<LI> For simplicity at the risk of ambiguity, code <b>open</b> in
statement form and use whatever you passed to it as a handle everywhere.
<LI> Or, for SETL2 compatibility and a bit of extra efficiency, use the
result of <b>open</b> as the file handle.
<LI> If <b>open</b> fails, it may return <b>om</b>.  The value of
<A HREF="#last_error"><b>last_error</b></A> will give the cause in
<b>string</b> form.
<LI> Put <i>fd</i> <b>:= fileno open (...)</b> to make sure <b>open</b>
does not return <b>om</b> (otherwise <A HREF="#fileno"><b>fileno</b></A>
raises an exception).
<p>
Here are the valid second argument (<i>how</i>) values for <b>open</b>.
They are case-insensitive, despite their presentation.  The modes
towards the end of the table, presented with a lowercase "b" in them,
and the modes with the word "BINARY" in them, are completely redundant
with other modes in the table on Unix systems, but in the
stream-oriented cases may be more ``raw'' on non-Unix systems, though
it is more likely that even on those systems, they will still be
redundant and that any nonsense such as inserting a carriage return
before each newline character will have to be done by completely
independent external filters.  Where simple files are concerned,
all the semantically distinguishable <b>open</b> modes are actually
captured in the first 8 entries.  For fifos, processes, networks,
signals, and timers, though, there is a world of wonders starting
at "rw":
<p>
[It would probably be better to present these as groups of synonyms.]
<p>
<TABLE BORDER>
<TR> <TH><i>how</i></TH>      <TH>meaning</TH> </TR>
<TR> <TD>"r"</TD>             <TD>stream input</TD> </TR>
<TR> <TD>"w"</TD>             <TD>stream output</TD> </TR>
<TR> <TD>"a"</TD>             <TD>stream output at end</TD> </TR>
<TR> <TD>"n"</TD>             <TD>stream output to new file</TD> </TR>
<TR> <TD>"r+"</TD>            <TD>direct access</TD> </TR>
<TR> <TD>"w+"</TD>            <TD>direct access, empty file first</TD> </TR>
<TR> <TD>"a+"</TD>            <TD>direct access, write at end</TD> </TR>
<TR> <TD>"n+"</TD>            <TD>direct access, new file</TD> </TR>
<TR> <TD>"INPUT"</TD>         <TD>stream input</TD> </TR>
<TR> <TD>"OUTPUT"</TD>        <TD>stream output</TD> </TR>
<TR> <TD>"APPEND"</TD>        <TD>stream output at end</TD> </TR>
<TR> <TD>"OUTPUT-APPEND"</TD> <TD>stream output at end</TD> </TR>
<TR> <TD>"NEW"</TD>           <TD>stream output to new file</TD> </TR>
<TR> <TD>"NEW+"</TD>          <TD>direct access, new file</TD> </TR>
<TR> <TD>"NEW-r+"</TD>        <TD>direct access, new file</TD> </TR>
<TR> <TD>"NEW-w+"</TD>        <TD>direct access, new file</TD> </TR>
<TR> <TD>"CODED"</TD>         <TD>stream input</TD> </TR>
<TR> <TD>"CODED-IN"</TD>      <TD>stream input</TD> </TR>
<TR> <TD>"CODED-OUT"</TD>     <TD>stream output</TD> </TR>
<TR> <TD>"CODED-APPEND"</TD>  <TD>stream output at end</TD> </TR>
<TR> <TD>"CODED-NEW"</TD>     <TD>stream output to new file</TD> </TR>
<TR> <TD>"NEW-CODED"</TD>     <TD>stream output to new file</TD> </TR>
<TR> <TD>"PRINT"</TD>         <TD>stream output</TD> </TR>
<TR> <TD>"PRINT-APPEND"</TD>  <TD>stream output at end</TD> </TR>
<TR> <TD>"TEXT"</TD>          <TD>stream input</TD> </TR>
<TR> <TD>"TEXT-IN"</TD>       <TD>stream input</TD> </TR>
<TR> <TD>"TEXT-OUT"</TD>      <TD>stream output</TD> </TR>
<TR> <TD>"TEXT-APPEND"</TD>   <TD>stream output at end</TD> </TR>
<TR> <TD>"TEXT-NEW"</TD>      <TD>stream output to new file</TD> </TR>
<TR> <TD>"NEW-TEXT"</TD>      <TD>stream output to new file</TD> </TR>
<TR> <TD>"DIRECT"</TD>        <TD>direct access</TD> </TR>
<TR> <TD>"DIRECT-NEW"</TD>    <TD>direct access, new file</TD> </TR>
<TR> <TD>"NEW-DIRECT"</TD>    <TD>direct access, new file</TD> </TR>
<TR> <TD>"RANDOM"</TD>        <TD>direct access</TD> </TR>
<TR> <TD>"RANDOM-NEW"</TD>    <TD>direct access, new file</TD> </TR>
<TR> <TD>"NEW-RANDOM"</TD>    <TD>direct access, new file</TD> </TR>
<TR> <TD>"rw"</TD>            <TD>stream input/output</TD> </TR>
<TR> <TD>"TWO-WAY"</TD>       <TD>stream input/output</TD> </TR>
<TR> <TD>"TWOWAY"</TD>        <TD>stream input/output</TD> </TR>
<TR> <TD>"BIDIRECTIONAL"</TD> <TD>stream input/output</TD> </TR>
<TR> <TD>"INPUT-OUTPUT"</TD>  <TD>stream input/output</TD> </TR>
<TR> <TD>"READ-WRITE"</TD>    <TD>stream input/output</TD> </TR>
<TR> <TD>"PIPE-IN"</TD>       <TD>input from command's stdout</TD> </TR>
<TR> <TD>"PIPE-FROM"</TD>     <TD>input from command's stdout</TD> </TR>
<TR> <TD>"PIPE-OUT"</TD>      <TD>output to command's stdin</TD> </TR>
<TR> <TD>"PIPE-TO"</TD>       <TD>output to command's stdin</TD> </TR>
<TR> <TD>"PUMP"</TD>          <TD>I/O on command's stdin and stdout (co-process)</TD> </TR>
<TR> <TD>"TTY-PUMP"</TD>      <TD>co-process pumping through a pseudo-tty</TD> </TR>
<TR> <TD>"LINE-PUMP"</TD>     <TD>co-process pumping through a pseudo-tty</TD> </TR>
<TR> <TD>"SOCKET"</TD>        <TD>Internet TCP client socket</TD> </TR>
<TR> <TD>"CLIENT-SOCKET"</TD> <TD>Internet TCP client socket</TD> </TR>
<TR> <TD>"TCP-CLIENT-SOCKET"</TD> <TD>Internet TCP client socket</TD> </TR>
<TR> <TD>"SERVER-SOCKET"</TD> <TD>Internet TCP server socket</TD> </TR>
<TR> <TD>"TCP-SERVER-SOCKET"</TD> <TD>Internet TCP server socket</TD> </TR>
<TR> <TD>"UDP-CLIENT-SOCKET"</TD> <TD>Internet UDP client socket</TD> </TR>
<TR> <TD>"UDP-SERVER-SOCKET"</TD> <TD>Internet UDP server socket</TD> </TR>
<TR> <TD>"SIGNAL"</TD>        <TD>signals input as newlines</TD> </TR>
<TR> <TD>"SIGNAL-IN"</TD>     <TD>signals input as newlines</TD> </TR>
<TR> <TD>"IGNORE"</TD>        <TD>ignore signals</TD> </TR>
<TR> <TD>"IGNORE-SIGNAL"</TD> <TD>ignore signals</TD> </TR>
<TR> <TD>"SIGNAL-IGNORE"</TD> <TD>ignore signals</TD> </TR>
<TR> <TD>"REAL-MS"</TD>       <TD>input newline per wall clock interval</TD> </TR>
<TR> <TD>"VIRTUAL-MS"</TD>    <TD>input newline per user CPU time interval</TD> </TR>
<TR> <TD>"VIRT-MS"</TD>       <TD>input newline per user CPU time interval</TD> </TR>
<TR> <TD>"PROFILE-MS"</TD>    <TD>input newline per total CPU time interval</TD> </TR>
<TR> <TD>"PROF-MS"</TD>       <TD>input newline per total CPU time interval</TD> </TR>
<TR> <TD>"rb"</TD>            <TD>stream input</TD> </TR>
<TR> <TD>"wb"</TD>            <TD>stream output</TD> </TR>
<TR> <TD>"ab"</TD>            <TD>stream output at end</TD> </TR>
<TR> <TD>"nb"</TD>            <TD>stream output to new file</TD> </TR>
<TR> <TD>"rb+"</TD>           <TD>direct access</TD> </TR>
<TR> <TD>"r+b"</TD>           <TD>direct access</TD> </TR>
<TR> <TD>"wb+"</TD>           <TD>direct access, empty file first</TD> </TR>
<TR> <TD>"w+b"</TD>           <TD>direct access, empty file first</TD> </TR>
<TR> <TD>"ab+"</TD>           <TD>direct access, write at end</TD> </TR>
<TR> <TD>"a+b"</TD>           <TD>direct access, write at end</TD> </TR>
<TR> <TD>"nb+"</TD>           <TD>direct access, new file</TD> </TR>
<TR> <TD>"n+b"</TD>           <TD>direct access, new file</TD> </TR>
<TR> <TD>"BINARY"</TD>        <TD>stream input</TD> </TR>
<TR> <TD>"BINARY-IN"</TD>     <TD>stream input</TD> </TR>
<TR> <TD>"BINARY-OUT"</TD>    <TD>stream output</TD> </TR>
<TR> <TD>"BINARY-APPEND"</TD> <TD>stream output at end</TD> </TR>
<TR> <TD>"BINARY-NEW"</TD>    <TD>stream output to new file</TD> </TR>
<TR> <TD>"NEW-BINARY"</TD>    <TD>stream output to new file</TD> </TR>
<TR> <TD>"BINARY-DIRECT"</TD> <TD>direct access</TD> </TR>
<TR> <TD>"DIRECT-BINARY"</TD> <TD>direct access</TD> </TR>
<TR> <TD>"RANDOM-BINARY"</TD> <TD>direct access</TD> </TR>
<TR> <TD>"BINARY-DIRECT-NEW"</TD> <TD>direct access, new file</TD> </TR>
<TR> <TD>"BINARY-RANDOM-NEW"</TD> <TD>direct access, new file</TD> </TR>
<TR> <TD>"DIRECT-BINARY-NEW"</TD> <TD>direct access, new file</TD> </TR>
<TR> <TD>"RANDOM-BINARY-NEW"</TD> <TD>direct access, new file</TD> </TR>
<TR> <TD>"NEW-BINARY-DIRECT"</TD> <TD>direct access, new file</TD> </TR>
<TR> <TD>"NEW-BINARY-RANDOM"</TD> <TD>direct access, new file</TD> </TR>
<TR> <TD>"NEW-DIRECT-BINARY"</TD> <TD>direct access, new file</TD> </TR>
<TR> <TD>"NEW-RANDOM-BINARY"</TD> <TD>direct access, new file</TD> </TR>
</TABLE>
<p>
For <i>how</i>&nbsp;= "TCP-CLIENT-SOCKET" or "UDP-CLIENT-SOCKET", the
<i>f</i> argument should be of the form "ip.name.or.address:portnum".
For example, here is a program to fetch a document from a popular
HTTP server and write it on standard output:
<p>
<DL>
<DT><i>fd</i> <b>:= open(</b>"galt.cs.nyu.edu:80"<b>, </b>"tcp-client-socket"<b>);</b>
<DT><b>printa(</b><i>fd</i><b>, </b>"GET /"<b>);</b>
<DT><b>putchar(getfile</b> <i>fd</i><b>);</b>
</DL>
<p>
For <i>how</i>&nbsp;= "TCP-SERVER-SOCKET" or "UDP-SERVER-SOCKET", the
<i>f</i> argument should be a port number contained in a
<b>string</b> or a service name that is listed in the local
``/etc/services'' file or equivalent and can therefore be mapped to
a port number by <i>getservbyname</i>(2).  It should <em>not</em> be an
<b>integer</b> except where you intend an already open fd.  For example,
"80" indicates a port number, but naked 80 indicates a file descriptor
that probably doesn't exist.  In the special case when
<i>f</i> is "0", the system chooses a port number which can be
retrieved using <A HREF="#port"><b>port</b></A> like this:
<p>
<DL>
<DT><i>fd</i> <b>:= open(</b>"0"<b>,</b> "tcp-server-socket"<b>);</b>
<DT><b>print(</b>"server port number is"<b>, port</b> <i>fd</i><b>);</b>
</DL>
<p>
The only I/O (data-transferring) operations allowed on UDP client
sockets are <A HREF="#send"><b>send</b></A> and
<A HREF="#recv"><b>recv</b></A>, and the only ones allowed on UDP
server sockets are <A HREF="#sendto"><b>sendto</b></A> and
<A HREF="#recvfrom"><b>recvfrom</b></A>.
Andconversely, <b>recv</b> and <b>send</b> can only be used on UDP
client sockets, and <b>recvfrom</b> and <b>sendto</b> can only be
used on UDP server sockets.
<p>
For <i>how</i>&nbsp;= "PIPE-IN" ("PIPE-FROM"), "PIPE-OUT" ("PIPE-TO"),
"PUMP", or "TTY-PUMP" ("LINE-PUMP"), the <i>f</i> argument is a command.
The difference between "TTY-PUMP" ("LINE-PUMP") and ordinary "PUMP" is
that the ordinary pump is fully buffered, whereas the child process in
the ``tty pump'' is given an environment in which its standard input and
output are connected to the slave end of a pseudo-terminal (of which
your SETL program gets the master end as an fd), so whatever buffering
applies to interactive use for the command takes place.  This can be
used to allow off-the-shelf programs like ``sed'' or ``awk'' to be
used as pumps by causing them to flush after every output line,
or to implement very fancy drivers of programs that really are meant
to be interactive, sending them commands and getting back results
line by line.  [Need to separate out the Unix-specific semantics there.]
<p>
For <i>how</i>&nbsp;= "SIGNAL" ("SIGNAL-IN")  or "IGNORE" ("SIGNAL-IGNORE",
"IGNORE-SIGNAL"), the signals that can be received as input newlines
or studiously ignored are as follows, where the names are given as
strings with or without the "SIG" prefix, and case is not significant
(in contrast with most other interpretations of the <i>f</i> parameter
to <b>open</b>):
<p>
<TABLE BORDER>
<TR> <TH>signal</TH> <TH>default action</TH> <TH>meaning</TH> </TR>
<TR> <TD>"HUP"</TD>  <TD>terminate</TD>      <TD>hangup</TD> </TR>
<TR> <TD>"INT"</TD>  <TD>terminate</TD>      <TD>interrupt from keyboard</TD> </TR>
<TR> <TD>"QUIT"</TD> <TD>terminate</TD>      <TD>quit from keyboard</TD> </TR>
<TR> <TD>"USR1"</TD> <TD>terminate</TD>      <TD>user-defined signal 1</TD> </TR>
<TR> <TD>"USR2"</TD> <TD>terminate</TD>      <TD>user-defined signal 2</TD> </TR>
<TR> <TD>"PIPE"</TD> <TD>terminate</TD>      <TD>write to pipe with no readers</TD> </TR>
<TR> <TD>"TERM"</TD> <TD>terminate</TD>      <TD>software termination</TD> </TR>
<TR> <TD>"CHLD"</TD> <TD>ignore</TD>         <TD>child exit</TD> </TR>
<TR> <TD>"CONT"</TD> <TD>ignore</TD>         <TD>continue after suspension</TD> </TR>
<TR> <TD>"PWR"</TD>  <TD>ignore</TD>         <TD>battery low</TD> </TR>
<TR> <TD>"WINCH"</TD><TD>ignore</TD>         <TD>terminal window size change</TD> </TR>
</TABLE>
<p>
Whenever a signal is received and there is at least one input stream
open on that signal type, a newline is delivered to every such stream.
Otherwise, if the signal is ``open for ignoring'', it is ignored.
Otherwise, its effect defaults to the action specified in the table
above.  All stream input routines and <A HREF="#select"><b>select</b></A> can
be used on signal streams just as they can on regular input streams.
<p>
For <i>how</i>&nbsp;= "REAL-MS", "VIRT-MS" ("VIRTUAL-MS"), or
"PROF-MS" ("PROFILE-MS"), case not significant, <i>f</i> must be
a pure digit string indicating a positive integer.  This is
interpreted as the number of milliseconds that should elapse
between newlines to be delivered on the created input stream.
Any number of input streams can be open on each kind of timer.
Just as for signal streams, all stream input routines and
<A HREF="#select"><b>select</b></A> can be used on timer streams.
<p>
[In the <a href="./download-setl.html">dB SETL implementation</a>,
the greater of 10 ms and the GCD of all the timers defines the tick
interval requested of the Unix system timer of that type.  This helps
to reduce overhead and improve timing accuracy, especially if the SETL
programmer knows about this small refinement.]
<p>
See also <A HREF="#umask"><b>umask</b></A>,
<A HREF="#close"><b>close</b></A>,
<A HREF="#shutdown"><b>shutdown</b></A>,
<A HREF="#fexists"><b>fexists</b></A>,
<A HREF="#link"><b>link</b></A>,
<A HREF="#symlink"><b>symlink</b></A>,
<A HREF="#lexists"><b>lexists</b></A>, and
<A HREF="#unlink"><b>unlink</b></A>.
<p>
[A current difference in the behaviour of the SETL pipe and pump
stream file descriptor dispositions from the analogous streams
created by <i>popen</i> (there is no Unix analogy to the pump
stream, however) is that the ``close on exec'' (FD_CLOEXEC) flag
is not set for these file descriptors in SETL, whereas it is for
the file descriptor underlying a <i>popen</i>-created stream.
This may change soon; the jury's still out on this one, but I'm
inclined to side with the C-library decision as of this writing,
because there is no obvious way to communicate information such as
the pid (which needs to be waited for upon the closing of such a
stream) across <i>exec</i>(2) boundaries automatically, though the
programmer could implement that spam.
<p>
Actually, FD_CLOEXEC <em>is</em> asserted for pipe and pump
streams currently.  It is nice (though not essential semantics)
that these SETL streams work the same way as Unix <i>popen</i>ed
streams, and nicer still that a succession of equivalent child
processes will tend to start with the same set of available file
descriptors.  But probably the best reason for keeping FD_CLOEXEC
in place is that not doing so doesn't really buy you anything very
useful.  You might think that the ``prophylactic pump over a
socket'' technique might generalize well to untrusted child
processes, but it doesn't:  you can't just <b>close</b> the fd
associated with the untrusted child process after passing it to
the prophylactic pump (though indeed the latter will preserve the
reference to the kernel data structure by having inherited the fd),
as you would with a newly <A HREF="#accept"><b>accept</b></A>ed socket
fd, because you will get stuck trying to reap the child process
immediately instead of holding off until it is ready to exit or has
already become a zombie (see <A HREF="#wait"><b>wait</b></A>).]
</DL>

<A NAME="or"></A>
<HR><p>
<FONT SIZE=+2>Logical disjunction</FONT>
<DL>
<DT><b>op or (boolean, boolean) : boolean</b>
<p>
The expression <i>a</i>&nbsp;<b>or</b>&nbsp;<i>b</i> is equivalent to the expression
<b>if</b>&nbsp;<i>a</i>&nbsp;<b>then&nbsp;true else</b>&nbsp;<i>b</i> <b>end</b>.
The <b>or</b> operator is ``short-circuited'' in that it only evaluates
its second argument if necessary.  This makes it suitable for use as a
``guard'' (see also <A HREF="#and"><b>and</b></A>).
</DL>

<A NAME="pack_..."></A>
<A NAME="pack_char"></A>
<A NAME="pack_short"></A>
<A NAME="pack_int"></A>
<A NAME="pack_long"></A>
<A NAME="pack_float"></A>
<A NAME="pack_double"></A>
<A NAME="pack_long_double"></A>
<HR><p>
<FONT SIZE=+2>Byte packing</FONT>
<DL>
<DT><b>op pack_char (integer) : string</b>
<DT><b>op pack_short (integer) : string</b>
<DT><b>op pack_int (integer) : string</b>
<DT><b>op pack_long (integer) : string</b>
<DT><b>op pack_float (real) : string</b>
<DT><b>op pack_double (real) : string</b>
<DT><b>op pack_long_double (real) : string</b>
<p>
These are low-level, machine-dependent (but not dangerous)
operators for obtaining strings corresponding to the primitive
predefined C types on the machine you are running SETL on.
For example, <b>pack_long</b> 97 might
produce, on a typical machine, a 4- or 8-byte string consisting
entirely of null bytes except for a character having the value
<b>char&nbsp;97</b> (ASCII ``a'') in either the first or the last position.
You could try the one-line program
<p>
  <DL>
  <DT><b>print (hex pack_long</b> 97<b>);</b>
  </DL>
<p>
to see what your machine does.  See also
<A HREF="#unpack_..."><b>unpack_...</b></A>,
<A HREF="#fetch_..."><b>fetch_...</b></A>, and
<A HREF="#store_..."><b>store_...</b></A>.
</DL>

<A NAME="peekc"></A>
<HR><p>
<FONT SIZE=+2>Peek at next character in input stream</FONT>
<DL>
<DT><b>op peekc (string</b> <i>f</i><b>) : string</b>
<DT><b>op peekc (integer</b> <i>f</i><b>) : string</b>
<p>
The next available character, if any, in the input stream <i>f</i> is
retured as a string of length 1, just as with
<A HREF="#getc"><b>getc</b></A>.  However, the character also remains
in the input stream as if it had been ``pushed back'' by
<A HREF="#ungetc"><b>ungetc</b></A>.  If there are no more characters
(the end of the input was reached), <b>peekc</b> behaves exactly the
same as <b>getc</b>, returning <b>om</b>.  If <i>f</i> is not already
open, an attempt will automatically be made to open it for reading.
<p>
See also <A HREF="#peekchar"><b>peekchar</b></A>.
</DL>

<A NAME="peekchar"></A>
<HR><p>
<FONT SIZE=+2>Peek at next character in standard input</FONT>
<DL>
<DT><b>proc peekchar : string</b>
<p>
Equivalent to
<A HREF="#peekc"><b>peekc</b></A>&nbsp;<A HREF="#std..."><b>stdin</b></A>.
</DL>

<A NAME="peer_address"></A>
<HR><p>
<FONT SIZE=+2>Peer host address</FONT>
<DL>
<DT><b>proc peer_address (integer</b> <i>f</i><b>): string</b>
<DT><b>proc peer_address (string</b> <i>f</i><b>): string</b>
<p>
If <i>f</i> refers to a socket in a ``connected'' state,
<b>peer_address</b> returns the remote peer's Internet (IP) address.
<p>
See <A HREF="#open"><b>open</b></A>, and
see also <A HREF="#hostaddr"><b>hostaddr</b></A>,
<A HREF="#ip_addresses"><b>ip_addresses</b></A>, and
<A HREF="#peer_name"><b>peer_name</b></A>.
</DL>

<A NAME="peer_name"></A>
<HR><p>
<FONT SIZE=+2>Peer hostname</FONT>
<DL>
<DT><b>proc peer_name (integer</b> <i>f</i><b>): string</b>
<DT><b>proc peer_name (string</b> <i>f</i><b>): string</b>
<p>
If <i>f</i> refers to a socket in a ``connected'' state,
<b>peer_name</b> returns the remote peer's Internet (DNS) name.
If the name cannot be found, <b>peer_name</b> returns <b>om</b>.
<p>
See <A HREF="#open"><b>open</b></A>, and
see also <A HREF="#hostname"><b>hostname</b></A>,
<A HREF="#ip_names"><b>ip_names</b></A>,
and <A HREF="#peer_address"><b>peer_address</b></A>.
</DL>

<A NAME="peer_port"></A>
<HR><p>
<FONT SIZE=+2>Peer port number</FONT>
<DL>
<DT><b>proc peer_port (integer</b> <i>f</i><b>): integer</b>
<DT><b>proc peer_port (string</b> <i>f</i><b>): integer</b>
<p>
If <i>f</i> refers to a socket in a ``connected'' state,
<b>peer_port</b> returns the remote peer's TCP or UDP port number.
<p>
See <A HREF="#open"><b>open</b></A>, and
see also <A HREF="#port"><b>port</b></A>,
<A HREF="#peer_name"><b>peer_name</b></A>,
and <A HREF="#peer_address"><b>peer_address</b></A>.
</DL>

<A NAME="pexists"></A>
<HR><p>
<FONT SIZE=+2>Test for existence of process</FONT>
<DL>
<DT><b>op pexists (integer) : boolean</b>
<p>
Return <b>true</b> if the the process identified by the <b>integer</b>
argument exists on the local system, otherwise <b>false</b>.
See also <A HREF="#kill"><b>kill</b></A>, which can make a similar
test a little more clumsily as suggested in the
<A HREF="#clear_error"><b>clear_error</b></A> example, and
<A HREF="#pid"><b>pid</b></A>.
</DL>

<A NAME="pid"></A>
<HR><p>
<FONT SIZE=+2>Process id of current process or subtask</FONT>
<DL>
<DT><b>proc pid : integer</b>
<DT><b>proc pid (string) : integer</b>
<DT><b>proc pid (integer) : integer</b>
<p>
Called with no argument, <b>pid</b> returns the Posix process
identifier (pid) of the current process.  Called with an
argument that refers to an open pipe, pump, or line-pump stream,
it returns the child's process id.
<p>
See also <A HREF="#open"><b>open</b></A>,
<A HREF="#pipe_from_child"><b>pipe_from_child</b></A>,
<A HREF="#pipe_to_child"><b>pipe_to_child</b></A>,
<A HREF="#pump"><b>pump</b></A>,
<A HREF="#pexists"><b>pexists</b></A>,
<A HREF="#kill"><b>kill</b></A>,
<A HREF="#getpgrp"><b>getpgrp</b></A>, and
<A HREF="#setpgrp"><b>setpgrp</b></A>.
</DL>

<A NAME="pipe"></A>
<HR><p>
<FONT SIZE=+2>Create primitive pipe</FONT>
<DL>
<DT><b>proc pipe : tuple</b>
<p>
This is a low-level interface to the Posix routine <i>pipe</i>(2),
and returns a <b>tuple</b> of two <b>integer</b> file descriptors
<b>[</b><i>pull</i><b>,</b><i>push</i><b>]</b>
such that <i>pull</i> is open (at the system level, not the SETL
level) for reading and and <i>push</i> is open for writing.
See the <A HREF="#open"><b>open</b></A> modes "PIPE-IN", "PIPE-OUT",
and "PUMP", and also the <A HREF="#pump"><b>pump</b></A> primitive,
one of which probably does whatever you want to do with pipes
much more conveniently than the raw <b>pipe</b> procedure does.
<p>
[Since I now map ``pipe'' calls to <i>socketpair</i>(2) when possible,
and pretty well everyone that doesn't have socketpair is probably
SVR4 by now, the low-level pipe you get from this
call is almost certainly bidirectional.  Indeed, this is taken for
granted in the current dB implementation of pumps:  gone is the
messiness of having to have a separate fd for each direction.]
</DL>

<A NAME="pipe_from_child"></A>
<A NAME="pipe_to_child"></A>
<HR><p>
<FONT SIZE=+2>Create pipe stream over local subprocess</FONT>
<DL>
<DT><b>proc pipe_from_child : integer</b>
<DT><b>proc pipe_to_child : integer</b>
<p>
The <b>pipe_from_child</b> and <b>pipe_to_child</b> primitives are
degenerate forms of <A HREF="#pump"><b>pump</b></A>.  Each creates a
unidirectional stream, but is in other respects just like <b>pump</b>
except that <A HREF="#shutdown"><b>shutdown</b></A> cannot be used on
a stream created by <b>pipe_from_child</b> or <b>pipe_to_child</b>.
In the child, either <A HREF="#stdin"><b>stdin</b></A> or
<A HREF="#stdout"><b>stdout</b></A> as appropriate is <i>connected</i>
through a pipe to the parent process, and the other is merely
<i>inherited</i> from the parent process in a similar manner as the
C-library <i>popen</i>(3) routine arranges.
</DL>

<A NAME="port"></A>
<HR><p>
<FONT SIZE=+2>Retrieve port number</FONT>
<DL>
<DT><b>op port (string</b> <i>f</i><b>) : integer</b>
<DT><b>op port (integer</b> <i>f</i><b>) : integer</b>
<p>
Returns the local port number associated with a client or server
socket <i>f</i>.  See <A HREF="#open"><b>open</b></A>, and
see also <A HREF="#peer_port"><b>peer_port</b></A>.
</DL>

<A NAME="pow"></A>
<HR><p>
<FONT SIZE=+2>Power set</FONT>
<DL>
<DT><b>op pow (set</b> <i>s</i><b>) : set</b>
<p>
Returns the set of all subsets of <i>s</i>, including
the null set <b>{}</b> and <i>s</i> itself.  There are
2 <b>** #</b><i>s</i> such subsets in all.  See also
<A HREF="#npow"><b>npow</b></A>.
</DL>

<A NAME="pretty"></A>
<HR><p>
<FONT SIZE=+2>``Prettify'' string</FONT>
<DL>
<DT><b>op pretty (string) : string</b>
<p>
The <b>pretty</b> operator returns a copy of its argument
in which the 95 characters that ASCII considers ``printable''
are left unmolested, except for the apostrophe ('), which
becomes two apostrophes in a row, and the backslash,
which becomes two backslashes in a row.  An apostrophe
is also added at each end.  Among the other codes, the
audible alarm, backspace, formfeed, newline, return, horizontal tab,
and vertical tab are converted to \a, \b, \f, \n, \r, \t, and \v
respectively (these are the same as the C conventions), and all
remaining codes are converted to \<i>xyz</i>, where <i>x</i>, <i>y</i>,
and <i>z</i> are octal digits.  See also
<A HREF="#unpretty"><b>unpretty</b></A>, <A HREF="#str"><b>str</b></A>,
and <A HREF="#unstr"><b>unstr</b></A>.
</DL>

<A NAME="print"></A>
<HR><p>
<FONT SIZE=+2>Print to standard output</FONT>
<DL>
<DT><b>proc print (...)</b>
<p>
Equivalent to
<A HREF="#printa"><b>printa</b></A>&nbsp;<b>(<A HREF="#std...">stdout</A>, ...)</b>.
</DL>

<A NAME="printa"></A>
<HR><p>
<FONT SIZE=+2>Print to output stream</FONT>
<DL>
<DT><b>proc printa (string</b> <i>f</i><b>, ...)</b>
<DT><b>proc printa (integer</b> <i>f</i><b>, ...)</b>
<p>
There can be 0 or more arguments after <i>f</i>, of any type.
They are sent in sequence to the stream <i>f</i>, separated by single
spaces and followed by a newline character.  String arguments
are written directly; all others are written as if they had
been passed through <A HREF="#str"><b>str</b></A> first.
<p>
See also <A HREF="#print"><b>print</b></A> and
<A HREF="#nprinta"><b>nprinta</b></A> (which omits the trailing
newline).
</DL>

<A NAME="pump"></A>
<HR><p>
<FONT SIZE=+2>Create pump stream over local subprocess</FONT>
<DL>
<DT><b>proc pump : integer</b>
<p>
The <b>pump</b> primitive creates a child co-process just as
<A HREF="#fork"><b>fork</b></A> does, but returns in the parent a
bidirectional stream that is connected to the child's standard input
and output.  Other streams open in the parent are left open in the
child, and <b>pump</b> returns -1 in the child.
<p>
If the system cannot create a new process, or if it cannot create
the requisite bidirectional stream, <b>pump</b> returns <b>om</b>.
<p>
See also <A HREF="#open"><b>open</b></A> (particularly the "PUMP"
and "LINE-PUMP" modes), <A HREF="#close"><b>close</b></A>,
<A HREF="#shutdown"><b>shutdown</b></A>,
<A HREF="#pipe_from_child"><b>pipe_from_child</b></A>,
<A HREF="#pipe_to_child"><b>pipe_to_child</b></A>, and
<A HREF="#filter"><b>filter</b></A>.
</DL>

<A NAME="put"></A>
<HR><p>
<FONT SIZE=+2>Put line(s) on standard output</FONT>
<DL>
<DT><b>proc put (...)</b>
<p>
Equivalent to
<A HREF="#puta"><b>puta</b></A>&nbsp;<b>(<A HREF="#std...">stdout</A>, ...)</b>.
</DL>

<A NAME="puta"></A>
<HR><p>
<FONT SIZE=+2>Put line(s) on output stream</FONT>
<DL>
<DT><b>proc puta (string</b> <i>f</i><b>, ...)</b>
<DT><b>proc puta (integer</b> <i>f</i><b>, ...)</b>
<p>
There can be 0 or more <b>string</b> arguments after the
output stream designator <i>f</i>.  They are written directly
to <i>f</i>, with a newline character after each.
A synonym for <b>puta</b> is <A HREF="#putline"><b>putline</b></A>.
</DL>

<A NAME="putb"></A>
<HR><p>
<FONT SIZE=+2>Put value(s) on output stream</FONT>
<DL>
<DT><b>proc putb (string</b> <i>f</i><b>, ...)</b>
<DT><b>proc putb (integer</b> <i>f</i><b>, ...)</b>
<p>
There can be 0 or more arguments after <i>f</i>, of any type.  They
are sent in sequence to the stream <i>f</i>, separated by single
spaces and followed by a newline character.  All of them are written
as if they had been passed through <A HREF="#str"><b>str</b></A> first,
with no exception for strings (contrast
<A HREF="#printa"><b>printa</b></A>).  Values written by <b>putb</b>,
except for atoms (see <A HREF="#newat"><b>newat</b></A>) and
procedure references (see <A HREF="#routine"><b>routine</b></A>),
can be read by <A HREF="#getb"><b>getb</b></A>.  This procedure is
functionally identical to <A HREF="#writea"><b>writea</b></A>.
</DL>

<A NAME="putc"></A>
<HR><p>
<FONT SIZE=+2>Put character(s) on output stream</FONT>
<DL>
<DT><b>proc putc (string</b> <i>f</i><b>, string</b> <i>c</i><b>)</b>
<DT><b>proc putc (integer</b> <i>f</i><b>, string</b> <i>c</i><b>)</b>
<p>
The 0 or more characters in <i>c</i> are sent to the stream <i>f</i>.
</DL>

<A NAME="putchar"></A>
<HR><p>
<FONT SIZE=+2>Put character(s) on standard output</FONT>
<DL>
<DT><b>proc putchar (string</b> <i>c</i><b>)</b>
<p>
The call <b>putchar&nbsp;(</b><i>c</i><b>)</b> is the same as
<A HREF="#putc"><b>putc</b></A>&nbsp;<b>(</b><A HREF="#std..."><b>stdout</b></A>,&nbsp;<i>c</i><b>)</b>.
</DL>

<A NAME="putenv"></A>
<HR><p>
<FONT SIZE=+2>Set environment variable</FONT>
<DL>
<DT><b>proc putenv (string)</b>
<p>
The argument should have the form "<i>id</i>=<i>value</i>" as in the
Posix <i>putenv</i>(3) routine.  However, it is possible on some systems
to ``unset'' an environment variable by passing just the "<i>id</i>"
part.  The use of <A HREF="#setenv"><b>setenv</b></A> and
<A HREF="#unsetenv"><b>unsetenv</b></A> is recommended in preference to
the rather old-fashioned <b>putenv</b>.  See also
<A HREF="#getenv"><b>getenv</b></A>.
</DL>

<A NAME="putfile"></A>
<HR><p>
<FONT SIZE=+2>Put character(s) on output stream</FONT>
<DL>
<DT><b>proc putfile (string</b> <i>f</i><b>, string</b> <i>c</i><b>)</b>
<DT><b>proc putfile (integer</b> <i>f</i><b>, string</b> <i>c</i><b>)</b>
<p>
The 0 or more characters in <i>c</i> are sent to the stream <i>f</i>;
thus <b>putfile</b> is equivalent to <A HREF="#putc"><b>putc</b></A>,
except that <b>putfile</b> will automatically close a file that was
automatically opened.
</DL>

<A NAME="putline"></A>
<HR><p>
<FONT SIZE=+2>Put line(s) on output stream</FONT>
<DL>
<DT><b>proc putline (string</b> <i>f</i><b>, ...)</b>
<DT><b>proc putline (integer</b> <i>f</i><b>, ...)</b>
<p>
There can be 0 or more <b>string</b> arguments after the
output stream designator <i>f</i>.  They are written directly
to <i>f</i>, with a newline character after each.
A synonym for <b>putline</b> is <A HREF="#puta"><b>puta</b></A>.
</DL>

<A NAME="puts"></A>
<HR><p>
<FONT SIZE=+2>Direct-access write</FONT>
<DL>
<DT><b>proc puts (string</b> <i>f</i><b>, integer</b> <i>start</i><b>, string</b> <i>x</i><b>)</b>
<DT><b>proc puts (integer</b> <i>f</i><b>, integer</b> <i>start</i><b>, string</b> <i>x</i><b>)</b>
<p>
The direct-access stream <i>f</i> (see <A HREF="#open"><b>open</b></A> mode "RANDOM") is
viewed as a string, where <i>start</i> specifies the index (1 or higher)
of the first character to write.  The <b>puts</b> procedure will write <i>n</i>
characters to <i>f</i>, increasing the size of the file as necessary.
See also <A HREF="#gets"><b>gets</b></A>, <A HREF="#seek"><b>seek</b></A>,
and <A HREF="#rewind"><b>rewind</b></A>.
</DL>

<A NAME="random"></A>
<HR><p>
<FONT SIZE=+2>Pseudo-random numbers and selections</FONT>
<DL>
<DT><b>op random (integer</b> <i>i</i><b>) : integer</b>
<DT><b>op random (real</b> <i>r</i><b>) : real</b>
<DT><b>op random (string</b> <i>s</i><b>) : string</b>
<DT><b>op random (set</b> <i>t</i><b>) : var</b>
<DT><b>op random (tuple</b> <i>t</i><b>) : var</b>
<p>
For an <b>integer</b> <i>i</i> <b>&gt;</b> 0, <b>random</b> <i>i</i> returns
a pseudo-random <b>integer</b> in <b>{</b>0<b>..</b><i>i</i><b>}</b>;
otherwise in <b>{-</b><i>i</i><b>..</b>0<b>}</b>.  Note that this is
a little unusual compared to other programming languages, in that both
endpoints are included in this definition (so <b>random</b> <i>i</i>
can produce any of <i>i</i> <b>+</b> 1 different numbers).
<p>
For a <b>real</b> <i>r</i>, <b>random</b> <i>r</i> returns
<i>r</i> <b>*</b> <i>u</i>, where <i>u</i> is a pseudo-random
<b>real</b> in the half-open interval [0,1).
<p>
For a <b>string</b> <i>s</i>, <b>random</b> <i>s</i> returns
a pseudo-randomly chosen character from <i>s</i>, or <b>om</b>
if <i>s</i> is the null string.
<p>
For a <b>set</b> or <b>tuple</b> <i>t</i>, <b>random</b> <i>t</i> returns
a pseudo-randomly chosen element from <i>t</i>, or <b>om</b> if
<b>#</b><i>t</i>&nbsp;<b>=</b>&nbsp;0.
<p>
See also <A HREF="#setrandom"><b>setrandom</b></A>.
</DL>

<A NAME="range"></A>
<HR><p>
<FONT SIZE=+2>Range of map</FONT>
<DL>
<DT><b>op range (set) : set</b>
<p>
The argument must be a set of ordered pairs, that is, a set
of tuples each of size 2.  The result is the set of all second
members of those tuples.  See also <A HREF="#domain"><b>domain</b></A>.
</DL>

<A NAME="rany"></A>
<A NAME="rbreak"></A>
<A NAME="rlen"></A>
<A NAME="rmatch"></A>
<A NAME="rnotany"></A>
<A NAME="rspan"></A>
<HR><p>
<FONT SIZE=+2>Right-to-left string breakers</FONT>
<DL>
<DT><b>proc rany (rw string</b> <i>s</i><b>, string</b> <i>p</i><b>) : string</b>
<DT><b>proc rbreak (rw string</b> <i>s</i><b>, string</b> <i>p</i><b>) : string</b>
<DT><b>proc rlen (rw string</b> <i>s</i><b>, integer</b> <i>n</i><b>) : string</b>
<DT><b>proc rmatch (rw string</b> <i>s</i><b>, string</b> <i>p</i><b>) : string</b>
<DT><b>proc rnotany (rw string</b> <i>s</i><b>, string</b> <i>p</i><b>) : string</b>
<DT><b>proc rspan (rw string</b> <i>s</i><b>, string</b> <i>p</i><b>) : string</b>
<p>
These procedures look for rightmost occurrences of something.  Thus
<b>rany</b> and <b>rnotany</b> try to pick off the character at
<i>s</i><b>(#</b><i>s</i><b>)</b>, <b>rbreak</b> and <b>rspan</b> scan from
right to left, <b>rlen</b> tries to consume <i>n</i> characters on the right,
and <b>rmatch</b> succeeds only if <i>p</i> occupies the last
<b>#</b><i>p</i> characters of <i>s</i>.
<p>
No reversal of actual character order is implied here; see instead
<A HREF="#reverse"><b>reverse</b></A>.
</DL>

<A NAME="read"></A>
<HR><p>
<FONT SIZE=+2>Get one or more values from standard input</FONT>
<DL>
<DT><b>proc read (wr var...)</b>
<p>
Equivalent to
<A HREF="#reada"><b>reada</b></A>&nbsp;<b>(<A HREF="#std...">stdin</A>, ...)</b>.
</DL>

<A NAME="reada"></A>
<HR><p>
<FONT SIZE=+2>Get one or more values from input stream</FONT>
<DL>
<DT><b>proc reada (string</b> <i>f</i><b>, wr var...)</b>
<DT><b>proc reada (integer</b> <i>f</i><b>, wr var...)</b>
<p>
Values are read from the input stream <i>f</i> and assigned to
the succeeding arguments in order.  If the end of the input is reached,
trailing arguments may be assigned <b>om</b>.
Values written by <A HREF="#writea"><b>writea</b></A>,
except for atoms (see <A HREF="#newat"><b>newat</b></A>) and
procedure references (see <A HREF="#routine"><b>routine</b></A>),
are guaranteed to be readable by <b>reada</b>.  If
<i>f</i> is not already open, an attempt will automatically be made
to open it for reading.  See also <A HREF="#unstr"><b>unstr</b></A>
and <A HREF="#reads"><b>reads</b></A>.
<p>
There is a subtle difference between <b>reada</b> and
<A HREF="#getb"><b>getb</b></A> in that <b>reada</b> will always
start reading at the beginning of a line, skipping ahead to just after
the next newline character if necessary in order to do so, but
<b>getb</b> will simply start with the next available character in the
input stream.
</DL>

<A NAME="readlink"></A>
<HR><p>
<FONT SIZE=+2>Symbolic link referent</FONT>
<DL>
<DT><b>op readlink (string</b> <i>f</i><b>) : string</b>
<p>
When <i>f</i> names a file that is really a symbolic link,
<b>readlink</b> yields the string associated with <i>f</i>.
The resulting string may or may not name another existing file.
<p>
Contrast this with a regular input operation on <i>f</i>, which
will fail if <i>f</i> is a symbolic link to a file that doesn't
exist.
<p>
If <i>f</i> itself doesn't exist, or is not a symbolic link,
<b>readlink</b> yields <b>om</b>, and
<A HREF="#last_error"><b>last_error</b></A> indicates
which case applies.
<p>
See also <A HREF="#lexists"><b>lexists</b></A>,
<A HREF="#fexists"><b>fexists</b></A>,
<A HREF="#symlink"><b>symlink</b></A>,
<A HREF="#link"><b>link</b></A>, and
<A HREF="#unlink"><b>unlink</b></A>.
</DL>

<A NAME="reads"></A>
<HR><p>
<FONT SIZE=+2>Get one or more values from a string</FONT>
<DL>
<DT><b>proc reads (string</b> <i>s</i><b>, wr var...)</b>
<p>
Values are ``read'' from the string <i>s</i> and assigned to the
succeeding arguments in order.  If the end of the string is reached,
unsatisfied trailing arguments will be assigned <b>om</b>.  The rules
for value recognition and conversion are the same as for
<A HREF="#reada"><b>reada</b></A> and <A HREF="#unstr"><b>unstr</b></A>.
</DL>

<A NAME="recv"></A>
<HR><p>
<FONT SIZE=+2>Receive datagram on UDP client socket</FONT>
<DL>
<DT><b>op recv (string</b> <i>f</i><b>) : string</b>
<DT><b>op recv (integer</b> <i>f</i><b>) : string</b>
<p>
A datagram is read from the UDP client socket <i>f</i> and yielded
as a string.  The <A HREF="#select"><b>select</b></A> procedure may
be used to check or wait for input of this kind.
<p>
See <A HREF="#open"><b>open</b></A>, and see also
<A HREF="#recvfrom"><b>recvfrom</b></A>,
<A HREF="#send"><b>send</b></A>, and
<A HREF="#sendto"><b>sendto</b></A>.
</DL>

<A NAME="recvfrom"></A>
<HR><p>
<FONT SIZE=+2>Receive datagram on UDP server socket</FONT>
<DL>
<DT><b>op recvfrom (string</b> <i>f</i><b>) : tuple</b>
<DT><b>op recvfrom (integer</b> <i>f</i><b>) : tuple</b>
<p>
A datagram is read from the UDP server socket <i>f</i>, and its
its sender's address is sensed.  The address is formatted as a
string of the form "ip.address:portnum", and returned with the
datagram as the pair of strings
<b>[</b><i>address</i><b>, </b><i>datagram</i><b>]</b>.
Example of use:
<p>
<DL>
<DT><b>[</b><i>address</i><b>, </b><i>datagram</i><b>] := recvfrom </b><i>f</i><b>;</b>
</DL>
<p>
The <A HREF="#select"><b>select</b></A> procedure may
be used to check or wait for input of this kind.
<p>
See <A HREF="#open"><b>open</b></A>, and see
also <A HREF="#recv"><b>recv</b></A>,
<A HREF="#send"><b>send</b></A>, and
<A HREF="#sendto"><b>sendto</b></A>.
</DL>

<A NAME="recv_fd"></A>
<HR><p>
<FONT SIZE=+2>Receive file descriptor</FONT>
<DL>
<DT><b>op recv_fd (string</b> <i>f</i><b>) : integer</b>
<DT><b>op recv_fd (integer</b> <i>f</i><b>) : integer</b>
<p>
A file descriptor sent by a process executing a
<A HREF="#send_fd"><b>send_fd</b></A> is returned and left
open at the underlying system level (but not at the SETL level,
so you still have to do an <A HREF="#open"><b>open</b></A> on it
to specify the I/O mode you want).  The stream designator <i>f</i>
must refer to a Unix-domain socket.  Note that the returned file
descriptor may arrive as a different integer than was passed by
the sending process to <b>send_fd</b>.
<p>
[While there are no explicit <A HREF="#open"><b>open</b></A>
modes that create Unix-domain sockets, they are in fact what you get
from opening in a "PIPE-..." or "PUMP" mode, and are also what
<A HREF="#pipe"><b>pipe</b></A> creates.  The system-specific
semantics obviously won't do, but will serve as a stand-in
until I learn what the equivalent of the bidirectional (modern)
form of BSD Unix pipes is on NT and Mac OS 8 (hah!) etc.]
<p>
The <A HREF="#select"><b>select</b></A> procedure may
be used to test or wait for the presence of a file descriptor ready to
be received on <i>f</i>.
</DL>

<A NAME="rem"></A>
<HR><p>
<FONT SIZE=+2>Integer remainder</FONT>
<DL>
<DT><b>op rem (integer, integer) : integer</b>
<p>
The definition of <b>rem</b> is such that for all <i>a</i> and <i>b</i>,
where <i>b</i> is nonzero:
<p>
  <DL>
  <DT><i>a</i> <b>rem</b> <i>b</i> <b>=</b> <i>a</i> <b>- ((</b><i>a</i> <b>div</b> <i>b</i><b>) *</b> <i>b</i>
  </DL>
<p>
so, for example:
<p>
  <DL>
  <DT>5 <b>rem</b> 3 <b>=</b> 2
  <DT><b>-</b>5 <b>rem</b> 3 <b>= -</b>2
  <DT>5 <b>rem -</b>3 <b>=</b> 2
  <DT><b>-</b>5 <b>rem -</b>3 <b>= -</b>2
  </DL>
<p>
Note that unless the remainder is zero, it has the same sign as the
dividend.  See also <A HREF="#div"><b>div</b></A> and
<A HREF="#mod"><b>mod</b></A>.
</DL>

<A NAME="reverse"></A>
<HR><p>
<FONT SIZE=+2>Reverse string</FONT>
<DL>
<DT><b>op reverse (string) : string</b>
<p>
Characters in reverse order.
</DL>

<A NAME="rewind"></A>
<HR><p>
<FONT SIZE=+2>Rewind direct-access stream</FONT>
<DL>
<DT><b>proc rewind (string</b> <i>f</i><b>)</b>
<DT><b>proc rewind (integer</b> <i>f</i><b>)</b>
<p>
The call <b>rewind(</b><i>f</i><b>)</b> is equivalent to the call
<A HREF="#seek"><b>seek</b></A>&nbsp;<b>(</b><i>f</i><b>,&nbsp;</b>0<b>)</b>.
</DL>

<A NAME="round"></A>
<HR><p>
<FONT SIZE=+2>Round to nearest integer</FONT>
<DL>
<DT><b>op round (real) : integer</b>
<DT><b>op round (integer) : integer</b>
<p>
Numbers ending in .5 are always rounded upward, so
<b>round</b>&nbsp;<i>x</i>&nbsp;=&nbsp;<A HREF="#floor"><b>floor</b></A>&nbsp;<b>(</b><i>x</i><b>+</b>0.5<b>)</b>.
See also <A HREF="#ceil"><b>ceil</b></A> and <A HREF="#fix"><b>fix</b></A>.
</DL>

<A NAME="routine"></A>
<HR><p>
<FONT SIZE=+2>Create procedure reference</FONT>
<DL>
<DT>
<DT><b>op routine (proc_name) : proc_ref</b>
<p>
This pseudo-operator produces a value that can subsequently be passed
to <A HREF="#call"><b>call</b></A> in order to effect an indirect
procedure call.  The typenames in the signature shown here do not
really exist as SETL keywords, but suggest how this operator is used:
you pass it the name of a procedure in your program, and <b>routine</b>
returns an opaque handle which you can save for later use.  For
example, it is sometimes convenient to use a mapping to associate
strings with procedure references, as is illustrated by the use of
<A HREF="#select"><b>select</b></A> in the ``callback'' style of
programming.  A more familiar application is to have a generic numerical
integration function to which you pass a reference to the function that
is to be integrated, like this:
<p>
  <DL>
  <DT><i>f_ref</i> <b>:= routine</b> <i>f</i><b>;</b>
  <DT><i>area</i> <b>:=</b> <i>integrate</i><b>(</b><i>f_ref</i><b>,</b> 0<b>,</b> 1<b>);</b>
<P>
  <DT><b>proc</b> <i>f</i><b>(</b><i>x</i><b>);</b>&nbsp;&nbsp;-- function to be integrated
    <DL>
    <DT><b>return sin</b> <i>x</i><b>;</b>
    </DL>
  <DT><b>end</b> <i>f</i><b>;</b>
<P>
  <DT><b>proc</b> <i>integrate</i><b>(</b><i>g</i><b>,</b> <i>x_lo</i><b>,</b> <i>x_hi</i><b>);</b>
    <DL>
    <DT><b>...</b>
    <DT><i>sum</i> <b>+:=</b> <i>dx</i> <b>* call(</b><i>g</i><b>,</b> <i>x</i><b>);</b>
    <DT><b>...</b>
    <DT><b>return</b> <i>sum</i><b>;</b>
    </DL>
  <DT><b>end</b> <i>integrate</i><b>;</b>
  </DL>
</DL>

<A NAME="rpad"></A>
<HR><p>
<FONT SIZE=+2>Pad string on right with blanks</FONT>
<DL>
<DT><b>proc rpad (string</b> <i>s</i><b>, integer</b> <i>n</i><b>) : string</b>
<p>
If <i>n</i>&nbsp;<b>&gt;&nbsp;#</b><i>s</i>, the returned <b>string</b> is a
copy of <i>s</i> padded on the right with blanks to length <i>n</i>.
Otherwise, (a copy of) <i>s</i> is returned.
See also <A HREF="#lpad"><b>lpad</b></A>.
</DL>

<A NAME="seek"></A>
<HR><p>
<FONT SIZE=+2>Reposition direct-access stream</FONT>
<DL>
<DT><b>proc seek (string</b> <i>f</i><b>, integer</b> <i>offset</i><b>)</b>
<DT><b>proc seek (integer</b> <i>f</i><b>, integer</b> <i>offset</i><b>)</b>
<p>
The direct-access stream <i>f</i> (see <A HREF="#open"><b>open</b></A> mode
"RANDOM") is repositioned so that the next ordinary read or write operation
will start at <i>offset</i> bytes past the beginning of the file.  Note that
<i>offset</i> should be 0 or more, consistent with the conventions of Unix
<i>fseek</i>(3), unlike the <i>start</i> parameter of <A HREF="#gets"><b>gets</b></A>
and <A HREF="#puts"><b>puts</b></A>:  <i>offset</i> is the same as
<i>start</i>&nbsp;<b>-</b>&nbsp;1.  See also <A HREF="#rewind"><b>rewind</b></A>.
</DL>

<A NAME="select"></A>
<HR><p>
<FONT SIZE=+2>Wait for I/O event or timeout</FONT>
<DL>
<DT><b>proc select (tuple</b> <i>fds</i><b>) : tuple</b>
<DT><b>proc select (tuple</b> <i>fds</i><b>, integer</b> <i>ms</i><b>) : tuple</b>
<p>
This is an extended interface to the Unix <i>select</i>(2) routine,
which allows a program to wait for I/O events on multiple streams
simultaneously, optionally taking a timeout or immediate return.
Because interprocess communication, signals, and interval timers are
all wrapped as I/O streams in SETL too, this is the fundamental
procedure for event-driven programming in SETL.
<p>
The <i>fds</i> argument contains up to 3 <b>set</b>s of stream
designators, where <i>fds</i><b>(</b>1<b>)</b> lists streams that
may produce input (the meaning of this is actually extended to
included TCP server sockets that are ready to
<A HREF="#accept"><b>accept</b></A> without blocking, UDP
sockets that have datagrams ready to be received by
<A HREF="#recv"><b>recv</b></A> or
<A HREF="#recvfrom"><b>recvfrom</b></A>, and Unix-domain sockets
on which <A HREF="#recv_fd"><b>recv_fd</b></A> can be called
without blocking), <i>fds</i><b>(</b>2<b>)</b> lists streams that take
output (including UDP sockets ready for <A HREF="#send"><b>send</b></A>
or <A HREF="#sendto"><b>sendto</b></A> operations, and Unix-domain
sockets that can take <A HREF="#send_fd"><b>send_fd</b></A> calls
without blocking), and <i>fds</i><b>(</b>3<b>)</b> lists streams that
can generate exceptional conditions.  For convenience, an empty
<i>fds</i> tuple can be indicated by passing <i>fds</i> as <b>om</b>.
<p>
The <i>ms</i> argument, if present, gives the number of milliseconds
<b>select</b> should wait if none of the stream designators given in
<i>fds</i> doesn't become ready sooner.  If <i>ms</i> is 0, it expires
immediately, giving the effect of ``polling'' (no wait).  If it is
absent or <b>om</b>, <b>select</b> waits indefinitely for a stream to
become ready, so the expression <b>select(om)</b> means wait (``sleep'')
indefinitely.
<p>
The return value from <b>select</b> is always a 3-element <b>tuple</b>
consisting of 3 <b>set</b>s of stream designators
<b>[</b><i>input</i><b>, </b><i>output</i><b>, </b><i>except</i><b>]</b>.
Any of these sets can be empty, and if <b>select</b> returns because
<i>ms</i> milliseconds has elapsed with no file descriptors becoming
ready, all three sets are empty.  Otherwise, they contain stream
designators corresponding to file descriptors that are ready for input,
output, or exception processing, respectively.
<p>
The ``callback'' style of event-driven programming can be supported
easily by passing control to a routine that repeatedly calls
<b>select</b> and looks up what procedure to call from a map from
fd's.  Here is an example that happens to deal only in input
streams (a typical case):
<p>
<DL>
<DT><b>proc</b> <i>callback_scheduler</i><b>;</b>
  <DL>
  <DT><b>loop</b>
    <DL>
    <DT><b>[</b><i>ready</i><b>] := select([</b><i>pool</i><b>]);</b>
    <DT><b>for</b> <i>fd</i> <b>in</b> <i>ready</i> <b>loop</b>
      <DL>
      <DT><b>call(</b><i>callback_map</i><b>(</b><i>fd</i><b>), [</b><i>fd</i><b>]);</b>
      </DL>
    <DT><b>end loop;</b>
    </DL>
  <DT><b>end loop;</b>
  </DL>
<DT><b>end proc;</b>
</DL>
<p>
A callback procedure <i>p</i> is ``registered'' in the callback map
by executing
<p>
<DL>
<DT><i>callback_map</i><b>(</b><i>fd</i><b>) := routine</b> <i>p</i><b>;</b>
</DL>
<p>
which associates it with <i>fd</i>.  It can later be ``unregistered''
thus:
<p>
<DL>
<DT><i>callback_map</i><b>(</b><i>fd</i><b>) := om;</b>
</DL>
<p>
The idea is that you pass control to <i>callback_scheduler</i> after
setting up your callback procedures (``event routines''), and
everything thereafter is driven from them.
<p>
Notice that the callback procedure has the option of reading further
information from the fd passed to it as a parameter if this if
appropriate, so the callback model is as convenient to use in
conjunction with SETL streams of all kinds as is the basic
<b>select</b> model.
<p>
[The above discussion should be updated to warn the unwary about the
hazards of modifying <i>callback_map</i> in the callback routines,
as expounded in my dissertation, where a solution is given.
Since everything is supposed to happen in the callback routines when
you program in this style, everyone who does so should be aware of
this!]
</DL>

<A NAME="send"></A>
<HR><p>
<FONT SIZE=+2>Send datagram on UDP client socket</FONT>
<DL>
<DT><b>proc send (string</b> <i>f</i><b>, string</b> <i>datagram</i><b>)</b>
<DT><b>proc send (integer</b> <i>f</i><b>, string</b> <i>datagram</i><b>)</b>
<p>
The <i>datagram</i> is sent to the UDP client socket <i>f</i>.
The <A HREF="#select"><b>select</b></A> procedure may
be used to check or wait for <i>f</i> to be ready to take a datagram.
<p>
See <A HREF="#open"><b>open</b></A>, and see also
<A HREF="#recv"><b>recv</b></A>,
<A HREF="#recvfrom"><b>recvfrom</b></A>, and
<A HREF="#sendto"><b>sendto</b></A>.
</DL>

<A NAME="sendto"></A>
<HR><p>
<FONT SIZE=+2>Send datagram on UDP server socket</FONT>
<DL>
<DT><b>proc sendto (string</b> <i>f</i><b>, string</b> <i>address</i><b>, string</b> <i>datagram</i><b>)</b>
<DT><b>proc sendto (integer</b> <i>f</i><b>, string</b> <i>address</i><b>, string</b> <i>datagram</i><b>)</b>
<p>
The <i>datagram</i> is sent by the UDP server socket <i>f</i>
to the destination <i>address</i>, which should be formatted as a
string of the form "ip.name.or.address:portnum".
The <A HREF="#select"><b>select</b></A> procedure may
be used to check or wait for <i>f</i> to be ready to take a datagram.
<p>
See <A HREF="#open"><b>open</b></A>, and see
also <A HREF="#recvfrom"><b>recvfrom</b></A>,
<A HREF="#recv"><b>recv</b></A>, and
<A HREF="#send"><b>send</b></A>.
</DL>

<A NAME="send_fd"></A>
<HR><p>
<FONT SIZE=+2>Send file descriptor</FONT>
<DL>
<DT><b>proc send_fd (string</b> <i>f</i><b>, integer</b> <i>fd</i><b>)</b>
<DT><b>proc send_fd (integer</b> <i>f</i><b>, integer</b> <i>fd</i><b>)</b>
<p>
The file descriptor <i>fd</i> is sent to a process that is
executing <A HREF="#recv_fd"><b>recv_fd</b></A>.
The stream designator <i>f</i> must refer to a Unix-domain socket.
<p>
The <A HREF="#select"><b>select</b></A> procedure may be used to
check or wait for <i>f</i> to be ready to take a file descriptor.
</DL>

<A NAME="setenv"></A>
<HR><p>
<FONT SIZE=+2>Set environment variable</FONT>
<DL>
<DT><b>proc setenv (string</b> <i>name</i><b>, string</b> <i>value</i><b>)</b>
<DT><b>proc setenv (string</b> <i>name</i><b>)</b>
<p>
The call <b>setenv&nbsp;(</b><i>name</i><b>,</b>&nbsp;<i>value</i><b>)</b>
gives the environment variable <i>name</i> the value <i>value</i>,
and omitting the value is equivalent to specifying the null string.
See also <A HREF="#getenv"><b>getenv</b></A>,
<A HREF="#unsetenv"><b>unsetenv</b></A>, and the mildly deprecated
<A HREF="#putenv"><b>putenv</b></A>.
</DL>

<A NAME="setgid"></A>
<HR><p>
<FONT SIZE=+2>Set group id</FONT>
<DL>
<DT><b>proc setgid (rd integer)</b>
<p>
On Unix systems, if the caller has ``superuser'' privileges,
<b>setgid</b> sets both the real and effective group id.  For
more humble callers, the effect depends on whether the BSD or
System V conventions are being followed locally.  Refer to the
Unix <i>setgid</i>(2) manual page for more details.
<p>
See also <A HREF="#getgid"><b>getgid</b></A>,
<A HREF="#getegid"><b>getegid</b></A>,
and <A HREF="#setuid"><b>setuid</b></A>.
</DL>

<A NAME="setpgrp"></A>
<HR><p>
<FONT SIZE=+2>Set process group id</FONT>
<DL>
<DT><b>proc setpgrp</b>
<p>
Make the current process a process group leader by making its
process group id equal to its process id.  This is done by calling
the Posix <i>setpgid</i>(2) routine with both arguments zero, not
by calling the non-Posix <i>setpgrp</i>(2) routine (because the latter
on some systems has the side-effect of making the process a session
leader as well).  See also <A HREF="#getpgrp"><b>getpgrp</b></A>
and <A HREF="#pid"><b>pid</b></A>.
</DL>

<A NAME="setrandom"></A>
<HR><p>
<FONT SIZE=+2>Set random seed</FONT>
<DL>
<DT><b>proc setrandom (rd integer)</b>
<p>
Establishes a starting point (``seed'') for pseudo-random number
generation.  If the <b>integer</b> argument is 0, the sequence will
be seeded by some unpredictable number related to the clock time.
See also <A HREF="#random"><b>random</b></A>.
</DL>

<A NAME="setuid"></A>
<HR><p>
<FONT SIZE=+2>Set user id</FONT>
<DL>
<DT><b>proc setuid (rd integer)</b>
<p>
On Unix systems, if the caller has ``superuser'' privileges,
<b>setuid</b> sets both the real and effective user id.  For
more humble callers, the effect depends on whether the BSD or
System V conventions are being followed locally.  Refer to the
Unix <i>setuid</i>(2) manual page for more details.
<p>
See also <A HREF="#getuid"><b>getuid</b></A>,
<A HREF="#geteuid"><b>geteuid</b></A>,
and <A HREF="#setgid"><b>setgid</b></A>.
</DL>

<A NAME="set_intslash"></A>
<HR><p>
<FONT SIZE=+2>Determine the type of integer quotients</FONT>
<DL>
<DT><b>proc set_intslash (boolean) : boolean</b>
<p>
Calling <b>set_intslash</b> is equivalent to retrieving the current
value of <A HREF="#intslash"><b>intslash</b></A> and setting it to a
new (<b>boolean</b>) value.  Using <b>set_intslash</b>, should you
have the bad taste to override the default <b>false</b> setting,
is arguably more polite than assigning directly to <b>intslash</b>.
See also <A HREF="#/">``<b>/</b>''</A>.
</DL>

<A NAME="set_magic"></A>
<HR><p>
<FONT SIZE=+2>Distinguish regular expressions, or not</FONT>
<DL>
<DT><b>proc set_magic (boolean) : boolean</b>
<p>
Calling <b>set_magic</b> is equivalent to retrieving the current
value of <A HREF="#magic"><b>magic</b></A> and setting it to a
new (<b>boolean</b>) value.  If you are writing utility routines
that depend on the value of <b>magic</b>, use of <b>set_magic</b>
is likely to be more convenient (and probably better style) than
fetching and assigning <b>magic</b> directly.
</DL>

<A NAME="shutdown"></A>
<A NAME="shut_rd"></A>
<A NAME="shut_wr"></A>
<A NAME="shut_rdwr"></A>
<HR><p>
<FONT SIZE=+2>Close I/O in one or both directions</FONT>
<DL>
<DT><b>proc shutdown (string</b> <i>f</i><b>, integer</b> <i>how</i><b>)</b>
<DT><b>proc shutdown (integer</b> <i>f</i><b>, integer</b> <i>how</i><b>)</b>
<DT><b>shut_rd : const integer</b>
<DT><b>shut_wr : const integer</b>
<DT><b>shut_rdwr : const integer</b>
<p>
If <i>f</i> designates a bidirectional stream that is (still) open
for the I/O direction(s) indicated in the <i>how</i>
value, which may be any one of the predefined constants <b>shut_rd</b>,
<b>shut_wr</b>, or <b>shut_rdwr</b>, then that direction (or both
directions, for <b>shut_rdwr</b>) is closed, using a call to
<i>shutdown</i>(2).
The underlying file descriptor remains open, however.
<p>
For TCP streams, <b>shutdown</b> can perform what is called a
``half-close'', which can be used, for example, to tell a peer
that you have finished sending data (thus making the peer see an
end-of-file condition on its input side) but that you would still like
to receive a reply on the same (still ``half-open'') connection.
<p>
It is an error to call <b>shutdown</b> on any other kind of stream,
except for a file descriptor that is not open at the SETL level (as
with <A HREF="#close"><b>close</b></A>), which is always acceptable
but may set <A HREF="#last_error"><b>last_error</b></A>.
<p>
See also <A HREF="#pump"><b>pump</b></A> and
<A HREF="#open"><b>open</b></A>.
</DL>

<A NAME="sign"></A>
<HR><p>
<FONT SIZE=+2>Numeric sign</FONT>
<DL>
<DT><b>op sign (integer</b> <i>x</i><b>) : integer</b>
<DT><b>op sign (real</b> <i>x</i><b>) : integer</b>
<p>
Returns -1, 0, or 1 according as <i>x</i>&nbsp;&lt;&nbsp;0,
<i>x</i>&nbsp;=&nbsp;0, or <i>x</i>&nbsp;&gt;&nbsp;0 respectively.
</DL>

<A NAME="sin"></A>
<HR><p>
<FONT SIZE=+2>Trigonometric sine</FONT>
<DL>
<DT><b>op sin (real) : real</b>
<DT><b>op sin (integer) : real</b>
</DL>

<A NAME="sinh"></A>
<HR><p>
<FONT SIZE=+2>Hyperbolic sine</FONT>
<DL>
<DT><b>op sinh (real) : real</b>
<DT><b>op sinh (integer) : real</b>
</DL>

<A NAME="span"></A>
<HR><p>
<FONT SIZE=+2>Consume initial substring</FONT>
<DL>
<DT><b>proc span (rw string</b> <i>s</i><b>, string</b> <i>p</i><b>) : string</b>
<p>
As many initial characters of <i>s</i> as appear in <i>p</i> are
removed from <i>s</i> and returned as the function result.
Otherwise, nothing happens to <i>s</i>, and the null string is returned.
See also <A HREF="#break"><b>break</b></A>,
<A HREF="#rspan"><b>rspan</b></A>, and
<A HREF="#rbreak"><b>rbreak</b></A>.
</DL>

<A NAME="split"></A>
<HR><p>
<FONT SIZE=+2>Split string into tuple</FONT>
<DL>
<DT><b>proc split (string</b> <i>s</i><b>, string</b> <i>p</i><b>) : tuple</b>
<DT><b>proc split (string</b> <i>s</i><b>, tuple</b> <i>p</i><b>) : tuple</b>
<DT><b>proc split (string</b> <i>s</i><b>) : tuple</b>
<p>
Substrings of <i>s</i> are returned as a <b>tuple</b>,
where the regular expression <i>p</i> is a ``delimiter''
pattern defaulting to whitespace, "[ \f\n\r\t\v]+".
<p>
The subject string <i>s</i> is considered to be surrounded by
strings satisfying the delimiter pattern <i>p</i>, and <b>split</b>
returns the strings between the delimiters.  So for example
<b>split(</b>"David Bacon::WGP:"<b>, </b>":"<b>)</b> is
<b>[</b>"David Bacon"<b>,</b> ""<b>,</b> "WGP"<b>,</b> ""<b>]</b>,
but when a line is split into whitespace-delimited words, extra
whitespace on either end of the line does not appear as a null
string in the result of <b>split</b>.  This is because the leading
or trailing whitespace merges with the added surrounding whitespace
from the delimiter pattern's point of view, and indeed there will be
some end-merging whenever <i>p</i> matches 2 or more copies of a
leading or trailing substring of <i>s</i>.
<p>
As a special case, <b>split(</b>""<b>,</b>&nbsp;<i>p</i><b>)</b>&nbsp;=&nbsp;<b>[]</b>
for any pattern <i>p</i>.  (Splitting the null string yields the null
tuple.)  If you would prefer to regard the semantics of this case
as nothing special, you can visualize that when the
imaginary surrounding delimiter-satisfying strings actually touch
each other, they fuse into just one such satisfying string, leaving
no ``between'' in which to find the null string lurking, even for
a delimiter pattern like ":".
<p>
See also <A HREF="#magic"><b>magic</b></A>.
</DL>

<A NAME="sqrt"></A>
<HR><p>
<FONT SIZE=+2>Square root</FONT>
<DL>
<DT><b>op sqrt (real) : real</b>
<DT><b>op sqrt (integer) : real</b>
</DL>

<A NAME="status"></A>
<HR><p>
<FONT SIZE=+2>Last subprocess exit status</FONT>
<DL>
<DT><b>status : integer</b>
<p>
Always contains the status of the subprocess that last exited and
was waited for by <A HREF="#filter"><b>filter</b></A>,
<A HREF="#system"><b>system</b></A>, or <A HREF="#wait"><b>wait</b></A>,
or by <A HREF="#close"><b>close</b></A> as applied to a pipe, pump,
or line-pump stream.
<p>
See also <A HREF="#open"><b>open</b></A>,
<A HREF="#pipe_from_child"><b>pipe_from_child</b></A>,
<A HREF="#pipe_to_child"><b>pipe_to_child</b></A>, and
<A HREF="#pump"><b>pump</b></A>.
</DL>

<A NAME="std..."></A>
<A NAME="stdin"></A>
<A NAME="stdout"></A>
<A NAME="stderr"></A>
<HR><p>
<FONT SIZE=+2>Standard input, output, and error streams</FONT>
<DL>
<DT><b>stdin : const integer =</b> 0
<DT><b>stdout : const integer =</b> 1
<DT><b>stderr : const integer =</b> 2
<p>
See also <A HREF="#open"><b>open</b></A>.
</DL>

<A NAME="store_..."></A>
<A NAME="store_char"></A>
<A NAME="store_short"></A>
<A NAME="store_int"></A>
<A NAME="store_long"></A>
<A NAME="store_float"></A>
<A NAME="store_double"></A>
<A NAME="store_long_double"></A>
<A NAME="store_string"></A>
<A NAME="store_c_string"></A>
<HR><p>
<FONT SIZE=+2>Machine memory write</FONT>
<DL>
<DT><b>proc store_char (integer</b> <i>i</i><b>, integer</b> <i>address</i><b>)</b>
<DT><b>proc store_short (integer</b> <i>i</i><b>, integer</b> <i>address</i><b>)</b>
<DT><b>proc store_int (integer</b> <i>i</i><b>, integer</b> <i>address</i><b>)</b>
<DT><b>proc store_long (integer</b> <i>i</i><b>, integer</b> <i>address</i><b>)</b>
<DT><b>proc store_float (real</b> <i>r</i><b>, integer</b> <i>address</i><b>)</b>
<DT><b>proc store_double (real</b> <i>r</i><b>, integer</b> <i>address</i><b>)</b>
<DT><b>proc store_long_double (real</b> <i>r</i><b>, integer</b> <i>address</i><b>)</b>
<DT><b>proc store_string (string</b> <i>s</i><b>, integer</b> <i>address</i><b>)</b>
<DT><b>proc store_c_string (string</b> <i>s</i><b>, integer</b> <i>address</i><b>)</b>
<p>
These are extremely low-level, machine-dependent, uncontrolled, dangerous
procedures to clobber specific locations in the computer's memory.
The <b>integer</b> <i>address</i> is assumed to contain a machine
address to which some number <i>n</i> of bytes will be written.
For <b>store_string</b>, <i>n</i>&nbsp;=&nbsp;<b>#</b><i>s</i>.  For
<b>store_c_string</b>, <i>n</i> is 1 more than the lesser of
<b>#</b><i>s</i> and the number of bytes before the first
null character ("\0") in <i>s</i> (a trailing null character is
always written for <b>store_c_string</b>).
For <b>store_char</b>, <i>n</i>&nbsp;=&nbsp;1.
For all the rest, <i>n</i> is machine-dependent.  These procedures are
typically only used if you have customized a C library interface
rather roughly and want to store into structs based on pointers to
them without going to the trouble of mapping the structs to SETL
objects properly.
<p>
See also
<A HREF="#fetch_..."><b>fetch_...</b></A>,
<A HREF="#pack_..."><b>pack_...</b></A>,
<A HREF="#unpack_..."><b>unpack_...</b></A>, and
<A HREF="#mem_copy"><b>mem_copy</b></A>.
</DL>

<A NAME="str"></A>
<HR><p>
<FONT SIZE=+2>String representation of value</FONT>
<DL>
<DT><b>op str (var</b> <i>x</i><b>) : string</b>
<p>
The argument <i>x</i> is converted to a <b>string</b> such
that the result could be converted back to the same value
using <A HREF="#unstr"><b>unstr</b></A>.  (Some loss of
precision is possible in the case of <b>real</b> <i>x</i>, however.
This can be overcome by the use of <A HREF="#fixed"><b>fixed</b></A>
or <A HREF="#floating"><b>floating</b></A> in place of <b>str</b>
on <b>real</b>s.  Also, for a procedure reference <i>x</i>,
<b>unstr&nbsp;str</b>&nbsp;<i>x</i> is not defined, because
<b>str</b>&nbsp;<i>x</i>&nbsp;=&nbsp;"&lt;ROUTINE&gt;".)  For a <b>string</b> <i>x</i>
that does not have the form of a SETL identifier (alphabetic
character followed by 0 or more alphanumeric or underscore
characters), the result <b>string</b> is identical to <i>x</i>
except that each apostrophe (') is twinned (producing two apostrophes
in a row), and an apostrophe is added at each end.  If a <b>string</b>
<i>x</i> does have the form of a SETL identifier, it is returned
unmolested (and this is indeed recognizable by <b>unstr</b> as
a <b>string</b>).
<p>
See also also <A HREF="#pretty"><b>pretty</b></A>,
<A HREF="#unpretty"><b>unpretty</b></A>,
<A HREF="#whole"><b>whole</b></A>, and
<A HREF="#strad"><b>strad</b></A>.
</DL>

<A NAME="strad"></A>
<HR><p>
<FONT SIZE=+2>Radix-prefixed string representation of integer</FONT>
<DL>
<DT><b>proc strad (integer</b> <i>x</i><b>, integer</b> <i>radix</i><b>) : string</b>
<p>
The <b>integer</b> argument <i>x</i> is converted to a <b>string</b>
representing its value as an explicit-radix denotation.  The
<i>radix</i> argument, which must be an <b>integer</b> in the range
2 to 36, give the radix (``base'') for the denotation, which will be
produced in the form "radix#digits", where the radix is
represented in decimal and the digits after the sharp sign are some
subset of the characters "0" through "9" and lowercase "a"
through "z".  For example,
<p>
  <DL>
  <DT><b>strad (</b>10<b>,</b> 10<b>) =</b> "10#10"
  <DT><b>strad (</b>10<b>,</b> 16<b>) =</b> "16#a"
  <DT><b>strad (</b>10<b>,</b> 2<b>) =</b> "2#1010"
  <DT><b>strad (-</b>899<b>,</b> 36<b>) =</b> "-36#oz"
  </DL>
<p>
Also, the following identity holds for any <b>integer</b> <i>x</i>
when the <b>integer</b> <i>radix</i> is in the range 2 through 36:
<p>
  <DL>
  <DT><b><a href="#val">val</a> strad (</b><i>x</i><b>,</b> <i>radix</i><b>) =</b> <i>x</i>
  </DL>
<p>
Note that <b>val</b> in the above identity can be replaced by the more
general <A HREF="#unstr"><b>unstr</b></A>; <b>strad</b> always produces
a denotation acceptable to them both.
<p>
See also <A HREF="#str"><b>str</b></A> and
<A HREF="#whole"><b>whole</b></A>.
</DL>

<A NAME="sub"></A>
<HR><p>
<FONT SIZE=+2>Substitute first occurrence of pattern in string</FONT>
<DL>
<DT><b>proc sub (rw string</b> <i>s</i><b>, string</b> <i>p</i><b>) : string</b>
<DT><b>proc sub (rw string</b> <i>s</i><b>, tuple</b> <i>p</i><b>) : string</b>
<DT><b>proc sub (rw string</b> <i>s</i><b>, string</b> <i>p</i><b>, string</b> <i>r</i><b>) : string</b>
<DT><b>proc sub (rw string</b> <i>s</i><b>, tuple</b> <i>p</i><b>, string</b> <i>r</i><b>) : string</b>
<p>
The leftmost occurrence in <i>s</i>, if any, of the pattern given
by the regular expression <i>p</i> is replaced by <i>r</i>, which
defaults to the null string.  The substring of <i>s</i> replaced
by this operation is returned as a <b>string</b>, unless <i>p</i>
did not occur in <i>s</i>, in which case <b>om</b> is returned and
<i>s</i> is left unmodified.  See also <A HREF="#gsub"><b>gsub</b></A>,
<A HREF="#mark"><b>mark</b></A>, and <A HREF="#gmark"><b>gmark</b></A>.
<p>
[Need rules for regexps, as mentioned under <A HREF="#gmark"><b>gmark</b></A>.]
</DL>

<A NAME="subset"></A>
<HR><p>
<FONT SIZE=+2>Subset test</FONT>
<DL>
<DT><b>op subset (set</b> <i>ss</i><b>, set</b> <i>s</i><b>) : boolean</b>
<p>
Returns <b>true</b> if <i>ss</i> is a subset of <i>s</i>.
Thus
<b>(</b><i>ss</i>&nbsp;<b>subset</b>&nbsp;<i>s</i><b>)&nbsp;=&nbsp;(</b><i>s</i>&nbsp;<A HREF="#incs"><b>incs</b></A>&nbsp;<i>ss</i><b>)</b>.
</DL>

<A NAME="symlink"></A>
<HR><p>
<FONT SIZE=+2>Create symbolic link</FONT>
<DL>
<DT><b>proc symlink (string</b> <i>f</i><b>, string</b> <i>new</i><b>)</b>
<p>
Atomically create a symbolic link to <i>f</i> under the filename
<i>new</i> using <i>symlink</i>(2), if
<i>new</i> does not exist before the call.  There is no return value,
but calling <A HREF="#clear_error"><b>clear_error</b></A> before the
operation and inspecting <A HREF="#last_error"><b>last_error</b></A>
after it can be used to determine whether the operation was successful.
Thus <b>symlink</b> can be used to implement a ``test and set'' mutex
lock in the file system:  if <i>new</i> already exists, the operation
will fail; and if it doesn't exist, it will be created and the calling
process will then ``own'' the lock.  Note that <i>f</i> may or may not
refer to an existing file.  In any case, if <i>new</i> ``points to''
<i>f</i>, such as after a successful call to <b>symlink</b>, subsequent
attempts to read or write <i>new</i> will attempt to read or write
<i>f</i>.
<p>
See also <A HREF="#link"><b>link</b></A>,
<A HREF="#readlink"><b>readlink</b></A>,
<A HREF="#unlink"><b>unlink</b></A>,
<A HREF="#lexists"><b>lexists</b></A>, and
<A HREF="#fexists"><b>fexists</b></A>.
</DL>

<A NAME="system"></A>
<HR><p>
<FONT SIZE=+2>Execute system command in subshell</FONT>
<DL>
<DT><b>proc system (string</b> <i>cmd</i><b>) : integer</b>
<p>
The command <i>cmd</i> is passed to the Posix <i>system</i>(3)
routine for execution as ``/bin/sh -c <i>cmd</i>'', so the
<i>cmd</i> may itself include parameters to the program to be
executed in the subshell.  The subshell's exit status is returned,
and also made available in <A HREF="#status"><b>status</b></A>.
</DL>

<A NAME="sys_read"></A>
<HR><p>
<FONT SIZE=+2>Low-level read</FONT>
<DL>
<DT><b>proc sys_read (integer</b> <i>fd</i><b>, integer</b> <i>n</i><b>) : string</b>
<p>
This procedure bypasses SETL buffering and calls the Posix
<i>read</i>(2) routine directly.  The file descriptor <i>fd</i>
may or may not be open at the SETL level (see <A HREF="#open"><b>open</b></A>).
Up to <i>n</i> bytes are read from the presumed input stream and
returned as a <b>string</b>.  It may be less than <i>n</i> bytes long
if the end of the input is encountered before <i>n</i> bytes have been
read or if the <i>fd</i> is a socket or pipe or pump where the output
process does a system-level ``write'' or ``send'' or flushes its
buffer after sending fewer than <i>n</i> bytes.
</DL>

<A NAME="sys_write"></A>
<HR><p>
<FONT SIZE=+2>Low-level write</FONT>
<DL>
<DT><b>proc sys_write (integer</b> <i>fd</i><b>, string</b> <i>s</i><b>) : integer</b>
<p>
This procedure bypasses SETL buffering and calls the Posix
<i>write</i>(2) routine directly.  The file descriptor <i>fd</i>
may or may not be open at the SETL level (see <A HREF="#open"><b>open</b></A>).
An attempt is made to write all <b>#</b><i>s</i> bytes of <i>s</i>.
This should succeed except in rather obscure circumstances, but in
any case the number of bytes actually written is returned.
</DL>

<A NAME="tan"></A>
<HR><p>
<FONT SIZE=+2>Trigonometric tangent</FONT>
<DL>
<DT><b>op tan (real) : real</b>
<DT><b>op tan (integer) : real</b>
</DL>

<A NAME="tanh"></A>
<HR><p>
<FONT SIZE=+2>Hyperbolic tangent</FONT>
<DL>
<DT><b>op tanh (real) : real</b>
<DT><b>op tanh (integer) : real</b>
</DL>

<A NAME="tie"></A>
<HR><p>
<FONT SIZE=+2>Autoflush output stream <i>per</i> other stream input</FONT>
<DL>
<DT><b>proc tie (string, string)</b>
<DT><b>proc tie (string, integer)</b>
<DT><b>proc tie (integer, string)</b>
<DT><b>proc tie (integer, integer)</b>
<p>
The arguments designate open streams.  After the call to <b>tie</b>,
whenever an input operation such as <A HREF="#reada"><b>reada</b></A> or
<A HREF="#geta"><b>geta</b></A> is requested on one of the two streams,
any buffered output on the other is written out first.
See also <A HREF="#flush"><b>flush</b></A>.
<p>
There is no <b>untie</b> routine; it does not seem useful.
</DL>

<A NAME="time"></A>
<HR><p>
<FONT SIZE=+2>CPU time in milliseconds</FONT>
<DL>
<DT><b>proc time : integer</b>
<p>
This gives the total amount of CPU time used by the current process
and all its child processes that have exited and been waited for
(automatically or by <A HREF="#wait"><b>wait</b></A>),
in milliseconds.  This includes both ``user'' time and time spent by
the ``system'' on behalf of the user.
See also <A HREF="#clock"><b>clock</b></A> and
<A HREF="#tod"><b>tod</b></A>.
</DL>

<A NAME="tmpnam"></A>
<HR><p>
<FONT SIZE=+2>Unique temporary filename</FONT>
<DL>
<DT><b>proc tmpnam : string</b>
<p>
This is an interface to the Posix <i>tmpnam</i>(3) routine.
</DL>

<A NAME="to_lower"></A>
<A NAME="to_upper"></A>
<HR><p>
<FONT SIZE=+2>Alphabetic case conversions</FONT>
<DL>
<DT><b>op to_lower (string) : string</b>
<DT><b>op to_upper (string) : string</b>
<p>
A string of length equal to that of the argument is returned.
Characters other than A-Z and a-z are unaffected.
</DL>

<A NAME="tod"></A>
<HR><p>
<FONT SIZE=+2>Calendar time in milliseconds</FONT>
<DL>
<DT><b>proc tod : integer</b>
<p>
This is the total number of milliseconds that have elapsed in the
``epoch'' beginning 1 January 1970 UTC.
See also <A HREF="#clock"><b>clock</b></A>,
<A HREF="#time"><b>time</b></A>, <A HREF="#date"><b>date</b></A>, and
<A HREF="#fdate"><b>fdate</b></A>.
</DL>

<A NAME="true"></A>
<HR><p>
<FONT SIZE=+2>Predefined ``true'' boolean value</FONT>
<DL>
<DT><b>true : const boolean</b>
<p>
See also <A HREF="#false"><b>false</b></A>.
</DL>

<A NAME="type"></A>
<HR><p>
<FONT SIZE=+2>Type of SETL value</FONT>
<DL>
<DT><b>op type (var) : string</b>
<p>
Returns "ATOM", "BOOLEAN", "INTEGER", "REAL", "SET", "STRING",
"TUPLE", "ROUTINE", or "OM".
</DL>

<A NAME="umask"></A>
<HR><p>
<FONT SIZE=+2>Set file creation mask</FONT>
<DL>
<DT><b>proc umask : integer</b>
<DT><b>proc umask (integer) : integer</b>
<p>
This is an interface to the Posix routine <i>umask</i>(2).  Both
forms of the call return the current value of the mask, and the
second form also changes it to a new value.  For example,
<p>
<DL>
<DT><b>umask(</b>8#022<b>);</b>
</DL>
<p>
arranges that files created by the SETL program and its child
processes will not be writable by other users or groups unless
subsequently made so by the <i>chmod</i>(1) command.
See also <A HREF="#system"><b>system</b></A> and
<A HREF="#open"><b>open</b></A>.
</DL>

<A NAME="ungetc"></A>
<HR><p>
<FONT SIZE=+2>Push character(s) back on input stream</FONT>
<DL>
<DT><b>proc ungetc (string</b> <i>f</i><b>, string</b> <i>c</i><b>)</b>
<DT><b>proc ungetc (integer</b> <i>f</i><b>, string</b> <i>c</i><b>)</b>
<p>
Immediately after any input operation on the stream <i>f</i> that
yielded at least one character <i>c</i>, the call
<b>ungetc(</b><i>f</i><b>,</b><i>c</i><b>)</b> ``pushes back'' the
character <i>c</i> on the stream <i>f</i> so that <i>c</i> will appear
as the next input character.  At least one character of pushback is
guaranteed after at least one character has been fetched.
<p>See also <A HREF="#peekc"><b>peekc</b></A> and
<A HREF="#ungetchar"><b>ungetchar</b></A>.
</DL>

<A NAME="ungetchar"></A>
<HR><p>
<FONT SIZE=+2>Push character(s) back on standard input</FONT>
<DL>
<DT><b>proc ungetchar (string</b> <i>c</i><b>)</b>
<p>
The call <b>ungetchar&nbsp;(</b><i>c</i><b>)</b> is the same as
<A HREF="#ungetc"><b>ungetc</b></A>&nbsp;<b>(<A HREF="#std...">stdin</A>,</b>&nbsp;<i>c</i><b>)</b>.
</DL>

<A NAME="unhex"></A>
<HR><p>
<FONT SIZE=+2>Convert from hexadecimal</FONT>
<DL>
<DT><b>op unhex (string) : string</b>
<p>
This is the inverse of <A HREF="#hex"><b>hex</b></A>, but returns
<b>om</b> if its argument is not a string consisting of an even number
of (case-insensitively recognized) hexadecimal characters.
</DL>

<A NAME="unlink"></A>
<HR><p>
<FONT SIZE=+2>Destroy file reference</FONT>
<DL>
<DT><b>proc unlink (string</b> <i>f</i><b>)</b>
<p>
Remove the name <i>f</i> from the file system.  If <i>f</i> is the
last reference (link) to the underlying file, including ``invisible''
references from running processes, the file will be destroyed.
<p>
See also <A HREF="#link"><b>link</b></A>,
<A HREF="#symlink"><b>symlink</b></A>,
<A HREF="#readlink"><b>readlink</b></A>,
<A HREF="#fexists"><b>fexists</b></A>, and
<A HREF="#lexists"><b>lexists</b></A>.
</DL>

<A NAME="unpack_..."></A>
<A NAME="unpack_char"></A>
<A NAME="unpack_short"></A>
<A NAME="unpack_int"></A>
<A NAME="unpack_long"></A>
<A NAME="unpack_float"></A>
<A NAME="unpack_double"></A>
<A NAME="unpack_long_double"></A>
<HR><p>
<FONT SIZE=+2>Byte unpacking</FONT>
<DL>
<DT><b>op unpack_char (string) : integer</b>
<DT><b>op unpack_short (string) : integer</b>
<DT><b>op unpack_int (string) : integer</b>
<DT><b>op unpack_long (string) : integer</b>
<DT><b>op unpack_float (string) : real</b>
<DT><b>op unpack_double (string) : real</b>
<DT><b>op unpack_long_double (string) : real</b>
<p>
These are low-level, machine-dependent (but not very dangerous)
operators for interpreting strings as representations of the
predefined C types on the machine you are running SETL on.
You must pass a string of the right length
for the C type suggested by the operator name (the SETL
implementation should check this).
<p>
See also
<A HREF="#pack_..."><b>pack_...</b></A>,
<A HREF="#fetch_..."><b>fetch_...</b></A>, and
<A HREF="#store_..."><b>store_...</b></A>.
</DL>

<A NAME="unpretty"></A>
<HR><p>
<FONT SIZE=+2>``Unprettify'' string</FONT>
<DL>
<DT><b>op unpretty (string</b> <i>s</i><b>) : string</b>
<p>
The <b>string</b> <i>s</i> should be in ``pretty'' form, although
the <b>unpretty</b> operator is somewhat liberal in what
it accepts relative to what <A HREF="#pretty"><b>pretty</b></A>
produces.  However, <i>s</i> must still begin and end with an apostrophe
(') or begin and end with a double quote (").
<!-- (which can be written
in a SETL literal as ", \", "", or a few less useful ways). -->
<p>
Inside <i>s</i>, every character must be one of the 95 characters
ASCII considers ``fit to print'', including blank.  The
<b>unpretty</b> operator makes the following interpretations
in transforming <i>s</i> into an unrestricted <b>string</b>:
<p>
Backslash followed by any of the 32 ``glyphs'' (that is,
all of the ASCII ``printable'' characters apart from
alphanumerics and blank) means just that glyph.
<p>
Backslash followed by up to 3 octal digits means a
character having the bit pattern suggested by the digits,
as in C.
<p>
Backslash followed by x and then 1 or 2 hexadecimal
digits (0123456789abcdefABCDEF) is an alternative to
the octal escape.
<p>
Backslash followed by a, b, f, n, r, t, or v means the same
thing as it does in C (i.e., audible alarm, backspace,
formfeed, newline, carriage return, horizontal tab, or
vertical tab, respectively).
<p>
Currently these are exactly the rules governing what
can be in a literal character string in SETL source code,
and the escape sequences have the same meanings.
<p>
The rules may be liberalized in the future, however,
because I don't think insisting on the use of octal or
hexadecimal escapes for specifying, say, the ESC character
is more portable than just embedding the thing right into
a string---a good ASCII&lt;-&gt;EBCDIC translation of the source
code would leave ESC meaning ESC either way, whereas the
use of \x1b (the ASCII code for ESC) would be an error
in an EBCDIC environment if the source code was just
translated and otherwise unmodified.  So maybe you want an escape
convention that allows special characters to be identified by name,
e.g., ESC, SOH, etc.  Suggestions are welcome.
<p>
See also <A HREF="#pretty"><b>pretty</b></A>,
<A HREF="#unstr"><b>unstr</b></A>, and
<A HREF="#str"><b>str</b></A>.
</DL>

<A NAME="unsetenv"></A>
<HR><p>
<FONT SIZE=+2>Remove environment variable definition</FONT>
<DL>
<DT><b>op unsetenv (string</b> <i>name</i><b>)</b>
<p>
If the environment variable <i>name</i> was defined, undefine it.
Note that this is not the same as setting it to the null string.
See also <A HREF="#setenv"><b>setenv</b></A>,
<A HREF="#getenv"><b>getenv</b></A>, and poor old
<A HREF="#putenv"><b>putenv</b></A>.
</DL>

<A NAME="unstr"></A>
<HR><p>
<FONT SIZE=+2>Read value from string</FONT>
<DL>
<DT><b>op unstr (string</b> <i>s</i><b>) : var</b>
<p>
Essentially, this is the inverse of <A HREF="#str"><b>str</b></A>,
but more liberal in what it accepts relative to what <b>str</b>
produces.  In particular, quoted strings can use either
the apostrophe (') or the double quote (") as the
beginning and ending character <i>q</i>.  Whichever one is
used is also the one that should be twinned internally to
represent <i>q</i>.  As a convenience (to be consistent with
what <A HREF="#reada"><b>reada</b></A> accepts), each backslash
followed immediately by a true newline is silently absorbed when
it occurs in a quoted string.  Apart from the interpretation
of <i>qq</i> and the backslash-newline absorption, <b>unstr</b>
is completely literal about how it interprets what is inside a
quoted string.  Other types are recognized by their first
non-whitespace character, except that numeric types don't
necessarily get resolved to <b>real</b> or <b>integer</b> that
early.
<p>
The <A HREF="#denotype"><b>denotype</b></A> operator can be used
to check whether a string is acceptable to <b>unstr</b>.
<p>
See also <A HREF="#val"><b>val</b></A>,
<A HREF="#reads"><b>reads</b></A>, and
<A HREF="#unpretty"><b>unpretty</b></A>.
</DL>

<A NAME="val"></A>
<HR><p>
<FONT SIZE=+2>Read numeric value from string</FONT>
<DL>
<DT><b>op val (string) : integer</b>
<DT><b>op val (string) : real</b>
<p>
This is similar to <A HREF="#unstr"><b>unstr</b></A> but expects a
numeric denotation as an argument.  Unlike <b>unstr</b>, however, it
will return <b>om</b> instead of raising an exception if the argument
string does not satisfy its syntactic requirements.
<p>
See also <A HREF="#denotype"><b>denotype</b></A> and
<A HREF="#strad"><b>strad</b></A>.
</DL>

<A NAME="wait"></A>
<HR><p>
<FONT SIZE=+2>Wait for subprocess to complete</FONT>
<DL>
<DT><b>proc wait : integer</b>
<DT><b>proc wait (boolean) : integer</b>
<p>
The call <b>wait()</b> (or <b>wait</b>) is equivalent to
<b>wait&nbsp;(true)</b>, which means block until some child process
exits.  The return value is the process id of a child process that has
exited, or 0 if <b>wait&nbsp;(false)</b> was called but no child has
terminated yet.
<p>
Waiting is automatic for child processes started by
<A HREF="#system"><b>system</b></A> or
<A HREF="#filter"><b>filter</b></A>, and happens upon
<A HREF="#close"><b>close</b></A> for those started by
<A HREF="#pipe_from_child"><b>pipe_from_child</b></A>,
<A HREF="#pipe_to_child"><b>pipe_to_child</b></A>,
<A HREF="#pump"><b>pump</b></A>, or
<A HREF="#open"><b>open</b></A> on a pipe, pump, or line-pump stream.
Only in the case of <A HREF="#fork"><b>fork</b></A> is it
necessary (or even wise) to call <b>wait</b> to clear the child
process entry from the kernel's record.  This wait-and-clear sequence
is sometimes called ``reaping'' the child process.  The process itself
is called a ``zombie'' between the time it exits and the time it is
reaped.  If the parent exits with zombies outstanding, they are
reaped automatically by the ancestor of all processes on the host
system.  That primordial process, incidentally, also inherits as
direct children any unterminated processes that are ``orphaned'' by a
parent that exits before they do.
<p>
See also <A HREF="#exec"><b>exec</b></A>,
<A HREF="#status"><b>status</b></A>, and
<A HREF="#time"><b>time</b></A>.
</DL>

<A NAME="whole"></A>
<HR><p>
<FONT SIZE=+2>Format integer</FONT>
<DL>
<DT><b>proc whole (integer</b> <i>x</i><b>, integer</b> <i>w</i><b>) : string</b>
<DT><b>proc whole (real</b> <i>x</i><b>, integer</b> <i>w</i><b>) : string</b>
<p>
The number <i>x</i> is converted to a string of at least <i>w</i>
characters, with blank padding on the left if necessary if <i>w</i>
is positive.  If <i>w</i> is negative, the result is padded on the
right as necessary to reach <b>abs</b>&nbsp;<i>w</i> characters.
For <b>integer</b> <i>x</i>,
<b>whole&nbsp;(</b><i>x</i><b>,</b>&nbsp;0<b>)</b> is the same as
<A HREF="#str"><b>str</b></A>&nbsp;<i>x</i>.
<p>
However, if <i>x</i> is <b>real</b>, then <b>whole</b> treats it as
<A HREF="#round"><b>round</b></A>&nbsp;<i>x</i>.
<p>
See also <A HREF="#fixed"><b>fixed</b></A>
<A HREF="#floating"><b>floating</b></A>, and
<A HREF="#strad"><b>strad</b></A>.
</DL>

<A NAME="with"></A>
<HR><p>
<FONT SIZE=+2>Set plus one element</FONT>
<DL>
<DT><b>op with (set, var) : set</b>
<p>
Definition:
<i>s</i>&nbsp;<b>with</b>&nbsp;<i>x</i>&nbsp;=&nbsp;<i>s</i>&nbsp;<b>+&nbsp;{</b><i>x</i><b>}</b>.
</DL>

<A NAME="write"></A>
<HR><p>
<FONT SIZE=+2>Write value(s) to standard output</FONT>
<DL>
<DT><b>proc write (...)</b>
<p>
Equivalent to
<A HREF="#writea"><b>writea</b></A>&nbsp;<b>(<A HREF="#std...">stdout</A>, ...)</b>.
</DL>

<A NAME="writea"></A>
<HR><p>
<FONT SIZE=+2>Write value(s) to output stream</FONT>
<DL>
<DT><b>proc writea (string</b> <i>f</i><b>, ...)</b>
<DT><b>proc writea (integer</b> <i>f</i><b>, ...)</b>
<p>
There can be 0 or more arguments after <i>f</i>, of any type.
They are sent in sequence to the stream <i>f</i>, separated by single
spaces and followed by a newline character.  All of them are written
as if they had been passed through <A HREF="#str"><b>str</b></A> first,
with no exception for strings (contrast
<A HREF="#printa"><b>printa</b></A>).  Values written by <b>writea</b>,
except for atoms (see <A HREF="#newat"><b>newat</b></A>) and
procedure references (see <A HREF="#routine"><b>routine</b></A>),
can be read by <A HREF="#reada"><b>reada</b></A>.  This procedure is
functionally identical to <A HREF="#putb"><b>putb</b></A>.
</DL>

<HR>

<PRE>
       <A HREF="http://cs.nyu.edu/~bacon/">dB</A>
</PRE>

</BODY>
</HTML>
